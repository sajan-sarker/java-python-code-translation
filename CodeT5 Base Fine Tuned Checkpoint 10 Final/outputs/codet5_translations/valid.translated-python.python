def calculateSquareSum ( n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT fibo = [ 0 ] * ( n + 1 ) NEW_LINE fibo [ 0 ] = 0 NEW_LINE fibo [ 1 ] = 1 NEW_LINE sum = ( fibo [ 0 ] * fibo [ 0 ] ) + ( fibo [ 1 ] * fibo [ 1 ] ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] NEW_LINE sum += ( fibo [ i ] * fibo [ i ] ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 6 NEW_LINE print ( " Sum ▁ of ▁ squares ▁ of ▁ Fibonacci ▁ numbers ▁ is ▁ : " , calculateSquareSum ( n ) ) NEW_LINE
s = input ( ) NEW_LINE t = input ( ) NEW_LINE n = len ( s ) NEW_LINE k = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if s [ i : i + n ] == t : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT if k % 2 == 0 : NEW_LINE INDENT ans += n * ( n - 1 ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += n * ( n - 1 ) - 1 NEW_LINE DEDENT print ( ans % ( 10 ** 9 + 7 ) ) NEW_LINE
while 1 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = input ( ) . split ( ) NEW_LINE a . append ( s [ 0 ] ) NEW_LINE s = s [ 1 ] NEW_LINE a . append ( s [ 2 ] ) NEW_LINE s = s [ 3 ] NEW_LINE a . append ( s [ 4 ] ) NEW_LINE s = s [ 5 ] NEW_LINE DEDENT m = max ( a ) NEW_LINE for i in range ( m , 0 , - 1 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if a [ i ] [ j ] == i : print ( s [ i ] + " , " + a [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if a [ i ] == 0 and a [ i - 1 ] == 1 and a [ i + 1 ] == 1 : NEW_LINE INDENT ans += 1 NEW_LINE if i <= n - 4 : NEW_LINE INDENT if a [ i + 2 ] == 0 and a [ i + 3 ] == 0 : NEW_LINE INDENT i += 3 NEW_LINE DEDENT else : NEW_LINE INDENT i += 2 NEW_LINE DEDENT DEDENT DEDENT elif a [ i ] == 0 and a [ i + 1 ] == 1 : NEW_LINE INDENT if a [ i - 1 ] == 1 and a [ i + 2 ] == 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += 2 NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
def val ( c ) : NEW_LINE INDENT if ( c >= '0' and c <= '9' ) : NEW_LINE INDENT return int ( c - '0' ) NEW_LINE DEDENT else : NEW_LINE INDENT return int ( c - ' A ' + 10 ) NEW_LINE DEDENT DEDENT def toDeci ( str , base ) : NEW_LINE INDENT len = len ( str ) NEW_LINE power = 1 NEW_LINE num = 0 NEW_LINE for i in range ( len - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( val ( str [ i ] ) >= base ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT num += val ( str [ i ] ) * power NEW_LINE power = power * base NEW_LINE DEDENT return num NEW_LINE DEDENT def checkCorrespond ( str , x ) : NEW_LINE INDENT counter = 0 NEW_LINE n = len ( str ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 2 , 36 ) : NEW_LINE INDENT if ( toDeci ( str [ i ] , j ) == x ) : NEW_LINE INDENT
n = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( len ( n ) ) : NEW_LINE INDENT l . append ( int ( n [ i ] ) ) NEW_LINE DEDENT m = max ( l ) NEW_LINE for i in range ( len ( n ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if n [ i ] == '0' : NEW_LINE INDENT n [ i ] = '9' NEW_LINE DEDENT else : NEW_LINE INDENT n [ i ] = str ( n [ i ] ) NEW_LINE DEDENT DEDENT print ( m ) NEW_LINE
n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > b [ i ] : NEW_LINE INDENT print ( " YES " ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
import heapq NEW_LINE from collections import deque NEW_LINE from enum import Enum NEW_LINE import sys NEW_LINE import math NEW_LINE from _heapq import heappush , heappop NEW_LINE BIG_NUM = 2000000000 NEW_LINE HUGE_NUM = 99999999999999999 NEW_LINE MOD = 1000000007 NEW_LINE EPS = 0.000000001 NEW_LINE sys . setrecursionlimit ( 100000 ) NEW_LINE N = int ( input ( ) ) NEW_LINE A = [ ] NEW_LINE B = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE A . append ( a ) NEW_LINE B . append ( b ) NEW_LINE DEDENT A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if A [ i ] [ 1 ] > B [ i ] [ 1 ] : NEW_LINE INDENT ans = max ( ans , len ( A ) ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def maxDivide ( a , b ) : NEW_LINE INDENT while ( a % b == 0 ) : NEW_LINE INDENT a = a // b NEW_LINE DEDENT return a NEW_LINE DEDENT def isUgly ( no ) : NEW_LINE INDENT no = maxDivide ( no , 2 ) NEW_LINE no = maxDivide ( no , 3 ) NEW_LINE no = maxDivide ( no , 5 ) NEW_LINE return ( no == 1 ) NEW_LINE DEDENT def getNthUglyNo ( n ) : NEW_LINE INDENT i = 1 NEW_LINE count = 1 NEW_LINE while ( n > count ) : NEW_LINE INDENT i += 1 NEW_LINE if ( isUgly ( i ) == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return i NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT no = getNthUglyNo ( 150 ) NEW_LINE print ( " 150th ▁ ugly ▁ no . ▁ is " , no ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE d = { } NEW_LINE for i in s : NEW_LINE INDENT if i in d : NEW_LINE INDENT d [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] = 1 NEW_LINE DEDENT DEDENT for i in d : NEW_LINE INDENT print ( i , end = ' ' ) NEW_LINE DEDENT
import math NEW_LINE def perfectSquares ( l , r ) : NEW_LINE INDENT number = math . ceil ( math . sqrt ( l ) ) NEW_LINE n2 = number * number NEW_LINE number = ( number * 2 ) + 1 NEW_LINE while ( ( n2 >= l and n2 <= r ) ) : NEW_LINE INDENT print ( n2 , end = " ▁ " ) NEW_LINE n2 = n2 + number NEW_LINE number += 2 NEW_LINE DEDENT DEDENT l = 2 NEW_LINE r = 24 NEW_LINE perfectSquares ( l , r ) NEW_LINE
import math NEW_LINE def CheckArray ( arr , n ) : NEW_LINE INDENT prod = 1 NEW_LINE freq = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq . append ( arr [ i ] ) NEW_LINE prod *= arr [ i ] NEW_LINE DEDENT root = int ( math . sqrt ( prod ) ) NEW_LINE if ( root * root == prod ) : NEW_LINE INDENT if ( freq . count ( root ) & freq . lastIndexOf ( root ) != ( len ( freq ) ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 12 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE if ( CheckArray ( arr , n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def findNumbers ( N ) : NEW_LINE INDENT i = 1 NEW_LINE while ( i <= N ) : NEW_LINE INDENT print ( ( i * i * i ) , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 4 NEW_LINE findNumbers ( N ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT b . append ( a [ i ] ) NEW_LINE DEDENT b . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if b [ i ] + a [ j ] >= m : NEW_LINE INDENT m -= a [ i ] + a [ j ] NEW_LINE b . append ( i ) NEW_LINE DEDENT DEDENT DEDENT print ( * b ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE if a [ 0 ] == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] == 1 : NEW_LINE INDENT print ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT
import math NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE a1 = a [ - 1 ] NEW_LINE a2 = a [ - 1 ] NEW_LINE a3 = a [ - 2 ] NEW_LINE a4 = a [ - 1 ] NEW_LINE a5 = a [ - 1 ] NEW_LINE a6 = a [ - 1 ] NEW_LINE a7 = a [ - 2 ] NEW_LINE a8 = a [ - 1 ] NEW_LINE a9 = a [ - 1 ] NEW_LINE a10 = a [ - 1 ] NEW_LINE a9 = a [ - 1 ] NEW_LINE a10 = a [ - 1 ] NEW_LINE a10 = a10 ** 2 NEW_LINE a9 = a9 ** 2 NEW_LINE a10 = a10 ** 3 NEW_LINE a10 = a10 ** 4 NEW_LINE a9 = a9 NEW_LINE a10 = a10 ** 5 NEW_LINE a10 = a10 ** 6 NEW_LINE a10 = a10 ** 7 NEW_LINE
s = input ( ) NEW_LINE d = { } NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT for j in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == s [ j ] : NEW_LINE INDENT d [ s [ i ] ] . append ( j ) NEW_LINE DEDENT else : NEW_LINE INDENT d [ s [ i ] ] = [ j ] NEW_LINE DEDENT DEDENT DEDENT ans = 0.0 NEW_LINE for i in range ( len ( d ) ) : NEW_LINE INDENT for j in range ( len ( d [ i ] ) ) : NEW_LINE INDENT ans += d [ i ] [ j ] * d [ i ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( len ( d ) ) : NEW_LINE INDENT for j in range ( len ( d [ i ] ) ) : NEW_LINE INDENT ans += d [ i ] [ j ] * d [ i ] [ j ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def countIntervals ( arr , V , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT li = arr [ i ] [ 0 ] NEW_LINE ri = arr [ i ] [ 1 ] NEW_LINE if ( V >= li and V <= ri ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ [ 1 , 10 ] , [ 5 , 10 ] , [ 15 , 25 ] , [ 7 , 12 ] , [ 20 , 25 ] ] NEW_LINE V = 7 NEW_LINE N = len ( arr ) NEW_LINE print ( countIntervals ( arr , V , N ) ) NEW_LINE
def msbPos ( n ) : NEW_LINE INDENT msb_p = - 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = n >> 1 NEW_LINE msb_p += 1 NEW_LINE DEDENT return msb_p NEW_LINE DEDENT def andOperator ( x , y ) : NEW_LINE INDENT res = 0 NEW_LINE while ( x > 0 and y > 0 ) : NEW_LINE INDENT msb_p1 = msbPos ( x ) NEW_LINE msb_p2 = msbPos ( y ) NEW_LINE if ( msb_p1 != msb_p2 ) : NEW_LINE INDENT break NEW_LINE DEDENT msb_val = ( 1 << msb_p1 ) NEW_LINE res = res + msb_val NEW_LINE x = x - msb_val NEW_LINE y = y - msb_val NEW_LINE DEDENT return res NEW_LINE DEDENT x = 10 NEW_LINE y = 15 NEW_LINE print ( andOperator ( x , y ) ) NEW_LINE
def lengthOfLastWord ( a ) : NEW_LINE INDENT char_flag = False ; NEW_LINE len = 0 ; NEW_LINE for i in range ( len ( a ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( ord ( a [ i ] ) == ord ( ' a ' ) ) : NEW_LINE INDENT char_flag = True ; NEW_LINE len += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( char_flag == True ) : NEW_LINE INDENT return len ; NEW_LINE DEDENT DEDENT DEDENT return len ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT input = " Geeks ▁ For ▁ Geeks ▁ " ; NEW_LINE print ( " The ▁ length ▁ of ▁ last ▁ word ▁ is " , lengthOfLastWord ( input ) ) ; NEW_LINE DEDENT
import math NEW_LINE R , X , Y , N = map ( int , input ( ) . split ( ) ) NEW_LINE P = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE S = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT S += P [ i ] NEW_LINE DEDENT for i in range ( N - 1 ) : NEW_LINE INDENT x1 = R * math . pi / 2 NEW_LINE y1 = R * math . pi / 2 NEW_LINE x2 = R * math . pi / 2 NEW_LINE y2 = R * math . pi / 2 NEW_LINE x1 += ( x1 - x2 ) / 2 NEW_LINE y1 += ( y1 - y2 ) / 2 NEW_LINE S += math . sqrt ( x1 ** 2 + y1 ** 2 ) NEW_LINE DEDENT print ( ' { : . 10f } ' . format ( S ) ) NEW_LINE
def partSort ( arr , N , a , b ) : NEW_LINE INDENT l = min ( a , b ) NEW_LINE r = max ( a , b ) NEW_LINE temp = [ ] NEW_LINE j = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT temp . append ( arr [ i ] ) NEW_LINE j += 1 NEW_LINE DEDENT temp . sort ( ) NEW_LINE j = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT arr [ i ] = temp [ j ] NEW_LINE j += 1 NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 7 , 8 , 4 , 5 , 2 ] NEW_LINE a = 1 NEW_LINE b = 4 NEW_LINE N = len ( arr ) NEW_LINE partSort ( arr , N , a , b ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] ** 2 != a [ i ] : NEW_LINE INDENT print ( a [ i ] ) NEW_LINE break NEW_LINE DEDENT DEDENT
def countSolutions ( a ) : NEW_LINE INDENT count = bin ( a ) . count ( '1' ) NEW_LINE count = int ( count ) NEW_LINE return int ( count ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 3 NEW_LINE print ( countSolutions ( a ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( n * ( n + 1 ) ) // 2 + m * ( m + 1 ) // 2 - n * ( n + 1 ) // 2 ) NEW_LINE DEDENT
import math NEW_LINE N = 1000005 NEW_LINE MAX = 1e18 NEW_LINE powers = [ ] NEW_LINE s = [ ] NEW_LINE def powersPrecomputation ( ) : NEW_LINE INDENT for i in range ( 2 , N ) : NEW_LINE INDENT squares . append ( i * i ) NEW_LINE if ( squares . count ( i ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT temp = i NEW_LINE while ( i * i <= MAX / temp ) : NEW_LINE INDENT temp *= ( i * i ) NEW_LINE s . append ( temp ) NEW_LINE DEDENT DEDENT for x in s : NEW_LINE INDENT powers . append ( x ) NEW_LINE DEDENT DEDENT def calculateAnswer ( L , R ) : NEW_LINE INDENT powersPrecomputation ( ) NEW_LINE perfectSquares = ( math . floor ( math . sqrt ( R ) ) - math . floor ( math . sqrt ( L - 1 ) ) ) NEW_LINE high = bisect ( powers , R ) NEW_LINE low = bisect ( powers , L ) NEW_LINE perfectPowers = perfectSquares + ( high - low )
dp = [ [ 0 for i in range ( 1000 ) ] for j in range ( 1000 ) ] NEW_LINE def sum ( a , i , j ) : NEW_LINE INDENT ans = 0 NEW_LINE for m in range ( i , j + 1 ) : NEW_LINE INDENT ans = ( ans + a [ m ] ) % 100 NEW_LINE DEDENT return ans NEW_LINE DEDENT def solve ( a , i , j ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT dp [ i ] [ j ] = 100000000 NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , ( solve ( a , i , k ) + solve ( a , k + 1 , j ) + sum ( a , i , k ) * sum ( a , k + 1 , j ) ) ) NEW_LINE DEDENT return dp [ i ] [ j ] NEW_LINE DEDENT if __
def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( 0 , size ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE return ; NEW_LINE DEDENT def printSequencesRecur ( arr , n , k , index ) : NEW_LINE INDENT if ( k == 0 ) : NEW_LINE INDENT printArray ( arr , index ) ; NEW_LINE DEDENT if ( k > 0 ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT arr [ index ] = i ; NEW_LINE printSequencesRecur ( arr , n , k - 1 , index + 1 ) ; NEW_LINE DEDENT DEDENT DEDENT def printSequences ( n , k ) : NEW_LINE INDENT arr = [ 0 ] * k ; NEW_LINE printSequencesRecur ( arr , n , k , 0 ) ; NEW_LINE return ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 ; NEW_LINE k = 2 ; NEW_LINE printSequences ( n ,
a = [ ] NEW_LINE b = [ ] NEW_LINE c = [ ] NEW_LINE while True : NEW_LINE INDENT try : NEW_LINE INDENT a . append ( list ( map ( int , input ( ) . split ( ' , ' ) ) ) ) NEW_LINE DEDENT except EOFError : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( len ( a ) ) : NEW_LINE INDENT if a [ i ] [ 0 ] ** 2 + a [ i ] [ 1 ] ** 2 == a [ i ] [ 2 ] ** 2 : NEW_LINE INDENT b . append ( [ a [ i ] [ 0 ] , a [ i ] [ 1 ] , a [ i ] [ 2 ] ] ) NEW_LINE DEDENT DEDENT print ( len ( b ) ) NEW_LINE print ( len ( c ) ) NEW_LINE
def maxValue ( a , n ) : NEW_LINE INDENT first = { } NEW_LINE last = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT first [ a [ i ] ] = 0 NEW_LINE last [ a [ i ] ] = 0 NEW_LINE DEDENT pr = [ 0 ] * n NEW_LINE pr [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pr [ i ] = pr [ i - 1 ] + a [ i ] NEW_LINE if first [ a [ i ] ] == 0 : NEW_LINE INDENT first [ a [ i ] ] = i NEW_LINE DEDENT last [ a [ i ] ] = i NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT start = first [ a [ i ] ] NEW_LINE end = last [ a [ i ] ] NEW_LINE if start != 0 : NEW_LINE INDENT ans = max ( ans , pr [ end ] - pr [ start - 1 ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main
def getPairs ( a , n ) : NEW_LINE INDENT visited1 = set ( ) NEW_LINE un = [ 0 ] * n NEW_LINE un [ n - 1 ] = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT if ( a [ i ] in visited1 ) : NEW_LINE INDENT un [ i - 1 ] = count NEW_LINE DEDENT else : NEW_LINE INDENT un [ i - 1 ] = count NEW_LINE DEDENT DEDENT visited2 = set ( ) NEW_LINE answer = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] in visited2 ) : NEW_LINE INDENT continue NEW_LINE DEDENT answer += un [ i ] NEW_LINE visited2 . add ( a [ i ] ) NEW_LINE DEDENT return answer NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 2 , 2 , 4 , 2 , 5 , 3 , 5 ] NEW_LINE n = len ( a ) NEW_LINE print ( getPairs ( a
def isTwoAlter ( s ) : NEW_LINE INDENT for i in range ( len ( s ) - 2 ) : NEW_LINE INDENT if ( s [ i ] != s [ i + 2 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if ( s [ 0 ] == s [ 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " ABAB " NEW_LINE if ( isTwoAlter ( str ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def findRemainder ( n ) : NEW_LINE INDENT l = n % 10 NEW_LINE while ( n >= 10 ) : NEW_LINE INDENT n //= 10 NEW_LINE DEDENT f = n NEW_LINE remainder = f % l NEW_LINE print ( remainder ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5223 NEW_LINE findRemainder ( n ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE if n % 5 == 0 : NEW_LINE INDENT print ( " Sheldon " ) NEW_LINE DEDENT elif n % 5 == 1 : NEW_LINE INDENT print ( " Leonard " ) NEW_LINE DEDENT elif n % 5 == 2 : NEW_LINE INDENT print ( " Penny " ) NEW_LINE DEDENT elif n % 5 == 3 : NEW_LINE INDENT print ( " Rajesh " ) NEW_LINE DEDENT elif n % 5 == 4 : NEW_LINE INDENT print ( " Howard " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Sheldon " ) NEW_LINE DEDENT
def findSumofEle ( arr1 , m , arr2 , n , k ) : NEW_LINE INDENT arraySum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT arraySum += arr2 [ i ] ; NEW_LINE DEDENT mean = arraySum / n ; NEW_LINE sumOfElements = 0 ; NEW_LINE difference = 0 ; NEW_LINE for i in range ( m ) : NEW_LINE INDENT difference = arr1 [ i ] - mean ; NEW_LINE if ( difference < 0 and ( k > ( - 1 ) * difference ) ) : NEW_LINE INDENT sumOfElements += arr1 [ i ] ; NEW_LINE DEDENT if ( difference >= 0 and ( k > difference ) ) : NEW_LINE INDENT sumOfElements += arr1 [ i ] ; NEW_LINE DEDENT DEDENT return sumOfElements ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr1 = [ 1 , 2 , 3 , 4 , 7 , 9 ] ; NEW_LINE arr2 = [ 0 , 1 , 2 , 1 , 1 , 4 ] ; NEW_LINE k = 2 ; NEW_LINE m
def CountWays ( n , flag ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT sum = 0 NEW_LINE if ( flag == False and n > 1 ) : NEW_LINE INDENT sum = sum + CountWays ( n - 1 , False ) + CountWays ( n - 2 , True ) NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + CountWays ( n - 1 , False ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 5 NEW_LINE print ( CountWays ( n , False ) ) NEW_LINE
def MaxSumDifference ( a , n ) : NEW_LINE INDENT finalSequence = [ ] NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT finalSequence . append ( a [ i ] ) NEW_LINE finalSequence . append ( a [ n - i - 1 ] ) NEW_LINE DEDENT if n % 2 != 0 : NEW_LINE INDENT finalSequence . append ( a [ n // 2 ] ) NEW_LINE DEDENT MaximumSum = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT MaximumSum = MaximumSum + abs ( finalSequence [ i ] - finalSequence [ i + 1 ] ) NEW_LINE DEDENT MaximumSum = MaximumSum + abs ( finalSequence [ n - 1 ] - finalSequence [ 0 ] ) NEW_LINE return MaximumSum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 2 , 4 , 8 ] NEW_LINE n = len ( a ) NEW_LINE print ( MaxSumDifference ( a , n ) ) NEW_LINE DEDENT
def reverse ( n ) : NEW_LINE INDENT rev = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT d = n % 10 NEW_LINE rev = rev * 10 + d NEW_LINE n = n // 10 NEW_LINE DEDENT return rev NEW_LINE DEDENT def isPalin ( n ) : NEW_LINE INDENT return ( n == reverse ( n ) ) NEW_LINE DEDENT def countDigits ( n ) : NEW_LINE INDENT c = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = n // 10 NEW_LINE c += 1 NEW_LINE DEDENT return c NEW_LINE DEDENT def countPalinDigits ( arr , n ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] < 10 or isPalin ( arr [ i ] ) ) : NEW_LINE INDENT s += countDigits ( arr [ i ] ) NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT arr = [ 121 , 56 , 434 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPalinDigits ( arr ,
def lenoflongestnonpalindrome ( s ) : NEW_LINE INDENT max1 = 1 NEW_LINE len = 0 NEW_LINE new_str = s NEW_LINE for i in range ( len ( new_str ) - 1 ) : NEW_LINE INDENT if ( new_str [ i ] == new_str [ i + 1 ] ) : NEW_LINE INDENT len = 0 NEW_LINE DEDENT elif ( i > 0 and ( new_str [ i + 1 ] == new_str [ i - 1 ] ) ) : NEW_LINE INDENT len = 1 NEW_LINE DEDENT else : NEW_LINE INDENT len += 1 NEW_LINE DEDENT max1 = max ( max1 , len + 1 ) NEW_LINE DEDENT if ( max1 == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return max1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " synapse " NEW_LINE print ( lenoflongestnonpalindrome ( s ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if a [ i ] != 0 and k != 0 : NEW_LINE INDENT a [ i ] -= 1 NEW_LINE a [ n - 1 ] -= 1 NEW_LINE k -= 1 NEW_LINE DEDENT DEDENT print ( * a ) NEW_LINE DEDENT
def ellipse ( l , b ) : NEW_LINE INDENT if ( l < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = ( 3.14 * l * b ) / 4 NEW_LINE return x NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 5 NEW_LINE b = 3 NEW_LINE print ( ellipse ( a , b ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > 1 : NEW_LINE INDENT b . append ( i + 1 ) NEW_LINE DEDENT elif a [ i ] < - 1 : NEW_LINE INDENT a [ i ] = - 1 NEW_LINE DEDENT DEDENT if len ( b ) % 2 == 1 : NEW_LINE INDENT print ( * b ) NEW_LINE DEDENT else : NEW_LINE INDENT if len ( a ) % 2 == 1 : NEW_LINE INDENT print ( * a ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( * a ) NEW_LINE DEDENT DEDENT
def alternate ( a , b , x ) : NEW_LINE INDENT return x = a ^ b ^ x NEW_LINE DEDENT a = - 10 NEW_LINE b = 15 NEW_LINE x = a NEW_LINE print ( " x ▁ is ▁ : " , x ) NEW_LINE x = alternate ( a , b , x ) NEW_LINE print ( " After ▁ exchange ▁ " ) NEW_LINE print ( " x ▁ is ▁ : " , x ) NEW_LINE
import math NEW_LINE n = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 2 , int ( math . sqrt ( i ) ) + 1 ) : NEW_LINE INDENT if i % j == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
x1 = 1 NEW_LINE x2 = 3 NEW_LINE x3 = 6 NEW_LINE y1 = 2 NEW_LINE y2 = - 4 NEW_LINE y3 = - 7 NEW_LINE x = ( x1 + x2 + x3 ) / 3 NEW_LINE y = ( y1 + y2 + y3 ) / 3 NEW_LINE print ( " Centroid ▁ = ▁ ( " , str ( x ) , " , " , str ( y ) , " ) " ) NEW_LINE
import sys NEW_LINE def areElementsContiguous ( arr , n ) : NEW_LINE INDENT max = - sys . maxsize ; NEW_LINE min = - sys . maxsize ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT max = max ( max , arr [ i ] ) ; NEW_LINE min = min ( min , arr [ i ] ) ; NEW_LINE DEDENT m = max - min + 1 ; NEW_LINE if ( m > n ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT visited = [ 0 ] * n ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT visited [ arr [ i ] - min ] = 1 ; NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT if ( visited [ i ] == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT arr = [ 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE if ( areElementsContiguous ( arr , n ) ) : NEW_LINE INDENT print ( " Yes " )
def count_ ( count , e ) : NEW_LINE INDENT hash = [ 0 for i in range ( 10 ) ] NEW_LINE while ( e > 0 ) : NEW_LINE INDENT if ( hash [ e % 10 ] == 0 ) : NEW_LINE INDENT count [ e % 10 ] += 1 NEW_LINE DEDENT hash [ e % 10 ] = 1 NEW_LINE e //= 10 NEW_LINE DEDENT DEDENT def find_subsequence ( arr , n ) : NEW_LINE INDENT count = [ 0 for i in range ( 10 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT count_ ( count , arr [ i ] ) NEW_LINE DEDENT longest = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT longest = max ( count [ i ] , longest ) NEW_LINE DEDENT print ( longest ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 11 , 12 , 23 , 74 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE find_subsequence ( arr , n ) NEW_LINE DEDENT
MAXN = 1000001 NEW_LINE spf = [ 0 ] * MAXN NEW_LINE def sieve ( ) : NEW_LINE INDENT for i in range ( 1 , MAXN ) : NEW_LINE INDENT spf [ i ] = i NEW_LINE DEDENT for i in range ( 4 , MAXN , 2 ) : NEW_LINE INDENT spf [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , MAXN , 2 ) : NEW_LINE INDENT if ( spf [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , MAXN , i ) : NEW_LINE INDENT if ( spf [ j ] == j ) : NEW_LINE INDENT spf [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def countSubArray ( arr , n ) : NEW_LINE INDENT ind = [ - 1 ] * MAXN NEW_LINE count = 0 NEW_LINE last_ind = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( arr [ i ] > 1 ) : NEW_LINE INDENT div = spf [ arr [ i ] ] NEW_LINE last_ind
N = 3 NEW_LINE def multiply ( mat , res ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT res [ i ] [ j ] = 0 NEW_LINE for k in range ( N ) : NEW_LINE INDENT res [ i ] [ j ] += mat [ i ] [ k ] * mat [ k ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT def InvolutoryMatrix ( mat ) : NEW_LINE INDENT res = [ [ 0 for i in range ( N ) ] for j in range ( N ) ] NEW_LINE multiply ( mat , res ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( i == j and res [ i ] [ j ] != 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( i != j and res [ i ] [ j ] != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE
def first ( n ) : NEW_LINE INDENT a = n NEW_LINE c = 1 NEW_LINE while ( a != 0 ) : NEW_LINE INDENT a //= 10 NEW_LINE c = c * 10 NEW_LINE DEDENT c = c // 10 NEW_LINE fi = n // c NEW_LINE return fi NEW_LINE DEDENT def prime ( n ) : NEW_LINE INDENT if ( n == 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( n == 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( n == 5 ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( n == 7 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def check ( n , k ) : NEW_LINE INDENT l = n % 10 NEW_LINE f = first ( n ) NEW_LINE lp = prime ( l ) NEW_LINE fp = prime ( f ) NEW_LINE if ( lp and fp ) : NEW_LINE INDENT if ( l + f < k ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else :
import math NEW_LINE def lengthSquare ( p1 , p2 ) : NEW_LINE INDENT xDiff = p1 . x - p2 . x NEW_LINE yDiff = p1 . y - p2 . y NEW_LINE return xDiff * xDiff + yDiff * yDiff NEW_LINE DEDENT def printAngle ( A , B , C ) : NEW_LINE INDENT a2 = lengthSquare ( B , C ) NEW_LINE b2 = lengthSquare ( A , B ) NEW_LINE c2 = lengthSquare ( A , B ) NEW_LINE a = math . sqrt ( a2 ) NEW_LINE b = math . sqrt ( b2 ) NEW_LINE c = math . sqrt ( c2 ) NEW_LINE a = math . sqrt ( a2 ) NEW_LINE b = math . sqrt ( b2 ) NEW_LINE c = math . sqrt ( c2 ) NEW_LINE alpha = math . acos ( ( b2 + c2 - a2 ) / ( 2 * b * c ) ) NEW_LINE betta = math . acos ( ( a2 + b2 - c2 ) / ( 2 * a * b ) ) NEW_LINE gamma =
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if a [ i ] > a [ i + 1 ] : NEW_LINE INDENT a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def maxEvenSum ( arr , n ) : NEW_LINE INDENT pos_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT pos_sum += arr [ i ] NEW_LINE DEDENT DEDENT if ( pos_sum % 2 == 0 ) : NEW_LINE INDENT return pos_sum NEW_LINE DEDENT ans = - 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 != 0 ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT ans = ans > ( pos_sum - arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = ans NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ans = pos_sum + arr [ i ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ - 2 , 2 , - 3 , 1 ] NEW_LINE print ( maxEvenSum ( a , len ( a ) ) ) NEW_LINE DE
def xorOfArray ( arr , n ) : NEW_LINE INDENT xor_arr = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xor_arr = xor_arr ^ arr [ i ] NEW_LINE DEDENT return xor_arr NEW_LINE DEDENT arr = [ 3 , 9 , 12 , 13 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( xorOfArray ( arr , n ) ) NEW_LINE
TEN = 10 NEW_LINE def updateFreq ( n , freq ) : NEW_LINE INDENT while ( n > 0 ) : NEW_LINE INDENT digit = n % TEN NEW_LINE freq [ digit ] += 1 NEW_LINE n //= TEN NEW_LINE DEDENT DEDENT def areAnagrams ( a , b ) : NEW_LINE INDENT freqA = [ 0 for i in range ( TEN ) ] NEW_LINE freqB = [ 0 for i in range ( TEN ) ] NEW_LINE updateFreq ( a , freqA ) NEW_LINE updateFreq ( b , freqB ) NEW_LINE for i in range ( TEN ) : NEW_LINE INDENT if ( freqA [ i ] != freqB [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 204 NEW_LINE b = 240 NEW_LINE if ( areAnagrams ( a , b ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def evenFib ( n ) : NEW_LINE INDENT if ( n < 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) NEW_LINE DEDENT n = 7 NEW_LINE print ( evenFib ( n ) ) NEW_LINE
import math NEW_LINE def minOperations ( N ) : NEW_LINE INDENT x = math . log ( N ) / math . log ( 2 ) NEW_LINE ans = int ( math . ceil ( x ) ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 10 NEW_LINE print ( minOperations ( N ) ) NEW_LINE DEDENT
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 6 ) NEW_LINE int1 = lambda x : int ( x ) - 1 NEW_LINE p2D = lambda x : print ( * x , sep = " \n " ) NEW_LINE def II ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def MI ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] NEW_LINE def SI ( ) : return sys . stdin . readline ( ) [ : - 1 ] NEW_LINE def main ( ) : NEW_LINE INDENT n = II ( ) NEW_LINE t , a = MI ( ) NEW_LINE dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT t , a = t - i , a - i NEW_
def check ( k , d0 , d1 ) : NEW_LINE INDENT s = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 + ( 6 * ( d0 + d1 ) ) % 10 ) NEW_LINE a = ( k - 3 ) % 4 NEW_LINE x = 0 NEW_LINE if ( a == 0 ) : NEW_LINE INDENT x = 0 NEW_LINE DEDENT elif ( a == 1 ) : NEW_LINE INDENT x = ( 2 * ( d0 + d1 ) ) % 10 NEW_LINE DEDENT elif ( a == 2 ) : NEW_LINE INDENT x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 NEW_LINE DEDENT elif ( a == 3 ) : NEW_LINE INDENT x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 ) NEW_LINE DEDENT sum = d0
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT l1 , r1 , l2 , r2 = map ( int , input ( ) . split ( ) ) NEW_LINE for i in range ( l1 , r1 + 1 ) : NEW_LINE INDENT for j in range ( l2 , r2 + 1 ) : NEW_LINE INDENT if i != j : NEW_LINE INDENT print ( i , j ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT
import sys NEW_LINE from collections import deque NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT N = 9 NEW_LINE A = [ 0 ] * N NEW_LINE B = [ 0 ] * N NEW_LINE C = [ 0 ] * N NEW_LINE D = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT A [ i ] = int ( input ( ) ) NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT B [ i ] = int ( input ( ) ) NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT C [ i ] = C [ i ] * 10 + int ( input ( ) ) NEW_LINE DEDENT C = deque ( [ 0 ] * N ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT C [ i ] = C [ i ] * 10 + int ( input ( ) ) NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT if C [ i ] == C [ j ] : NEW_LINE
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LENGTH = 20 NEW_LINE BASE = 10 NEW_LINE MOD = 10 ** 9 NEW_LINE MODULUS = eulerlib . pow ( 10 , 9 ) NEW_LINE MAX_SQR_DIGIT_SUM = ( BASE - 1 ) * ( BASE - 1 ) * LENGTH NEW_LINE sum = [ [ 0 ] * ( LENGTH + 1 ) for i in range ( LENGTH + 1 ) ] NEW_LINE count = [ [ 0 ] * ( LENGTH + 1 ) for i in range ( LENGTH + 1 ) ] NEW_LINE for i in range ( 1 , LENGTH + 1 ) : NEW_LINE INDENT for j in range ( BASE ) : NEW_LINE INDENT for k in range ( MAX_SQR_DIGIT_SUM + 1 ) : NEW_LINE INDENT for j in range ( MAX_SQR_DIGIT_SUM + 1 ) : NEW_LINE INDENT for k in range ( MAX_SQR_DIGIT_SUM + 1 ) : NEW_LINE INDENT sum [ i ] [ k + j * j ] = ( sum [ i ] [ k + j * j ] + sum [ i - 1 ]
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE INF = 10 ** 18 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE input = lambda : sys . stdin . readline ( ) . rstrip ( ) NEW_LINE YesNo = lambda b : bool ( [ print ( ' Yes ' ) ] if b else print ( ' No ' ) ) NEW_LINE YESNO = lambda b : bool ( [ print ( ' YES ' ) ] if b else print ( ' NO ' ) ) NEW_LINE int1 = lambda x : int ( x ) - 1 NEW_LINE def main ( ) : NEW_LINE INDENT Q = int ( input ( ) ) NEW_LINE A = [ ] NEW_LINE for _ in range ( Q ) : NEW_LINE INDENT query = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if query [ 0 ] == 0 : NEW_LINE INDENT A . append ( query [ 1 ] ) NEW_LINE print ( len ( A ) ) NEW_LINE DEDENT elif query [ 0 ] == 1 : NEW_LINE INDENT A . remove ( query [ 1 ] ) NEW_LINE print ( 1 ) NEW_
MAX = 10000002 NEW_LINE prime = [ 0 for i in range ( MAX ) ] NEW_LINE prime_count = [ 0 for i in range ( MAX ) ] NEW_LINE def sieve ( ) : NEW_LINE INDENT prime [ 0 ] = prime [ 1 ] = 1 NEW_LINE for i in range ( 2 , int ( MAX ** 0.5 ) ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i * 2 , MAX , i ) : NEW_LINE INDENT if ( prime [ j ] == 0 ) : NEW_LINE INDENT prime [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( 2 , MAX ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT prime [ i ] = i NEW_LINE DEDENT DEDENT DEDENT def numberOfDivisorsOfProduct ( arr , n ) : NEW_LINE INDENT prime_count = [ 0 for i in range ( MAX ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE while ( temp != 1 ) : NEW_
def check ( num ) : NEW_LINE INDENT digitSum = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT digitSum = digitSum + num % 10 NEW_LINE num = int ( num / 10 ) NEW_LINE DEDENT temp = digitSum NEW_LINE reverseDigitSum = 0 NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT rem = temp % 10 NEW_LINE reverseDigitSum = reverseDigitSum * 10 + rem NEW_LINE temp = temp // 10 NEW_LINE DEDENT number = digitSum * reverseDigitSum NEW_LINE return number NEW_LINE DEDENT num = 1729 NEW_LINE x = check ( num ) NEW_LINE if ( num == x ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def sum ( arr ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT arr = [ 12 , 3 , 4 , 15 ] NEW_LINE print ( " Sum ▁ of ▁ given ▁ array ▁ is " , sum ( arr ) ) NEW_LINE
def ways ( n ) : NEW_LINE INDENT first = 2 NEW_LINE second = 3 NEW_LINE res = 0 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT res = first + second NEW_LINE first = second NEW_LINE second = res NEW_LINE DEDENT return res NEW_LINE DEDENT n = 7 NEW_LINE print ( " Total ▁ ways ▁ are : " , ways ( n ) ) NEW_LINE
import math NEW_LINE pi = math . pi NEW_LINE def volume ( r , R , h ) : NEW_LINE INDENT return 1 / 3 * pi * h * ( r * r + R * R + R * R ) NEW_LINE DEDENT def curved_surface_area ( r , R , l ) : NEW_LINE INDENT return pi * l * ( R + r ) + pi * ( r * r + R * R ) NEW_LINE DEDENT small_radius = 3 NEW_LINE big_radius = 8 NEW_LINE slant_height = 13 NEW_LINE height = 12 NEW_LINE print ( " Volume ▁ Of ▁ Frustum ▁ of ▁ Cone ▁ : ▁ " , volume ( small_radius , big_radius , height ) ) NEW_LINE print ( " Curved ▁ Surface ▁ Area ▁ Of ▁ Frustum ▁ of ▁ Cone ▁ : ▁ " , curved_surface_area ( small_radius , big_radius , height ) ) NEW_LINE
def digitSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT sum += ( n % 10 ) NEW_LINE n //= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def isPalindrome ( n ) : NEW_LINE INDENT divisor = 1 NEW_LINE while ( n // divisor >= 10 ) : NEW_LINE INDENT divisor *= 10 NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT leading = n // divisor NEW_LINE trailing = n % 10 NEW_LINE if ( leading != trailing ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = ( n % divisor ) // 10 NEW_LINE divisor = divisor // 100 NEW_LINE DEDENT return True NEW_LINE DEDENT def isDigitSumPalindrome ( n ) : NEW_LINE INDENT sum = digitSum ( n ) NEW_LINE if ( isPalindrome ( sum ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 56 NEW_LINE if ( isDigitSumPalindrome ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n <= 6 : NEW_LINE INDENT print ( 15 ) NEW_LINE DEDENT else : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT n += 1 NEW_LINE DEDENT else : NEW_LINE INDENT n //= 2 NEW_LINE n *= 5 NEW_LINE DEDENT print ( n ) NEW_LINE DEDENT DEDENT
def getPercentile ( rank , students ) : NEW_LINE INDENT result = ( students - rank ) / students * 100 NEW_LINE return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT your_rank = 805 NEW_LINE total_students = 97481 NEW_LINE print ( getPercentile ( your_rank , total_students ) ) NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT n = 17 NEW_LINE if ( isPrime ( n ) and ( n % 16 == 1 ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT n = 13 NEW_LINE if ( isPrime ( n ) and ( n % 4 == 1 ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def isPowerOfTwo ( n ) : NEW_LINE INDENT return ( n != 0 and ( ( n & ( n - 1 ) ) == 0 ) ) NEW_LINE DEDENT n = 43 NEW_LINE if ( isPrime ( n ) and ( isPowerOfTwo ( n * 3 - 1 ) ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
import sys NEW_LINE from sys import stdin NEW_LINE input = stdin . readline NEW_LINE def main ( args ) : NEW_LINE INDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE p . sort ( ) NEW_LINE cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if p [ i ] == 1 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT p [ i ] = 1 NEW_LINE DEDENT DEDENT print ( cnt ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
def countOfSubstringWithKOnes ( s , K ) : NEW_LINE INDENT N = len ( s ) NEW_LINE res = 0 NEW_LINE countOfOne = 0 NEW_LINE freq = [ 0 ] * ( N + 1 ) NEW_LINE freq [ 0 ] = 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT countOfOne += ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE if ( countOfOne >= K ) : NEW_LINE INDENT res += freq [ countOfOne - K ] NEW_LINE DEDENT freq [ countOfOne ] += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = "10010" NEW_LINE K = 1 NEW_LINE print ( countOfSubstringWithKOnes ( s , K ) ) NEW_LINE DEDENT
def kth ( arr1 , arr2 , m , n , k ) : NEW_LINE INDENT sorted1 = [ 0 ] * ( m + n ) NEW_LINE i , j , d = 0 , 0 , 0 NEW_LINE while i < m and j < n : NEW_LINE INDENT if arr1 [ i ] < arr2 [ j ] : NEW_LINE INDENT sorted1 [ d ] = arr1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT sorted1 [ d ] = arr2 [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT while i < m : NEW_LINE INDENT sorted1 [ d ] = arr1 [ i ] NEW_LINE i += 1 NEW_LINE d += 1 NEW_LINE DEDENT while j < n : NEW_LINE INDENT sorted1 [ d ] = arr2 [ j ] NEW_LINE j += 1 NEW_LINE d += 1 NEW_LINE DEDENT return sorted1 [ k - 1 ] NEW_LINE DEDENT arr1 = [ 2 , 3 , 6 , 7 , 9 ] NEW_LINE arr2 = [ 1 , 4 , 8 , 10 ] NEW_LINE k = 5
MAX = 256 NEW_LINE freq = [ [ 0 for i in range ( MAX ) ] for j in range ( 256 ) ] NEW_LINE def preCalculate ( str , n ) : NEW_LINE INDENT freq [ ord ( str [ 0 ] ) ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ch = str [ i ] NEW_LINE for j in range ( MAX ) : NEW_LINE INDENT charToUpdate = j NEW_LINE if charToUpdate == ch : NEW_LINE INDENT freq [ j ] [ i ] = freq [ j ] [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ j ] [ i ] = freq [ j ] [ i - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT def getFrequency ( ch , l , r ) : NEW_LINE INDENT if l == 0 : NEW_LINE INDENT return freq [ ch ] [ r ] NEW_LINE DEDENT else : NEW_LINE INDENT return ( freq [ ch ] [ r ] - freq [ ch ] [ l - 1 ] ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " :
MAX = 256 NEW_LINE freq = [ [ 0 for i in range ( MAX ) ] for j in range ( 256 ) ] NEW_LINE def preCalculate ( str , n ) : NEW_LINE INDENT freq [ ord ( str [ 0 ] ) ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ch = str [ i ] NEW_LINE for j in range ( MAX ) : NEW_LINE INDENT charToUpdate = j NEW_LINE if ( charToUpdate == ch ) : NEW_LINE INDENT freq [ j ] [ i ] = freq [ j ] [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ j ] [ i ] = freq [ j ] [ i - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT def getFrequency ( ch , l , r ) : NEW_LINE INDENT if ( l == 0 ) : NEW_LINE INDENT return freq [ ch ] [ r ] NEW_LINE DEDENT else : NEW_LINE INDENT return ( freq [ ch ] [ r ] - freq [ ch ] [ l - 1 ] ) NEW_LINE DEDENT DEDENT def lastNonRepeating ( str ,
def divide ( a , b ) : NEW_LINE INDENT for i in range ( 2 , min ( a , b ) + 1 ) : NEW_LINE INDENT while ( a % i == 0 and b % i == 0 ) : NEW_LINE INDENT a = a // i NEW_LINE b = b // i NEW_LINE DEDENT DEDENT print ( " A ▁ = " , a , " , ▁ B ▁ = " , b ) NEW_LINE DEDENT A = 10 NEW_LINE B = 15 NEW_LINE divide ( A , B ) NEW_LINE
import math NEW_LINE permutation = [ ] NEW_LINE def printPermutation ( ) : NEW_LINE INDENT permutation . append ( [ ] ) NEW_LINE DEDENT def give_random_number ( l , r ) : NEW_LINE INDENT x = int ( math . random ( ) % ( r - l + 1 ) + l ) NEW_LINE return x NEW_LINE DEDENT def generate_random_permutation ( l , r ) : NEW_LINE INDENT if ( l > r ) : NEW_LINE INDENT return NEW_LINE DEDENT n = give_random_number ( l , r ) NEW_LINE permutation . append ( n ) NEW_LINE generate_random_permutation ( l , n - 1 ) NEW_LINE generate_random_permutation ( n + 1 , r ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l = 5 NEW_LINE r = 15 NEW_LINE generate_random_permutation ( l , r ) NEW_LINE printPermutation ( ) NEW_LINE DEDENT
n , d = map ( int , input ( ) . split ( ) ) NEW_LINE if d == 1 : NEW_LINE INDENT print ( ( n * ( n - 1 ) ) // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( n - d ) * ( n - 1 ) // 2 + d - 2 ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if m % n == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif m % n == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT
n , a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE s = [ ' R ' , ' P ' , ' S ' , ' P ' , ' R ' , ' S ' , ' P ' , ' S ' , ' R ' , ' P ' , ' S ' , ' P ' , ' R ' , ' P ' , ' S ' ] NEW_LINE s1 = 0 NEW_LINE s2 = 0 NEW_LINE for i in s : NEW_LINE INDENT if i == ' R ' : NEW_LINE INDENT s1 += 1 NEW_LINE DEDENT elif i == ' P ' : NEW_LINE INDENT s2 += 1 NEW_LINE DEDENT elif i == ' S ' : NEW_LINE INDENT s1 -= 1 NEW_LINE DEDENT DEDENT if s1 + s2 < n : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . append ( input ( ) ) NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if s [ i ] [ j ] == ' C ' or s [ i ] [ j ] == ' M ' or s [ i ] [ j ] == ' Y ' : NEW_LINE INDENT print ( ' # Color ' ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT print ( ' # Black & White ' ) NEW_LINE DEDENT
def exponent ( A , B ) : NEW_LINE INDENT if ( A == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( B == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT y = 0 NEW_LINE if ( B % 2 == 0 ) : NEW_LINE INDENT y = exponent ( A , B // 2 ) NEW_LINE y = ( y * y ) NEW_LINE DEDENT else : NEW_LINE INDENT y = A NEW_LINE y = ( y * exponent ( A , B - 1 ) ) NEW_LINE DEDENT return y NEW_LINE DEDENT def sum ( k , n ) : NEW_LINE INDENT sum = exponent ( k , n + 1 ) - exponent ( k - 1 , n + 1 ) NEW_LINE return sum NEW_LINE DEDENT n = 3 NEW_LINE K = 3 NEW_LINE print ( sum ( K , n ) ) NEW_LINE
s = input ( ) NEW_LINE print ( s [ : : - 1 ] ) NEW_LINE
pref = [ 0 ] * 100001 ; NEW_LINE def checkPalindrome ( num ) : NEW_LINE INDENT str = str ( num ) ; NEW_LINE l = 0 ; r = len ( str ) - 1 ; NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( str [ l ] != str [ r ] ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT l += 1 ; NEW_LINE r -= 1 ; NEW_LINE DEDENT return num ; NEW_LINE DEDENT def preCompute ( ) : NEW_LINE INDENT for i in range ( 1 , 100000 ) : NEW_LINE INDENT pref [ i ] = pref [ i - 1 ] + checkPalindrome ( i ) ; NEW_LINE DEDENT DEDENT def printSum ( L , R ) : NEW_LINE INDENT print ( pref [ R ] - pref [ L - 1 ] , end = " " ) ; NEW_LINE DEDENT def printSumPalindromic ( arr , Q ) : NEW_LINE INDENT preCompute ( ) ; NEW_LINE for i in range ( Q ) : NEW_LINE INDENT printSum ( arr [ i ] [ 0 ] , arr [ i ] [ 1
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE input = sys . stdin . readline NEW_LINE from math import factorial NEW_LINE def main ( ) : NEW_LINE INDENT N , K = map ( int , input ( ) . split ( ) ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE divisors = [ ] NEW_LINE for i in range ( 1 , int ( factorial ( N ) ** 0.5 ) + 1 ) : NEW_LINE INDENT if N % i == 0 : NEW_LINE INDENT divisors . append ( i ) NEW_LINE if i * i != N : NEW_LINE INDENT divisors . append ( N // i ) NEW_LINE DEDENT DEDENT DEDENT divisors . sort ( ) NEW_LINE dp = [ [ 0 ] * ( K + 1 ) for i in range ( len ( divisors ) ) ] NEW_LINE for i in range ( len ( divisors ) ) : NEW_LINE INDENT dp [ 0 ] [ i ] = ( dp [ 0 ] [ i ] + divisors [ i ] ) % MOD NEW_LINE DEDENT ans = 0 NEW_LINE
N = 3 NEW_LINE def interchangeDiagonals ( array ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT if ( i != N // 2 ) : NEW_LINE INDENT temp = array [ i ] [ i ] NEW_LINE array [ i ] [ i ] = array [ i ] [ N - i - 1 ] NEW_LINE array [ i ] [ N - i - 1 ] = temp NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT print ( array [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT array = [ [ 4 , 5 , 6 ] , [ 1 , 2 , 3 ] , [ 7 , 8 , 9 ] ] NEW_LINE interchangeDiagonals ( array ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT s , a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE print ( s // c * a + s % c ) NEW_LINE DEDENT
MAX = 100000 ; NEW_LINE prime = [ False ] * 100002 ; NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT p = 2 ; NEW_LINE while ( p * p <= MAX ) : NEW_LINE INDENT if ( prime [ p ] == False ) : NEW_LINE INDENT for i in range ( p * 2 , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = True ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT DEDENT def superpower ( n ) : NEW_LINE INDENT SieveOfEratosthenes ( ) ; NEW_LINE superPower = 0 ; factor = 0 ; NEW_LINE i = 2 ; NEW_LINE while ( n > 1 and i <= MAX ) : NEW_LINE INDENT if ( not prime [ i ] ) : NEW_LINE INDENT factor = 0 ; NEW_LINE while ( n % i == 0 and n > 1 ) : NEW_LINE INDENT factor += 1 ; NEW_LINE n = int ( n / i ) ; NEW_LINE DEDENT if ( superPower < factor ) : NEW_LINE INDENT superPower = factor ; NEW_LINE DE
def printSubArrays ( arr , start , end ) : NEW_LINE INDENT if ( end == len ( arr ) ) : NEW_LINE INDENT return ; NEW_LINE DEDENT elif ( start > end ) : NEW_LINE INDENT printSubArrays ( arr , 0 , end + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " [ " , end , end , end , end , end ) ; NEW_LINE DEDENT print ( arr [ end ] , end , end ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 ] ; NEW_LINE printSubArrays ( arr , 0 , 0 ) ; NEW_LINE DEDENT
def isDivisible999 ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE if ( n == 0 and num [ 0 ] == '0' ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 3 == 1 ) : NEW_LINE INDENT num = "00" + num NEW_LINE DEDENT if ( n % 3 == 2 ) : NEW_LINE INDENT num = "0" + num NEW_LINE DEDENT gSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT group = 0 NEW_LINE group += int ( num [ i ] ) * 100 NEW_LINE group += int ( num [ i ] ) * 10 NEW_LINE group += int ( num [ i ] ) NEW_LINE gSum += group NEW_LINE DEDENT if ( gSum > 1000 ) : NEW_LINE INDENT num = str ( gSum ) NEW_LINE n = len ( num ) NEW_LINE gSum = 1 NEW_LINE DEDENT return ( gSum == 999 ) NEW_LINE DEDENT num = "1998" NEW_LINE print ( " Divisible " if isDivisible999 ( num ) else " Not �
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = sum ( l ) NEW_LINE a = s // n NEW_LINE b = s % n NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a += l [ i ] NEW_LINE b += a NEW_LINE c += 1 NEW_LINE DEDENT print ( c ) NEW_LINE
n = 5 ; a = 2 ; NEW_LINE print ( " % . 3 f " , sumOfSeries ( a , n ) ) ; NEW_LINE
def printTheArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT def generateAllBinaryStrings ( n , arr , i ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT printTheArray ( arr , n ) ; NEW_LINE return ; NEW_LINE DEDENT arr [ i ] = 0 ; NEW_LINE generateAllBinaryStrings ( n , arr , i + 1 ) ; NEW_LINE arr [ i ] = 1 ; NEW_LINE generateAllBinaryStrings ( n , arr , i + 1 ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 ; NEW_LINE arr = [ 0 ] * n ; NEW_LINE generateAllBinaryStrings ( n , arr , 0 ) ; NEW_LINE DEDENT
def numberSequence ( n ) : NEW_LINE INDENT num = ( pow ( 4 , n ) - pow ( 2 , n ) ) - 1 NEW_LINE return num NEW_LINE DEDENT n = 4 NEW_LINE print ( numberSequence ( n ) ) NEW_LINE
def digitProduct ( n ) : NEW_LINE INDENT prod = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT prod = prod * ( n % 10 ) NEW_LINE n = n // 10 NEW_LINE DEDENT return prod NEW_LINE DEDENT def printMultiplicativePrimes ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) NEW_LINE prime [ 0 ] = prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ i ] and prime [ digitProduct ( i ) ] ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT n = 10 NEW_LINE printMultiplicativePrimes ( n ) NEW_LINE
def minMoves ( arr , n ) : NEW_LINE INDENT expectedItem = n NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] == expectedItem ) : NEW_LINE INDENT expectedItem -= 1 NEW_LINE DEDENT DEDENT return expectedItem NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 3 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minMoves ( arr , n ) ) NEW_LINE DEDENT
def largestGCDSubsequence ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE maxele = max ( arr ) NEW_LINE for i in range ( 2 , maxele + 1 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT ans = max ( ans , count ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 6 , 2 , 5 , 4 ] NEW_LINE size = len ( arr ) NEW_LINE print ( largestGCDSubsequence ( arr , size ) ) NEW_LINE DEDENT
def calculateSum ( n ) : NEW_LINE INDENT a1 = 1 NEW_LINE a2 = 2 NEW_LINE r = 2 NEW_LINE d = 1 NEW_LINE return ( n ) * ( 2 * a1 + ( n - 1 ) * d ) // 2 + a2 * ( pow ( r , n ) - 1 ) // ( r - 1 ) ) NEW_LINE DEDENT n = 5 NEW_LINE print ( " Sum ▁ = " , calculateSum ( n ) ) NEW_LINE
def count ( str1 , str2 ) : NEW_LINE INDENT c = 0 ; j = 0 ; NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT if ( str2 . find ( str1 [ i ] ) >= 0 ) : NEW_LINE INDENT c += 1 ; NEW_LINE DEDENT DEDENT print ( " No . ▁ of ▁ matching ▁ characters ▁ are : " , c ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str1 = " aabcddekll12 @ " ; NEW_LINE str2 = " bb2211@55k " ; NEW_LINE count ( str1 , str2 ) ; NEW_LINE DEDENT
import sys NEW_LINE def MinimumX ( a , b , c , k ) : NEW_LINE INDENT x = sys . maxsize NEW_LINE if ( k <= c ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT h = k - c NEW_LINE l = 0 NEW_LINE while ( l <= h ) : NEW_LINE INDENT m = ( l + h ) // 2 NEW_LINE if ( ( a * m * m ) + ( b * m ) > ( k - c ) ) : NEW_LINE INDENT x = min ( x , m ) NEW_LINE h = m - 1 NEW_LINE DEDENT elif ( ( a * m * m ) + ( b * m ) < ( k - c ) ) : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return m NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 3 NEW_LINE b = 2 NEW_LINE c = 4 NEW_LINE k = 15 NEW_LINE print ( MinimumX ( a , b , c , k ) ) NEW_LINE DEDENT
def minLettersNeeded ( n ) : NEW_LINE INDENT if ( n % 26 == 0 ) : NEW_LINE INDENT return ( n // 26 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( n // 26 ) + 1 ) NEW_LINE DEDENT DEDENT n = 52 NEW_LINE print ( minLettersNeeded ( n ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE d = { } NEW_LINE for i in s : NEW_LINE INDENT if i in d : NEW_LINE INDENT d [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] = 1 NEW_LINE DEDENT DEDENT c = [ 0 ] * 26 NEW_LINE for i in d : NEW_LINE INDENT c [ i ] = min ( c [ i ] , d [ i - 1 ] ) NEW_LINE DEDENT for i in range ( 1 , 26 ) : NEW_LINE INDENT c [ i ] = min ( c [ i ] , d [ i - 1 ] ) NEW_LINE DEDENT for i in range ( min ( 24 , n // k ) ) : NEW_LINE INDENT c [ i ] = c [ i ] - c [ i - 1 ] NEW_LINE DEDENT for i in range ( min ( 24 , n // k ) ) : NEW_LINE INDENT if c [ i ] > c [ i - 1 ] : NEW_
a = int ( input ( ) ) NEW_LINE b = int ( input ( ) ) NEW_LINE c = int ( input ( ) ) NEW_LINE d = int ( input ( ) ) NEW_LINE if max ( a , b , c ) > max ( a , b , c ) : NEW_LINE INDENT print ( " Misha " ) NEW_LINE DEDENT elif max ( a , b , c ) < max ( a , b , c ) : NEW_LINE INDENT print ( " Vasya " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Tie " ) NEW_LINE DEDENT
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if abs ( a - b ) < 2 : NEW_LINE INDENT print ( " Yay ! " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " : ( " ) NEW_LINE DEDENT
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a > b : NEW_LINE INDENT print ( a - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a ) NEW_LINE DEDENT
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE input = sys . stdin . readline NEW_LINE from collections import Counter NEW_LINE def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE A = Counter ( A ) NEW_LINE def is_prime ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) NEW_LINE prime [ 0 ] = False NEW_LINE for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT A = sorted ( A ) NEW_LINE for i in A : NEW_LINE INDENT if is_prime ( i ) : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( 2 , int ( i ** 0.5 ) + 1 ) : NEW_LINE INDENT if i % j == 0 : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT return
def ways ( s , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT dp [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT temp = " " NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT temp += s [ j ] NEW_LINE test = " " NEW_LINE for k in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT test += s [ k ] NEW_LINE if ( test < temp ) : NEW_LINE INDENT dp [ i ] [ j ] += dp [ k ] [ i - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += dp [ i ] [ n - 1 ] NEW_LINE DE
a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE print ( " abcdefghijklmnopqrstuvwxyz " [ a == b and b == c ] ) NEW_LINE
def isOdd ( arr , n ) : NEW_LINE INDENT flag , flag1 , sum = 0 , 0 , 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE if ( arr [ i ] % 2 == 0 and flag == 0 ) : NEW_LINE INDENT flag = 1 NEW_LINE l = arr [ i ] NEW_LINE DEDENT if ( arr [ i ] % 2 != 0 and flag1 == 0 ) : NEW_LINE INDENT r = arr [ i ] NEW_LINE flag1 = 1 NEW_LINE DEDENT DEDENT if ( sum % 2 != 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT if ( flag1 == 1 and flag == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT ar = [ 5 , 4 , 4 , 5 , 1 , 3 ] NEW_LINE n = len ( ar ) NEW_LINE res = isOdd ( ar , n ) NEW_LINE if
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE i = 0 NEW_LINE j = len ( s ) - 1 NEW_LINE while k > 0 and i < j : NEW_LINE INDENT if s [ i ] != s [ j ] : NEW_LINE INDENT k -= 1 NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT def maxCommonFactors ( a , b ) : NEW_LINE INDENT __gcd = gcd ( a , b ) NEW_LINE ans = 1 NEW_LINE for i in range ( 2 , int ( __gcd ** 0.5 ) + 1 ) : NEW_LINE INDENT if ( __gcd % i == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE while ( __gcd % i == 0 ) : NEW_LINE INDENT __gcd //= i NEW_LINE DEDENT DEDENT DEDENT if ( __gcd != 1 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 12 NEW_LINE b = 18 NEW_LINE print ( maxCommonFactors ( a , b ) ) NEW_LINE DEDENT
def allCharactersSame ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] != s [ 0 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " aaa " NEW_LINE if ( allCharactersSame ( s ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE b = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE print ( ' YES ' if a [ 0 ] > b [ 0 ] else ' NO ' ) NEW_LINE DEDENT
def printUnsorted ( arr , n ) : NEW_LINE INDENT s = 0 NEW_LINE e = n - 1 NEW_LINE for s in range ( 0 , n - 1 ) : NEW_LINE INDENT if arr [ s ] > arr [ s + 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if s == n - 1 : NEW_LINE INDENT print ( " The ▁ complete ▁ array ▁ is ▁ sorted " ) NEW_LINE return NEW_LINE DEDENT for e in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT if arr [ e ] < arr [ e - 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT max = arr [ s ] NEW_LINE min = arr [ s ] NEW_LINE for i in range ( s + 1 , e + 1 ) : NEW_LINE INDENT if arr [ i ] > max : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT if arr [ i ] < min : NEW_LINE INDENT i = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( n - 1 , -
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l1 = [ ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if l [ i ] <= l [ i + 1 ] : NEW_LINE INDENT l1 . append ( i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT l1 . append ( l [ i ] ) NEW_LINE DEDENT DEDENT print ( max ( l1 ) ) NEW_LINE
L , D = map ( int , input ( ) . split ( ) ) NEW_LINE print ( L // D + L % D ) NEW_LINE
def check ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE digitSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT digitSum += ( ord ( str [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT return ( digitSum % 9 == 0 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = "99333" NEW_LINE if check ( str ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def check ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE if ( ( ord ( str [ n - 1 ] ) - ord ( '0' ) ) % 2 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT digitSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT digitSum += ( ord ( str [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT return ( digitSum % 3 == 0 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = "1332" NEW_LINE if ( check ( str ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
class Solution ( object ) : NEW_LINE INDENT def letterCasePermutation ( self , S ) : NEW_LINE INDENT ans = [ ] NEW_LINE for c in S : NEW_LINE INDENT n = len ( ans ) NEW_LINE if c . islower ( ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT ans . append ( chr ( ord ( c ) . lower ( ) ) ) NEW_LINE ans [ n + i ] = chr ( ord ( c ) . upper ( ) ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT ans . append ( c ) NEW_LINE ans [ i ] = chr ( ord ( c ) . lower ( ) ) NEW_LINE ans [ n + i ] = chr ( ord ( c ) . upper ( ) ) NEW_LINE DEDENT DEDENT DEDENT ans = " " . join ( ans ) NEW_LINE return ans NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE S = " a1b2" NEW_LINE out = sObj .
import math NEW_LINE def countDigits ( n ) : NEW_LINE INDENT return ( n * math . log10 ( 2 ) + 1 ) NEW_LINE DEDENT n = 5 NEW_LINE print ( countDigits ( n ) ) NEW_LINE
import math NEW_LINE def isPerfectSquare ( N ) : NEW_LINE INDENT sr = math . sqrt ( N ) NEW_LINE return ( sr - math . floor ( sr ) ) == 0 NEW_LINE DEDENT def BetrothedNumbers ( n , m ) : NEW_LINE INDENT Sum1 = 1 NEW_LINE Sum2 = 1 NEW_LINE for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT Sum1 += i + ( isPerfectSquare ( n ) ) NEW_LINE DEDENT DEDENT for i in range ( 2 , int ( math . sqrt ( m ) ) + 1 ) : NEW_LINE INDENT if ( m % i == 0 ) : NEW_LINE INDENT Sum2 += i + ( isPerfectSquare ( m ) ) NEW_LINE DEDENT DEDENT if ( ( n + 1 == Sum2 ) and ( m + 1 == Sum1 ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT if __name__
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 40000000 NEW_LINE totient = eulerlib . list_totients ( LIMIT - 1 ) NEW_LINE totient_chain_length = [ 0 ] * ( LIMIT - 1 ) NEW_LINE totient_chain_length [ 0 ] = 0 NEW_LINE for i in range ( 1 , len ( totient ) ) : NEW_LINE INDENT chainlen = totient_chain_length [ totient [ i ] ] + 1 NEW_LINE if chainlen == 25 and totient [ i ] == i - 1 : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return str ( sum ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE c = 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if a [ i ] + 1 < a [ i + 1 ] : NEW_LINE INDENT c += 1 NEW_LINE a [ i ] += 1 NEW_LINE DEDENT elif a [ i ] != a [ i + 1 ] : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE DEDENT
import sys NEW_LINE from sys import stdin NEW_LINE input = stdin . readline NEW_LINE def print ( * args , end = ' \n ' , sep = ' ▁ ' ) -> None : NEW_LINE INDENT sys . stdout . write ( sep . join ( map ( str , args ) ) + end ) NEW_LINE DEDENT def Solve ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE if N == 0 : NEW_LINE INDENT exit ( ) NEW_LINE DEDENT P = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] NEW_LINE ans = [ [ 0 ] * N for _ in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT ans [ i ] [ j ] = P [ i ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT print ( " % 3d " % ( ans [ i ] [ j ] , end = " " ) ) NEW
def findGreatest ( arr , n ) : NEW_LINE INDENT result = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( arr [ j ] * arr [ k ] == arr [ i ] ) : NEW_LINE INDENT result = max ( result , arr [ i ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT arr = [ 30 , 10 , 9 , 3 , 35 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findGreatest ( arr , n ) ) NEW_LINE
def XorSum ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT k = 0 NEW_LINE for j in range ( 1 , arr [ i ] + 1 ) : NEW_LINE INDENT k ^= arr [ i ] NEW_LINE DEDENT result += k NEW_LINE DEDENT return result NEW_LINE DEDENT arr = [ 1 , 2 , 6 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( XorSum ( arr , n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans . append ( max ( map ( int , s . split ( ) ) ) ) NEW_LINE DEDENT for i in ans : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT
MAX = 256 NEW_LINE def compare ( arr1 , arr2 ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT if ( arr1 [ i ] != arr2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def search ( pat , txt ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE countP = [ 0 ] * MAX NEW_LINE countTW = [ 0 ] * MAX NEW_LINE for i in range ( M ) : NEW_LINE INDENT countP [ pat [ i ] ] += 1 NEW_LINE countTW [ txt [ i ] ] += 1 NEW_LINE DEDENT for i in range ( M , N ) : NEW_LINE INDENT if ( compare ( countP , countTW ) ) : NEW_LINE INDENT print ( " Found ▁ at ▁ Index " , ( i - M ) ) NEW_LINE DEDENT countTW [ txt [ i ] ] -= 1 NEW_LINE DEDENT if ( compare ( countP , countTW ) ) : NEW_LINE INDENT print ( " Found �
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = x + ( 2 * i - n + 1 ) * a [ i ] NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT y = y + ( 2 * i - m + 1 ) * a [ i ] NEW_LINE DEDENT print ( ( x * y ) % mod ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE fib = [ 0 ] * ( n + 1 ) NEW_LINE fib [ 0 ] , fib [ 1 ] = 1 , 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if fib [ i ] <= k : NEW_LINE INDENT fib [ i ] , fib [ i + 1 ] = fib [ i + 1 ] , fib [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT k -= fib [ i ] NEW_LINE fib [ i ] , fib [ i + 1 ] = fib [ i + 1 ] , fib [ i ] NEW_LINE DEDENT DEDENT print ( * fib ) NEW_LINE
d = { } NEW_LINE d [ ' S ' ] = int ( input ( ) ) NEW_LINE d [ ' M ' ] = int ( input ( ) ) NEW_LINE d [ ' L ' ] = int ( input ( ) ) NEW_LINE d [ ' XL ' ] = int ( input ( ) ) NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT k = input ( ) NEW_LINE if k in d : NEW_LINE INDENT print ( k ) NEW_LINE d [ k ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT for i in d : NEW_LINE INDENT if d [ i ] > 0 : NEW_LINE INDENT print ( i ) NEW_LINE d [ i ] -= 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , x = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] + b [ i ] > x : NEW_LINE INDENT print ( " NO " ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT
def solve ( n ) : NEW_LINE INDENT ans = ( n * n // 4 ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 10 NEW_LINE print ( solve ( n ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( "1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ( " + " ) " * ( 2 * n ) + " ) " ) NEW_LINE DEDENT DEDENT
def Valid ( a , b , c , d ) : NEW_LINE INDENT if ( a + b + c + d == 360 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT a = 80 NEW_LINE b = 70 NEW_LINE c = 100 NEW_LINE d = 110 NEW_LINE if ( Valid ( a , b , c , d ) == 1 ) : NEW_LINE INDENT print ( " Valid ▁ quadilateral " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Invalid ▁ quadilateral " ) NEW_LINE DEDENT
import math NEW_LINE n , r , a = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT if r >= a * 2 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT elif n == 2 : NEW_LINE INDENT if r >= a * 2 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
MAX = 100001 ; NEW_LINE prime = [ 0 ] * ( MAX + 1 ) ; NEW_LINE countdiv = [ 0 ] * ( MAX + 1 ) ; NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT for i in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i * 2 , MAX + 1 , i ) : NEW_LINE INDENT prime [ j ] = i ; NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , MAX ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT prime [ i ] = i ; NEW_LINE DEDENT DEDENT DEDENT def largestGCDSubsequence ( arr , n ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT element = arr [ i ] ; NEW_LINE while ( element > 1 ) : NEW_LINE INDENT div = prime [ element ] ; NEW_LINE countdiv [ div ] = countdiv [ div ] ; NEW_LINE ans = max ( ans , count
def Count ( s , pos ) : NEW_LINE INDENT c = s [ pos - 1 ] NEW_LINE counter = 0 NEW_LINE for i in range ( pos - 1 ) : NEW_LINE INDENT if ( s [ i ] == c ) : NEW_LINE INDENT counter = counter + 1 NEW_LINE DEDENT DEDENT return counter NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " abacsddaa " NEW_LINE n = len ( s ) NEW_LINE query = [ 9 , 3 , 2 ] NEW_LINE Q = len ( query ) NEW_LINE for i in range ( Q ) : NEW_LINE INDENT pos = query [ i ] NEW_LINE print ( Count ( s , pos ) ) NEW_LINE DEDENT DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE if a >= b : NEW_LINE INDENT print ( b ) NEW_LINE DEDENT else : NEW_LINE INDENT if c >= d : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( b + ( c - d ) * b ) NEW_LINE DEDENT DEDENT DEDENT
arr = [ 12 , 11 , 40 , 12 , 5 , 6 , 5 , 12 , 11 ] NEW_LINE n = len ( arr ) NEW_LINE d = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in d : NEW_LINE INDENT d [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT for i in d : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE if d [ i ] > 1 : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE dup = True NEW_LINE DEDENT DEDENT if dup : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT
N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE A . sort ( ) NEW_LINE if sum ( A ) % 2 == 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
import sys NEW_LINE def findMissingUtil ( arr , low , high , diff ) : NEW_LINE INDENT if ( high <= low ) : NEW_LINE INDENT return sys . maxsize NEW_LINE DEDENT mid = low + ( high - low ) // 2 NEW_LINE if ( arr [ mid + 1 ] - arr [ mid ] != diff ) : NEW_LINE INDENT return ( arr [ mid ] + diff ) NEW_LINE DEDENT if ( mid > 0 and arr [ mid ] - arr [ mid - 1 ] != diff ) : NEW_LINE INDENT return ( arr [ mid - 1 ] + diff ) NEW_LINE DEDENT if ( arr [ mid ] == arr [ 0 ] + mid * diff ) : NEW_LINE INDENT return findMissingUtil ( arr , mid + 1 , high , diff ) NEW_LINE DEDENT return findMissingUtil ( arr , low , mid - 1 , diff ) NEW_LINE DEDENT def findMissing ( arr , n ) : NEW_LINE INDENT diff = ( arr [ n - 1 ] - arr [ 0 ] ) // n NEW_LINE return findMissingUtil ( arr , 0 , n - 1 , diff ) NEW_LINE DEDENT arr = [ 2 , 4 ,
def findPair ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT print ( " - 1" , end = " ▁ " ) ; NEW_LINE return ; NEW_LINE DEDENT first = second = - 1 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT second = first ; NEW_LINE first = arr [ i ] ; NEW_LINE DEDENT elif ( arr [ i ] > second ) : NEW_LINE INDENT second = arr [ i ] ; NEW_LINE DEDENT DEDENT print ( " n ▁ = " , first , " and ▁ r ▁ = " , second ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 0 , 2 , 3 , 4 , 1 , 6 , 8 , 9 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE findPair ( arr , n ) ; NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l1 = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT l1 . append ( l [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT l1 . append ( l [ i ] + l [ i - 1 ] ) NEW_LINE DEDENT DEDENT l1 . sort ( ) NEW_LINE l1 . reverse ( ) NEW_LINE print ( l1 [ 0 ] + 1 , l1 [ - 1 ] + 1 ) NEW_LINE
s = input ( ) NEW_LINE vowel = [ ' w ' , ' k ' , ' s ' , ' t ' , ' n ' , ' h ' , ' m ' , ' y ' , ' r ' , ' e ' , ' d ' , ' o ' ] NEW_LINE ans = [ ] NEW_LINE for i in range ( len ( s ) // 2 ) : NEW_LINE INDENT if s [ i ] == '0' : NEW_LINE INDENT ans . append ( vowel [ ord ( s [ i ] ) - ord ( '0' ) ] ) NEW_LINE DEDENT elif s [ i ] == 'U ' : NEW_LINE INDENT ans . append ( vowel [ ord ( s [ i ] ) - ord ( '0' ) ] ) NEW_LINE DEDENT elif s [ i ] == 'T ' : NEW_LINE INDENT ans . append ( vowel [ ord ( s [ i ] ) - ord ( '0' ) ] ) NEW_LINE DEDENT elif s [ i ] == 'L ' : NEW_LINE INDENT ans . append ( vowel [ ord ( ' i ' ) - ord ( 'u ' ) ] ) NEW_LINE DEDENT elif s [ i ]
def Square ( row , column , moves ) : NEW_LINE INDENT a = row - moves ; NEW_LINE b = row + moves ; NEW_LINE c = column - moves ; NEW_LINE d = column + moves ; NEW_LINE total = 0 ; NEW_LINE a = row - moves ; NEW_LINE b = row + moves ; NEW_LINE c = column - moves ; NEW_LINE d = column + moves ; NEW_LINE total = 0 ; NEW_LINE if ( a < 1 ) : NEW_LINE INDENT a = 1 ; NEW_LINE DEDENT if ( c < 1 ) : NEW_LINE INDENT c = 1 ; NEW_LINE DEDENT if ( b > 8 ) : NEW_LINE INDENT b = 8 ; NEW_LINE DEDENT if ( d > 8 ) : NEW_LINE INDENT d = 8 ; NEW_LINE DEDENT total = ( b - a + 1 ) * ( d - c + 1 ) - 1 ; NEW_LINE return total ; NEW_LINE DEDENT R = 4 ; NEW_LINE C = 5 ; M = 2 ; NEW_LINE print ( Square ( R , C , M ) ) ; NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( a + b + c ) % 2 ) NEW_LINE DEDENT
import math NEW_LINE def powmod ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def discreteLogarithm ( a , b , m ) : NEW_LINE INDENT n = int ( math . sqrt ( m ) + 1 ) NEW_LINE value = [ 0 ] * m NEW_LINE for i in range ( n , - 1 , - 1 ) : NEW_LINE INDENT value [ powmod ( a , i * n , m ) ] = i NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT cur = ( powmod ( a , j , m ) * b ) % m NEW_LINE if ( value [ cur ] > 0 ) : NEW_LINE INDENT ans = value [ cur ] * n - j NEW_LINE if ( ans < m ) : NEW_LINE INDENT return ans NEW_
def Circumference ( l , w ) : NEW_LINE INDENT return ( 2 * ( l + w ) ) NEW_LINE DEDENT l = 8 NEW_LINE w = 4 NEW_LINE c = Circumference ( l , w ) NEW_LINE print ( " Circumference ▁ of ▁ a ▁ rectangle ▁ is " , c ) NEW_LINE
import math NEW_LINE def edgeDisjoint ( n ) : NEW_LINE INDENT result = 0 NEW_LINE result = math . floor ( n / 2 ) NEW_LINE return result NEW_LINE DEDENT n = 4 NEW_LINE print ( edgeDisjoint ( n ) ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT b . append ( i + a [ i ] ) NEW_LINE DEDENT ans = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans . append ( i ) NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT ans . append ( b [ i ] ) NEW_LINE DEDENT print ( * ans ) NEW_LINE
sum = [ 0 ] * 1000005 ; NEW_LINE def toInt ( x ) : NEW_LINE INDENT return ord ( x ) - ord ( '0' ) ; NEW_LINE DEDENT def prepareSum ( s ) : NEW_LINE INDENT sum [ 0 ] = 0 ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT sum [ i + 1 ] = sum [ i ] + toInt ( s [ i ] ) ; NEW_LINE DEDENT DEDENT def query ( l , r ) : NEW_LINE INDENT if ( ( sum [ r + 1 ] - sum [ l ] ) % 3 == 0 ) : NEW_LINE INDENT print ( " Divisible ▁ by ▁ 3" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ divisible ▁ by ▁ 3" ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = "12468236544" ; NEW_LINE prepareSum ( n ) ; NEW_LINE query ( 0 , 1 ) ; NEW_LINE query ( 1 , 2
def compute ( ) : NEW_LINE INDENT LIMIT = 100000 NEW_LINE rads = [ 1 ] * LIMIT NEW_LINE for i in range ( 2 , LIMIT + 1 ) : NEW_LINE INDENT if rads [ i ] == 1 : NEW_LINE INDENT for j in range ( i , LIMIT + 1 , i ) : NEW_LINE INDENT rads [ j ] *= i NEW_LINE DEDENT DEDENT DEDENT data = [ ] NEW_LINE for i in range ( LIMIT + 1 ) : NEW_LINE INDENT data . append ( ( rads [ i + 1 ] , i + 1 ) ) NEW_LINE DEDENT data . sort ( ) NEW_LINE return str ( data [ 10000 - 1 ] . b ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n < 14 : NEW_LINE INDENT print ( " NO " ) NEW_LINE continue NEW_LINE DEDENT if n % 14 == 0 : NEW_LINE INDENT print ( " NO " ) NEW_LINE continue NEW_LINE DEDENT if n % 14 == 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n >= m // 2 : NEW_LINE INDENT print ( m // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n + ( m - 2 * n ) // 4 ) NEW_LINE DEDENT
def printFirstNegativeInteger ( arr , n , k ) : NEW_LINE INDENT Di = [ ] NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT Di . append ( i ) NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( len ( Di ) > 0 ) : NEW_LINE INDENT print ( arr [ Di [ - 1 ] ] , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" , end = " ▁ " ) NEW_LINE DEDENT while ( len ( Di ) > 0 and Di [ - 1 ] < ( i - k + 1 ) ) : NEW_LINE INDENT Di . pop ( ) NEW_LINE DEDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT Di . append ( i ) NEW_LINE DEDENT DEDENT if ( len ( Di ) > 0 ) : NEW_LINE INDENT print ( arr [ Di [ - 1 ] ] , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT
import math NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( 1 , int ( math . sqrt ( a [ 0 ] ) ) + 1 ) : NEW_LINE INDENT if a [ 0 ] % i == 0 : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if a [ j ] % i == 0 : NEW_LINE INDENT a [ j ] //= i NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( * a ) NEW_LINE
a = input ( ) NEW_LINE b = int ( input ( ) ) NEW_LINE c = int ( input ( ) ) NEW_LINE d = int ( input ( ) ) NEW_LINE e = int ( input ( ) ) NEW_LINE f = int ( input ( ) ) NEW_LINE g = int ( input ( ) ) NEW_LINE h = int ( input ( ) ) NEW_LINE i = int ( input ( ) ) NEW_LINE j = int ( input ( ) ) NEW_LINE print ( a , b , c , f ) NEW_LINE
from math import sqrt NEW_LINE x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE q = int ( input ( ) ) NEW_LINE for _ in range ( q ) : NEW_LINE INDENT x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE x1 , y1 = x1 - x2 , y1 - y2 NEW_LINE x2 , y2 = x2 , y2 - x1 NEW_LINE d = sqrt ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) NEW_LINE a = x1 NEW_LINE b = y1 NEW_LINE c = y1 NEW_LINE d = d / d NEW_LINE e = y1 NEW_LINE f = x2 - x1 NEW_LINE g = y2 - y1 NEW_LINE x = ( d - a ) / d NEW_LINE y = ( d - b ) / d NEW_LINE x = ( d - c ) / d NEW_LINE print ( x , y ) NEW_LINE DEDENT
from math import sqrt NEW_LINE xp1 , yp1 , xp2 , yp2 = map ( int , input ( ) . split ( ) ) NEW_LINE q = int ( input ( ) ) NEW_LINE xp = [ ] NEW_LINE yp = [ ] NEW_LINE for i in range ( q ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE xp . append ( x ) NEW_LINE yp . append ( y ) NEW_LINE DEDENT for i in range ( q ) : NEW_LINE INDENT xp . append ( sqrt ( ( xp1 [ i ] - xp2 [ i ] ) ** 2 + ( yp1 [ i ] - yp2 [ i ] ) ** 2 ) ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( q ) : NEW_LINE INDENT t = ( xp [ i ] - xp1 [ i ] ) ** 2 + ( yp [ i ] - yp1 [ i ] ) ** 2 NEW_LINE ans = max ( ans , t ) NEW_LINE DEDENT print ( ans ) NEW_LINE
def printInitials ( str ) : NEW_LINE INDENT len1 = len ( str ) NEW_LINE for i in range ( len1 ) : NEW_LINE INDENT if str [ i ] != ' ▁ ' : NEW_LINE INDENT str1 = str1 . upper ( ) + str [ 0 ] . lower ( ) NEW_LINE DEDENT else : NEW_LINE INDENT str1 = str1 . upper ( ) + str [ 0 ] . upper ( ) NEW_LINE DEDENT DEDENT print ( str1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " ishita ▁ bhuiya " NEW_LINE printInitials ( str ) NEW_LINE DEDENT
def max_sum ( arr , n , k ) : NEW_LINE INDENT dp = [ 0 ] * n ; NEW_LINE dp [ 0 ] = max ( 0 , arr [ 0 ] ) ; NEW_LINE i = 1 ; NEW_LINE while ( i < k ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i - 1 ] , arr [ i ] ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT i = k ; NEW_LINE while ( i < n ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i - 1 ] , arr [ i ] + dp [ i - k ] ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT return dp [ n - 1 ] ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , - 2 , 4 , 3 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 4 ; NEW_LINE print ( max_sum ( arr , n , k ) ) ; NEW_LINE DEDENT
k = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE if k == 1 : NEW_LINE INDENT print ( s [ 0 ] ) NEW_LINE DEDENT elif k == 2 : NEW_LINE INDENT print ( s [ 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ 0 ] + s [ 1 ] ) NEW_LINE DEDENT
def countX ( a , b ) : NEW_LINE INDENT if ( b > a ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( a == b ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = a - b NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , int ( x ** 0.5 ) + 1 ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT d1 = i NEW_LINE d2 = b - 1 NEW_LINE if ( i * i != x ) : NEW_LINE INDENT d2 = x // i NEW_LINE DEDENT if ( d1 > b ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT if ( d2 > b ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 21 NEW_LINE b = 5 NEW_LINE print ( countX ( a , b ) ) NEW_LINE DEDENT
from collections import deque NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE g = [ [ ] for _ in range ( n + 1 ) ] NEW_LINE for _ in range ( m ) : NEW_LINE INDENT l , r , d = map ( int , input ( ) . split ( ) ) NEW_LINE l -= 1 NEW_LINE r -= 1 NEW_LINE g [ l ] . append ( ( r , d ) ) NEW_LINE g [ r ] . append ( ( l , - d ) ) NEW_LINE DEDENT p = [ 0 ] * n NEW_LINE used = [ False ] * n NEW_LINE q = deque ( ) NEW_LINE used [ 0 ] = True NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT q . append ( i ) NEW_LINE for j in g [ i ] : NEW_LINE INDENT if used [ j ] : NEW_LINE INDENT continue NEW_LINE DEDENT if p [ j ] != p [ i - 1 ] + j : NEW_LINE INDENT continue NEW_LINE DEDENT used [ j ] = True NEW_LINE p [ i - 1 ]
nA , nB , k , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if a [ k - 1 ] < b [ nB - m ] : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
import math NEW_LINE a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 0 and b == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT elif a == 0 and b == 0 : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( 1 * - c / b ) NEW_LINE DEDENT elif a == 0 and b == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif b == 0 and c == 0 : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( 1 * - c / b ) NEW_LINE DEDENT else : NEW_LINE INDENT d = b ** 2 - 4 * a * c NEW_LINE if d < 0 : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 ) NEW_LINE print ( ( - b + d ) / ( 2 * a ) ) NEW_LINE DEDENT DEDENT
def average ( a , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] ; NEW_LINE DEDENT return sum / n ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 10 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( average ( arr , n ) ) ; NEW_LINE DEDENT
def isKSortedArray ( arr , n , k ) : NEW_LINE INDENT aux = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT aux . append ( arr [ i ] ) NEW_LINE DEDENT aux . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = bisect . bisect_left ( aux , arr [ i ] ) NEW_LINE if abs ( i - j ) > k : NEW_LINE INDENT return " No " NEW_LINE DEDENT DEDENT return " Yes " NEW_LINE DEDENT arr = [ 3 , 2 , 1 , 5 , 6 , 4 ] NEW_LINE k = 2 NEW_LINE print ( " Is ▁ it ▁ a ▁ k ▁ sorted ▁ array ? : " , isKSortedArray ( arr , len ( arr ) , k ) ) NEW_LINE
def nCr ( n , k ) : NEW_LINE INDENT C = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] NEW_LINE DEDENT def resultOfAllSubsets ( arr , N ) : NEW_LINE INDENT result = 0.0 NEW_LINE sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for n in range ( 1 , N + 1 ) : NEW_LINE INDENT result += ( sum * ( nCr ( N - 1 , n - 1 ) ) ) / n NEW_LINE DE
import math NEW_LINE def productPrimeFactors ( n ) : NEW_LINE INDENT product = 1 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT product *= 2 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = n // 2 NEW_LINE DEDENT DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT product = product * i NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT n = n // i NEW_LINE DEDENT DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT product = product * n NEW_LINE DEDENT return product NEW_LINE DEDENT n = 44 NEW_LINE print ( productPrimeFactors ( n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if s [ i ] == s [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if a [ i ] < 0 : NEW_LINE INDENT a [ i ] = - a [ i ] NEW_LINE DEDENT DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT if a [ i ] > 0 : NEW_LINE INDENT a [ i + 1 ] = - a [ i ] NEW_LINE DEDENT DEDENT if len ( a ) == 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE ans = n NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if a [ i ] > a [ i + 1 ] + k : NEW_LINE INDENT ans -= 1 NEW_LINE DEDENT elif a [ i ] < a [ i + 1 ] : NEW_LINE INDENT ans -= 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( y % 2 == 0 ) : NEW_LINE INDENT return power ( x , y // 2 ) * power ( x , y // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return x * power ( x , y // 2 ) * power ( x , y // 2 ) NEW_LINE DEDENT DEDENT x = 2 NEW_LINE y = 3 NEW_LINE print ( power ( x , y ) ) NEW_LINE
import sys NEW_LINE def charVal ( s , i ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( s [ i ] == '1' ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT def countMinimalReplacements ( s , i , prev , dp , n ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ prev ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ prev ] NEW_LINE DEDENT val = charVal ( s , i ) NEW_LINE ans = sys . maxsize NEW_LINE if ( val == prev ) : NEW_LINE INDENT val = 0 NEW_LINE for cur in range ( 0 , 2 ) : NEW_LINE INDENT if ( cur == prev ) : NEW_LINE INDENT continue NEW_LINE DEDENT val = 1 + countMinimalReplacements ( s , i + 1 , cur , dp , n ) NEW_LINE ans = min ( ans , val ) NEW_LINE DEDENT
def xorRange ( pre , l , r ) : NEW_LINE INDENT cntOnes = pre [ r ] NEW_LINE if ( l - 1 >= 0 ) : NEW_LINE INDENT cntOnes -= pre [ l - 1 ] NEW_LINE DEDENT if ( cntOnes % 2 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT def performQueries ( queries , q , a , n ) : NEW_LINE INDENT pre = [ 0 ] * n NEW_LINE pre [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + a [ i ] NEW_LINE DEDENT for i in range ( q ) : NEW_LINE INDENT print ( xorRange ( pre , queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 0 , 1 , 1 , 0 , 1 , 1 ] NEW_LINE n = len ( a ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k , u = map ( int , input ( ) . split ( ) ) NEW_LINE p = list ( map ( float , input ( ) . split ( ) ) ) NEW_LINE p . sort ( ) NEW_LINE ans = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( p [ i + 1 ] - p [ i ] ) * ( i + 1 ) > u : NEW_LINE INDENT ans = 0 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT u -= p [ i ] - p [ i + 1 ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
import sys NEW_LINE def printArray ( A , n , K ) : NEW_LINE INDENT minEle = sys . maxsize ; NEW_LINE maxEle = sys . maxsize ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT minEle = min ( minEle , A [ i ] ) ; NEW_LINE maxEle = max ( maxEle , A [ i ] ) ; NEW_LINE DEDENT if ( K != 0 ) : NEW_LINE INDENT if ( K % 2 == 1 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT A [ i ] = maxEle - A [ i ] ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT A [ i ] = A [ i ] - minEle ; NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( A [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT arr = [ 4 , 8 , 12 , 16 ] ; NEW_LINE K = 4 ; NEW_LINE N = len ( arr ) ; NEW_LINE printArray
import sys NEW_LINE readline = sys . stdin . readline NEW_LINE write = sys . stdout . write NEW_LINE def solve ( ) : NEW_LINE INDENT N , K = map ( int , readline ( ) . split ( ) ) NEW_LINE if N == K == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if N == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT if K == 2 : NEW_LINE INDENT return True NEW_LINE DEDENT if N == 3 : NEW_LINE INDENT return True NEW_LINE DEDENT if K == 4 : NEW_LINE INDENT return True NEW_LINE DEDENT if K == 5 : NEW_LINE INDENT return True NEW_LINE DEDENT if K == 6 : NEW_LINE INDENT return True NEW_LINE DEDENT if K == 7 : NEW_LINE INDENT return True NEW_LINE DEDENT if K == 8 : NEW_LINE INDENT return True NEW_LINE DEDENT if K == 9 : NEW_LINE INDENT return True NEW_LINE DEDENT if K == 10 : NEW_LINE INDENT return False NEW_LINE DEDENT if K == 9 : NEW_LINE INDENT return True NEW_LINE DEDENT if K == 9 : NEW_
MAX = 64 NEW_LINE def maxOR ( L , R ) : NEW_LINE INDENT if ( L == R ) : NEW_LINE INDENT return L NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( MAX - 1 , - 1 , - 1 ) : NEW_LINE INDENT p = 1 << i NEW_LINE lbit = ( L >> i ) & 1 NEW_LINE rbit = ( R >> i ) & 1 NEW_LINE if ( ( rbit == 1 ) and ( lbit == 0 ) ) : NEW_LINE INDENT ans += ( p << 1 ) - 1 NEW_LINE break NEW_LINE DEDENT if ( rbit == 1 ) : NEW_LINE INDENT ans += p NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT L = 4 NEW_LINE R = 5 NEW_LINE print ( maxOR ( L , R ) ) NEW_LINE DEDENT
import sys NEW_LINE from sys import stdin NEW_LINE input = stdin . readline NEW_LINE def main ( args ) : NEW_LINE INDENT while True : NEW_LINE INDENT data = input ( ) . strip ( ) NEW_LINE if data == ' # ' : NEW_LINE INDENT break NEW_LINE DEDENT data = data . split ( ' = ' ) NEW_LINE flag = True NEW_LINE for i in range ( len ( data ) ) : NEW_LINE INDENT if data [ i ] == ' T ' : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if data [ i ] == ' F ' : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
def findSplit ( arr , n ) : NEW_LINE INDENT preSum = 0 NEW_LINE ind1 = - 1 NEW_LINE ind2 = - 1 NEW_LINE S = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT S += arr [ i ] NEW_LINE DEDENT if ( S % 3 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT S1 = S // 3 NEW_LINE S2 = 2 * S1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT preSum += arr [ i ] NEW_LINE if ( preSum % S1 == 0 and ind1 == - 1 ) : NEW_LINE INDENT ind1 = i NEW_LINE DEDENT elif ( preSum % S2 == 0 ) : NEW_LINE INDENT ind2 = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( ind1 != - 1 and ind2 != - 1 ) : NEW_LINE INDENT print ( " ( " , ind1 , " , " , ind2 , " ) " ) NEW_LINE return 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _
def NoofTriplets ( N , K ) : NEW_LINE INDENT cnt = [ 0 for i in range ( K ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT cnt [ i % K ] += 1 NEW_LINE DEDENT if ( K & 1 ) : NEW_LINE INDENT return ( cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] + cnt [ K // 2 ] * cnt [ K // 2 ] * cnt [ K // 2 ] ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 3 NEW_LINE K = 2 NEW_LINE print ( NoofTriplets ( N , K ) ) NEW_LINE DEDENT
def printTwoSetBitNums ( n ) : NEW_LINE INDENT x = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT y = 0 NEW_LINE while ( y < x ) : NEW_LINE INDENT print ( ( ( 1 << x ) + ( 1 << y ) ) , end = " ▁ " ) NEW_LINE n -= 1 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT y += 1 NEW_LINE DEDENT x += 1 NEW_LINE DEDENT DEDENT n = 4 NEW_LINE printTwoSetBitNums ( n ) NEW_LINE
def KnapSack ( val , wt , n , W ) : NEW_LINE INDENT dp = [ 0 ] * ( W + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( W , - 1 , - 1 ) : NEW_LINE INDENT dp [ j ] = max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) NEW_LINE DEDENT DEDENT return dp [ W ] NEW_LINE DEDENT val = [ 7 , 8 , 4 ] NEW_LINE wt = [ 3 , 8 , 6 ] NEW_LINE W = 10 NEW_LINE n = 3 NEW_LINE print ( KnapSack ( val , wt , n , W ) ) NEW_LINE
import math NEW_LINE def twoEggDrop ( k ) : NEW_LINE INDENT return int ( math . ceil ( ( - 1.0 + math . sqrt ( 1 + 8 * k ) ) / 2.0 ) ) NEW_LINE DEDENT k = 100 NEW_LINE print ( twoEggDrop ( k ) ) NEW_LINE
import math NEW_LINE def nextPerfectSquare ( N ) : NEW_LINE INDENT nextN = math . floor ( math . sqrt ( N ) ) + 1 NEW_LINE return nextN * nextN NEW_LINE DEDENT n = 35 NEW_LINE print ( nextPerfectSquare ( n ) ) NEW_LINE
x , y = map ( int , input ( ) . split ( ) ) NEW_LINE print ( x // y , x % y , 5.8 ) NEW_LINE
eps = 1e-6 NEW_LINE def getArea ( base , hypotenuse ) : NEW_LINE INDENT height = sqrt ( hypotenuse * hypotenuse - base * base ) ; NEW_LINE return 0.5 * base * height ; NEW_LINE DEDENT def printRightAngleTriangle ( hypotenuse , area ) : NEW_LINE INDENT hsquare = hypotenuse * hypotenuse ; NEW_LINE sideForMaxArea = sqrt ( hsquare / 2.0 ) ; NEW_LINE maxArea = getArea ( sideForMaxArea , hypotenuse ) ; NEW_LINE if ( area > maxArea ) : NEW_LINE INDENT print ( " Not ▁ possible " ) ; NEW_LINE return ; NEW_LINE DEDENT low = 0.0 ; NEW_LINE high = sideForMaxArea ; NEW_LINE base = 0 ; NEW_LINE while ( abs ( high - low ) > eps ) : NEW_LINE INDENT base = ( low + high ) / 2.0 ; NEW_LINE if ( getArea ( base , hypotenuse ) >= area ) : NEW_LINE INDENT high = base ; NEW_LINE
n = 3 NEW_LINE MAX = 30 NEW_LINE dp = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE v = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE def findCount ( mat , i , j , m ) : NEW_LINE INDENT if ( i == 0 and j == 0 ) : NEW_LINE INDENT if ( m == mat [ 0 ] [ 0 ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( m < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i < 0 or j < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( v [ i ] [ j ] [ m ] ) : NEW_LINE INDENT return dp [ i ] [ j ] [ m ] NEW_LINE DEDENT v [ i ] [ j ] [ m ] = True NEW_LINE dp [ i ] [ j ] [ m ] = findCount ( mat , i - 1 , j , m - mat [ i ] [ j ] ) + find
while True : NEW_LINE INDENT a , b , p = map ( int , input ( ) . split ( ) ) NEW_LINE if a == b == p == 0 : NEW_LINE INDENT break NEW_LINE DEDENT dp = [ 0 ] * ( 10 ** 5 + 1 ) NEW_LINE dp [ 0 ] = 1 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT dp [ i ] = ( dp [ i - a ] + dp [ i - b ] ) % p NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT ans += dp [ i - a ] NEW_LINE DEDENT print ( ans % p ) NEW_LINE DEDENT
def findNormal ( A , x , y ) : NEW_LINE INDENT dif = A - x * 2 NEW_LINE if ( y == ( 2 * x - x * x ) ) : NEW_LINE INDENT if ( dif < 0 ) : NEW_LINE INDENT print ( ( 0 - dif ) , " y ▁ = ▁ " , " x " , ( 0 - x ) + ( y * dif ) ) NEW_LINE DEDENT elif ( dif > 0 ) : NEW_LINE INDENT print ( dif , " y ▁ = ▁ " , " - x , ( x + dif * y ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " x ▁ = " , x ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " Not ▁ possible " ) NEW_LINE DEDENT DEDENT A = 2 NEW_LINE x = 2 NEW_LINE y = 0 NEW_LINE findNormal ( A , x , y ) NEW_LINE
def pattern ( ) : NEW_LINE INDENT i , j , k , spaces , n = 0 , 0 , 1 , 7 NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT if ( i != n ) : NEW_LINE INDENT for k in range ( 1 , spaces + 1 ) : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT spaces = spaces + 2 NEW_LINE DEDENT for j in range ( i , 0 , - 1 ) : NEW_LINE INDENT if ( j != n ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT spaces = spaces - 4 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT if ( i !=
def answer ( n ) : NEW_LINE INDENT m = 2 NEW_LINE ans = 1 NEW_LINE r = 1 NEW_LINE while ( r < n ) : NEW_LINE INDENT r = ( pow ( 2 , m ) - 1 ) * ( pow ( 2 , m - 1 ) ) NEW_LINE if ( r < n ) : NEW_LINE INDENT ans = r NEW_LINE DEDENT m += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT n = 7 NEW_LINE print ( answer ( n ) ) NEW_LINE
def nPermute ( string , n ) : NEW_LINE INDENT string . sort ( ) NEW_LINE i = 1 NEW_LINE while ( i == n ) : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT while ( next_permutation ( string ) ) : NEW_LINE INDENT print ( string ) NEW_LINE DEDENT
h , w = map ( int , input ( ) . split ( ) ) NEW_LINE s = [ ] NEW_LINE for i in range ( h ) : NEW_LINE INDENT s . append ( input ( ) ) NEW_LINE DEDENT for i in range ( h ) : NEW_LINE INDENT if s [ i ] == ' # ' : NEW_LINE INDENT w += 1 NEW_LINE DEDENT DEDENT if w == h + w - 1 : NEW_LINE INDENT print ( ' Possible ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Impossible ' ) NEW_LINE DEDENT
def compute ( ) : NEW_LINE INDENT LENGTH = 50 NEW_LINE ways = [ 1 ] * ( LENGTH + 1 ) NEW_LINE ways [ 0 ] = 1 NEW_LINE for n in range ( 1 , LENGTH + 1 ) : NEW_LINE INDENT ways [ n ] += ways [ n - 1 ] NEW_LINE if n >= m : NEW_LINE INDENT ways [ n ] += ways [ n - m ] NEW_LINE DEDENT DEDENT return ways [ LENGTH ] - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
import sys NEW_LINE def check ( arr , n ) : NEW_LINE INDENT k = - sys . maxsize ; NEW_LINE r = sys . maxsize ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT k = max ( k , arr [ i ] ) ; NEW_LINE r = min ( r , arr [ i ] ) ; NEW_LINE DEDENT k += 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] = k - arr [ i ] ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( abs ( arr [ i ] ) - 1 < n and arr [ abs ( arr [ i ] ) - 1 ] > 0 ) : NEW_LINE INDENT arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ] ; NEW_LINE DEDENT DEDENT flag = 0 ; NEW_LINE for i in range ( k - r - 1 ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT flag = 1 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT return flag ; NEW_
def power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( y % 2 == 0 ) : NEW_LINE INDENT return power ( x , y // 2 ) * power ( x , y // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return x * power ( x , y // 2 ) * power ( x , y // 2 ) NEW_LINE DEDENT DEDENT def sieveOfEratosthenes ( n , isPrime ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( isPrime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def leftTruPrime ( n ) : NEW_LINE INDENT temp = n NEW_LINE cnt = 0 NEW_LINE temp1 = temp % 10 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT cnt += 1 NEW
def minReplacement ( s , length ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( length ) : NEW_LINE INDENT if ( i % 2 == 0 and s [ i ] == '1' ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT if ( i % 2 == 1 and s [ i ] == '0' ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return min ( ans , length - ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = "1100" NEW_LINE length = len ( s ) NEW_LINE print ( minReplacement ( s , length ) ) NEW_LINE DEDENT
def right_left ( a , n ) : NEW_LINE INDENT total = dict ( ) NEW_LINE left = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT total [ a [ i ] ] = total [ a [ i ] ] + 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( ( total [ a [ i ] ] - 1 - 2 * left [ a [ i ] ] ) , end = " ▁ " ) NEW_LINE left [ a [ i ] ] = left [ a [ i ] ] + 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 2 , 3 , 2 , 1 ] NEW_LINE n = len ( a ) NEW_LINE right_left ( a , n ) NEW_LINE DEDENT
N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if A [ j ] < A [ j - 1 ] : NEW_LINE INDENT A [ j - 1 ] , A [ j ] = A [ j - 1 ] , A [ j ] NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( * A ) NEW_LINE
def countPattern ( n , pat ) : NEW_LINE INDENT pattern_int = 0 NEW_LINE power_two = 1 NEW_LINE all_ones = 0 NEW_LINE for i in range ( len ( pat ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT current_bit = ord ( pat [ i ] ) - ord ( '0' ) NEW_LINE pattern_int += ( power_two * current_bit ) NEW_LINE all_ones = all_ones + power_two NEW_LINE power_two = power_two * 2 NEW_LINE DEDENT count = 0 NEW_LINE while ( n != 0 and n >= pattern_int ) : NEW_LINE INDENT if ( ( n & all_ones ) == pattern_int ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT n = n >> 1 NEW_LINE DEDENT return count NEW_LINE DEDENT n = 500 NEW_LINE pat = "10" NEW_LINE print ( countPattern ( n , pat ) ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = [ 0 ] * n NEW_LINE for i in a : NEW_LINE INDENT c [ i - 1 ] += 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if c [ i ] > 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT
import math NEW_LINE def findNumber ( n ) : NEW_LINE INDENT num = n - 1 NEW_LINE num = 2 * pow ( 4 , num ) NEW_LINE num = int ( math . floor ( num / 3.0 ) ) NEW_LINE return num NEW_LINE DEDENT n = 5 NEW_LINE print ( findNumber ( n ) ) NEW_LINE
def multiply ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( y > 0 ) : NEW_LINE INDENT return ( x + multiply ( x , y - 1 ) ) NEW_LINE DEDENT if ( y < 0 ) : NEW_LINE INDENT return - multiply ( x , - y ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT print ( multiply ( 5 , - 11 ) ) NEW_LINE
sz = 1e3 NEW_LINE fib = set ( ) NEW_LINE def fibonacci ( ) : NEW_LINE INDENT prev = 0 NEW_LINE curr = 1 NEW_LINE len = 2 NEW_LINE fib . add ( prev ) NEW_LINE fib . add ( curr ) NEW_LINE while ( len <= sz ) : NEW_LINE INDENT temp = curr + prev NEW_LINE fib . add ( temp ) NEW_LINE prev = curr NEW_LINE curr = temp NEW_LINE len += 1 NEW_LINE DEDENT DEDENT def printArray ( arr , len ) : NEW_LINE INDENT for i in range ( len ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT def removeFibonacci ( arr , len ) : NEW_LINE INDENT fibonacci ( ) NEW_LINE for i in range ( len ) : NEW_LINE INDENT if ( arr [ i ] in fib ) : NEW_LINE INDENT for j in range ( i , len - 1 ) : NEW_LINE INDENT arr [ j ] = arr [ j + 1 ] NEW_LINE DEDENT i
import math NEW_LINE def minAbsDiff ( n ) : NEW_LINE INDENT left = 1 << ( math . floor ( math . log ( n , 2 ) ) ) NEW_LINE right = left * 2 NEW_LINE return min ( ( n - left ) , ( right - n ) ) NEW_LINE DEDENT n = 15 NEW_LINE print ( minAbsDiff ( n ) ) NEW_LINE
def bitonicGenerator ( arr , n ) : NEW_LINE INDENT i = 1 NEW_LINE j = n - 1 NEW_LINE if ( j % 2 != 0 ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT while ( i < j ) : NEW_LINE INDENT arr = arr [ i : j ] NEW_LINE i += 2 NEW_LINE j -= 2 NEW_LINE DEDENT arr . sort ( ) NEW_LINE arr . sort ( ) NEW_LINE low = ( n + 1 ) // 2 NEW_LINE high = n - 1 NEW_LINE while ( low < high ) : NEW_LINE INDENT temp = arr [ low ] NEW_LINE arr [ low ] , arr [ high ] = arr [ high ] , arr [ low ] NEW_LINE low += 1 NEW_LINE high -= 1 NEW_LINE DEDENT return arr NEW_LINE DEDENT arr = [ 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE bitonicGenerator ( arr , n ) NEW_LINE print ( arr ) NEW_LINE
n = 5 NEW_LINE def printSumSimple ( mat , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( 0 , n - k + 1 ) : NEW_LINE INDENT for j in range ( 0 , n - k + 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE for p in range ( i , k + i ) : NEW_LINE INDENT for q in range ( j , k + j ) : NEW_LINE INDENT sum += mat [ p ] [ q ] NEW_LINE DEDENT DEDENT print ( sum , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT mat = [ [ 1 , 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 , 4 ] , [ 5 , 5 , 5 , 5 ] ] NEW_LINE k = 3 NEW_LINE printSumSimple ( mat , k ) NEW_LINE
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( a + b - 1 ) NEW_LINE for i in range ( 1 , b + 1 ) : NEW_LINE INDENT print ( i , i + 1 ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT s = " " NEW_LINE while n != 0 : NEW_LINE INDENT if n % 16 == 0 : NEW_LINE INDENT s += "0" NEW_LINE n //= 16 NEW_LINE DEDENT elif n % 16 == 1 : NEW_LINE INDENT s += "1" NEW_LINE n //= 16 NEW_LINE DEDENT elif n % 16 == 2 : NEW_LINE INDENT s += "2" NEW_LINE n //= 16 NEW_LINE DEDENT elif n % 16 == 3 : NEW_LINE INDENT s += "3" NEW_LINE n //= 16 NEW_LINE DEDENT elif n % 16 == 4 : NEW_LINE INDENT s += "4" NEW_LINE n //= 16 NEW_LINE DEDENT elif n % 16 == 5 : NEW_LINE INDENT s += "5" NEW_LINE n //= 16 NEW_LINE DEDENT elif n % 16 == 7 : NEW_LINE INDENT s += "8" NEW_LINE n //= 16 NEW_LINE DEDENT elif n % 16 == 8 :
def numOfWhiteHats ( arr , n ) : NEW_LINE INDENT freq = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] >= n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT diffFreq = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( freq [ i ] > 0 ) : NEW_LINE INDENT diffFreq += 1 NEW_LINE DEDENT DEDENT if ( diffFreq == 1 and freq [ n - 1 ] == n ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( diffFreq != 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT k = n - 1 NEW_LINE while ( k >= 1 ) : NEW_LINE INDENT if ( freq [ k ] > 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( freq [ k - 1 ] == k and freq [ k ] + k == n ) : NEW_LINE INDENT return freq [ k - 1 ] NEW_LINE
def canBeBalanced ( s , n ) : NEW_LINE INDENT count = 0 NEW_LINE count_1 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT count_1 = min ( count_1 , count ) NEW_LINE DEDENT if ( count_1 >= - 1 and count == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " ( ) ) ( ) ( " NEW_LINE n = len ( s ) NEW_LINE if ( canBeBalanced ( s , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def solve ( ) : NEW_LINE INDENT L , R = map ( int , input ( ) . split ( ) ) NEW_LINE ans = float ( ' inf ' ) NEW_LINE for i in range ( 1 , L + 1 ) : NEW_LINE INDENT for j in range ( 1 , R + 1 ) : NEW_LINE INDENT if i & ( 1 << j ) : NEW_LINE INDENT ans = min ( ans , arr [ i - 1 ] [ j ] - arr [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
def minInt ( str ) : NEW_LINE INDENT s = " " NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] >= '5' ) : NEW_LINE INDENT s += chr ( ( 9 - ord ( str [ i ] ) ) + 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT s += str [ i ] NEW_LINE DEDENT DEDENT if ( str [ 0 ] == '0' ) : NEW_LINE INDENT s += '9' NEW_LINE DEDENT return s NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = "589" NEW_LINE print ( minInt ( str ) ) NEW_LINE DEDENT
MAX = 100001 ; NEW_LINE prefix = [ 0 ] * MAX ; NEW_LINE def sieve_modified ( ) : NEW_LINE INDENT for i in range ( 1 , MAX , 2 ) : NEW_LINE INDENT for j in range ( i , MAX , i ) : NEW_LINE INDENT prefix [ j ] += i ; NEW_LINE DEDENT DEDENT for i in range ( 1 , MAX , 1 ) : NEW_LINE INDENT prefix [ i ] += prefix [ i - 1 ] ; NEW_LINE DEDENT DEDENT def sumOddFactors ( L , R ) : NEW_LINE INDENT return ( prefix [ R ] - prefix [ L - 1 ] ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sieve_modified ( ) ; NEW_LINE l = 6 ; r = 10 ; NEW_LINE print ( sumOddFactors ( l , r ) ) ; NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n % 4 == 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
h , l = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( l ** 2 - h ** 2 ) / ( 2 * h ) ) NEW_LINE
import math NEW_LINE def findDigits ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT digits = 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT digits += math . log10 ( i ) NEW_LINE DEDENT return int ( math . floor ( digits ) + 1 ) NEW_LINE DEDENT print ( findDigits ( 1 ) ) NEW_LINE print ( findDigits ( 5 ) ) NEW_LINE print ( findDigits ( 10 ) ) NEW_LINE print ( findDigits ( 120 ) ) NEW_LINE
import math NEW_LINE def largestCube ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = ( 2 * r ) / math . sqrt ( 3 ) NEW_LINE return a NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT r = 5 NEW_LINE print ( largestCube ( r ) ) NEW_LINE DEDENT
def numberOfPaths ( m , n ) : NEW_LINE INDENT path = 1 NEW_LINE for i in range ( n , ( m + n - 1 ) ) : NEW_LINE INDENT path *= i NEW_LINE path /= ( i - n + 1 ) NEW_LINE DEDENT return path NEW_LINE DEDENT print ( numberOfPaths ( 3 , 3 ) ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = list ( input ( ) ) NEW_LINE l , r = 0 , n - 1 NEW_LINE ans = s [ 0 ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT c = input ( ) NEW_LINE if c == " R + + " : NEW_LINE INDENT r += 1 NEW_LINE ans -= s [ r ] NEW_LINE l += 1 NEW_LINE DEDENT elif c == " R - - " : NEW_LINE INDENT r -= 1 NEW_LINE ans += s [ r ] NEW_LINE l -= 1 NEW_LINE DEDENT elif c == " L + + " : NEW_LINE INDENT r += 1 NEW_LINE ans -= s [ l ] NEW_LINE l += 1 NEW_LINE DEDENT elif c == " R - + " : NEW_LINE INDENT r -= 1 NEW_LINE ans -= s [ l ] NEW_LINE l -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans -= s [ r ] NEW_LINE r += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
class Node : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . data = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def maxOfRightElement ( root ) : NEW_LINE INDENT res = - 1 NEW_LINE if ( root == None ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( root . right != None ) : NEW_LINE INDENT res = root . right . data NEW_LINE DEDENT return max ( maxOfRightElement ( root . right ) , max ( res , maxOfRightElement ( root . left ) ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT root = Node ( 7 ) NEW_LINE root . left = Node ( 6 ) NEW_LINE root . right = Node ( 5 ) NEW_LINE root . left . left = Node ( 4 ) NEW_LINE root . left . right = Node ( 3 ) NEW_LINE root . right . left = Node ( 2 ) NEW_LINE root . right . right = Node ( 1 ) NEW_LINE print ( maxOfRightElement ( root
def removeElements ( arr , n ) : NEW_LINE INDENT brr = [ 0 for i in range ( n ) ] NEW_LINE l = 1 NEW_LINE brr [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( brr [ l - 1 ] <= arr [ i ] ) : NEW_LINE INDENT brr [ l ] = arr [ i ] NEW_LINE l += 1 NEW_LINE DEDENT DEDENT for i in range ( l ) : NEW_LINE INDENT print ( brr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 10 , 12 , 9 , 10 , 2 , 13 , 14 ] NEW_LINE n = len ( arr ) NEW_LINE removeElements ( arr , n ) NEW_LINE DEDENT
class Node : NEW_LINE INDENT def __init__ ( self , elementID , stepsToeliminate ) : NEW_LINE INDENT self . elementID = elementID NEW_LINE self . stepsToeliminate = stepsToeliminate NEW_LINE DEDENT DEDENT def minSteps ( arr , N ) : NEW_LINE INDENT s = [ Node ( 0 , - 1 ) ] NEW_LINE s . append ( Node ( 0 , - 1 ) ) NEW_LINE maxStepsToeliminate = - 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT stepsToeliminate = 1 NEW_LINE while ( len ( s ) > 0 ) : NEW_LINE INDENT if ( arr [ s [ - 1 ] . elementID ] >= arr [ i ] ) : NEW_LINE INDENT stepsToeliminate = max ( stepsToeliminate , s [ - 1 ] . stepsToeliminate + 1 ) NEW_LINE s . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( len ( s ) == 0 ) : NEW_LINE INDENT stepsToeliminate = - 1 NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( input ( ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT b . append ( input ( ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if len ( b [ i ] ) <= len ( a [ i ] ) : NEW_LINE INDENT print ( b [ i ] [ 0 ] , end = ' ▁ ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a [ i ] [ 1 ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT
def check ( H , S ) : NEW_LINE INDENT return H * H >= 4 * S NEW_LINE DEDENT def findPairs ( H , n , S , m ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( check ( H [ i ] , S [ j ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT H = [ 1 , 6 , 4 ] NEW_LINE n = len ( H ) NEW_LINE S = [ 23 , 3 , 42 , 14 ] NEW_LINE m = len ( S ) NEW_LINE print ( findPairs ( H , n , S , m ) ) NEW_LINE
import sys NEW_LINE def Print3Smallest ( array , n ) : NEW_LINE INDENT firstmin = sys . maxsize NEW_LINE secmin = sys . maxsize NEW_LINE thirdmin = sys . maxsize NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( array [ i ] < firstmin ) : NEW_LINE INDENT thirdmin = secmin NEW_LINE secmin = firstmin NEW_LINE firstmin = array [ i ] NEW_LINE DEDENT elif ( array [ i ] < secmin ) : NEW_LINE INDENT thirdmin = secmin NEW_LINE secmin = array [ i ] NEW_LINE DEDENT elif ( array [ i ] < thirdmin ) : NEW_LINE INDENT thirdmin = array [ i ] NEW_LINE DEDENT DEDENT print ( " First ▁ min ▁ = " , firstmin ) NEW_LINE print ( " Second ▁ min ▁ = " , secmin ) NEW_LINE print ( " Third ▁ min ▁ = " , thirdmin ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT
s = input ( ) NEW_LINE d = { ' ! ' : 0 , ' R ' : 0 , ' B ' : 0 , ' Y ' : 0 , ' G ' : 0 , ' B ' : 0 , ' Y ' : 0 , ' G ' : 0 , ' R ' : 0 , ' B ' : 0 , ' Y ' : 0 , ' G ' : 0 } NEW_LINE ans = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] in d : NEW_LINE INDENT d [ s [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ s [ i ] ] = 1 NEW_LINE DEDENT DEDENT for i in d : NEW_LINE INDENT ans . append ( d [ i ] ) NEW_LINE DEDENT print ( ' ▁ ' . join ( ans ) ) NEW_LINE
def dayofweek ( d , m , y ) : NEW_LINE INDENT t = [ 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 ] NEW_LINE y -= 1 NEW_LINE if ( m < 3 ) : NEW_LINE INDENT y -= 1 NEW_LINE DEDENT return ( y + y // 4 - y // 100 + y // 400 + t [ m - 1 ] + d ) % 7 NEW_LINE DEDENT day = dayofweek ( 30 , 8 , 2010 ) NEW_LINE print ( day ) NEW_LINE
def powerNumbers ( n ) : NEW_LINE INDENT v = set ( ) NEW_LINE v . add ( 1 ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT j = i * i NEW_LINE v . add ( j ) NEW_LINE while ( j * i <= n ) : NEW_LINE INDENT v . add ( j * i ) NEW_LINE j = j * i NEW_LINE DEDENT DEDENT return len ( v ) NEW_LINE DEDENT print ( powerNumbers ( 50 ) ) NEW_LINE
def productDivisible ( n , k ) : NEW_LINE INDENT product = 1 NEW_LINE position = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( position % 2 == 0 ) : NEW_LINE INDENT product *= n % 10 NEW_LINE DEDENT n = int ( n / 10 ) NEW_LINE position += 1 NEW_LINE DEDENT if ( product % k == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 321922 NEW_LINE k = 3 NEW_LINE if ( productDivisible ( n , k ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def isDivisibleBy10 ( bin , n ) : NEW_LINE INDENT if ( bin [ n - 1 ] == '1' ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( bin [ i ] == '1' ) : NEW_LINE INDENT posFromRight = n - i - 1 NEW_LINE if ( posFromRight % 4 == 1 ) : NEW_LINE INDENT sum = sum + 2 NEW_LINE DEDENT elif ( posFromRight % 4 == 2 ) : NEW_LINE INDENT sum = sum + 4 NEW_LINE DEDENT elif ( posFromRight % 4 == 3 ) : NEW_LINE INDENT sum = sum + 8 NEW_LINE DEDENT elif ( posFromRight % 4 == 0 ) : NEW_LINE INDENT sum = sum + 6 NEW_LINE DEDENT DEDENT DEDENT if ( sum % 10 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT bin = "101000" NEW_LINE n = len ( bin ) NEW_LINE if ( isDivisibleBy20 ( bin ,
def halfsquare ( n , x , y ) : NEW_LINE INDENT half = n // 2 NEW_LINE if ( ( half == x or half == x - 1 ) and ( half == y or half == y - 1 ) ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT n = 100 NEW_LINE x = 51 NEW_LINE y = 100 NEW_LINE halfsquare ( n , x , y ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT while ( a != 0 ) : NEW_LINE INDENT c = a NEW_LINE a = b % a NEW_LINE b = c NEW_LINE DEDENT return b NEW_LINE DEDENT def forbenius ( X , Y ) : NEW_LINE INDENT if ( gcd ( X , Y ) != 1 ) : NEW_LINE INDENT print ( " NA " ) NEW_LINE return NEW_LINE DEDENT A = ( X * Y ) - ( X + Y ) NEW_LINE N = ( ( X - 1 ) * ( Y - 1 ) // 2 ) NEW_LINE print ( " Largest ▁ Amount ▁ = " , A ) NEW_LINE print ( " Total ▁ Count ▁ = " , N ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT X = 2 NEW_LINE Y = 5 NEW_LINE forbenius ( X , Y ) NEW_LINE X = 5 NEW_LINE Y = 10 NEW_LINE print ( ) NEW_LINE forbenius ( X , Y ) NEW_LINE DEDENT
def reverse ( a ) : NEW_LINE INDENT n = len ( a ) NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT t = a [ i ] NEW_LINE a [ i ] = a [ n - i - 1 ] NEW_LINE a [ n - i - 1 ] = t NEW_LINE DEDENT DEDENT arr = [ 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE arr . sort ( reverse = True ) NEW_LINE print ( " Array ▁ after ▁ sorting ▁ : ▁ " , end = " " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT
def bestApproximate ( x , y ) : NEW_LINE INDENT n = len ( x ) NEW_LINE m = 0 NEW_LINE sum_x = 0 NEW_LINE sum_y = 0 NEW_LINE sum_xy = 0 NEW_LINE sum_x2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum_x += x [ i ] NEW_LINE sum_y += y [ i ] NEW_LINE sum_xy += x [ i ] * y [ i ] NEW_LINE sum_x2 += pow ( x [ i ] , 2 ) NEW_LINE DEDENT m = ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - pow ( sum_x , 2 ) ) NEW_LINE c = ( sum_y - m * sum_x ) / n NEW_LINE print ( " m ▁ = " , m ) NEW_LINE print ( " c ▁ = " , c ) NEW_LINE DEDENT x = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE y = [ 14 , 27 , 40 , 55 , 68 ] NEW_LINE best
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( ) NEW_LINE new_node . data = new_data NEW_LINE new_node . next = head_ref NEW_LINE ( head_ref ) = new_node NEW_LINE head = head_ref NEW_LINE DEDENT def productOfLastN_NodesUtil ( head , n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT st = [ ] NEW_LINE prod = 1 NEW_LINE while ( head != None ) : NEW_LINE INDENT st . append ( head . data ) NEW_LINE head = head . next NEW_LINE DEDENT while ( n ) : NEW_LINE INDENT prod *= st . pop ( ) NEW_LINE st . pop ( ) NEW_LINE DEDENT return prod NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT head = None NEW_LINE push
def modExp ( a , b ) : NEW_LINE INDENT result = 1 NEW_LINE while ( b ) : NEW_LINE INDENT if ( b == 1 ) : NEW_LINE INDENT result = result * a NEW_LINE DEDENT a = a * a NEW_LINE b //= 2 NEW_LINE DEDENT return result NEW_LINE DEDENT def check ( num ) : NEW_LINE INDENT if ( num == 1 or num < 3 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT elif ( num % 4 == 0 ) : NEW_LINE INDENT return modExp ( num // 4 , 4 ) NEW_LINE DEDENT elif ( num % 6 == 0 ) : NEW_LINE INDENT return modExp ( num // 3 , 2 ) * modExp ( num // 6 , 2 ) NEW_LINE DEDENT elif ( num % 10 == 0 ) : NEW_LINE INDENT return modExp ( num // 5 , 2 ) * ( num // 10 ) * ( num // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT num = 10 NEW_LINE print ( check ( num ) ) NEW_LINE
import sys NEW_LINE def findMaxDiff ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT print ( " Invalid ▁ " ) NEW_LINE return 0 NEW_LINE DEDENT res = - sys . maxsize NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( res < ( arr [ i ] - arr [ j ] - i + j ) ) : NEW_LINE INDENT res = ( arr [ i ] - arr [ j ] - i + j ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 9 , 15 , 4 , 12 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxDiff ( arr , n ) ) NEW_LINE DEDENT
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( " Enter ▁ lower ▁ bound ▁ of ▁ the ▁ interval : ▁ " , a , b ) NEW_LINE print ( " Prime ▁ numbers ▁ between ▁ 2 ▁ and ▁ 2 ▁ are : ▁ " , a , b ) NEW_LINE
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( " Enter ▁ lower ▁ bound ▁ of ▁ the ▁ interval : " , a , b ) NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT DEDENT
MAX = 100 NEW_LINE def smallestInRow ( mat , n , m ) : NEW_LINE INDENT print ( " { ▁ " , end = " " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT minm = mat [ i ] [ 0 ] NEW_LINE for j in range ( 1 , m ) : NEW_LINE INDENT if ( mat [ i ] [ j ] < minm ) : NEW_LINE INDENT minm = mat [ i ] [ j ] NEW_LINE DEDENT DEDENT print ( minm , " , ▁ " , end = " " ) NEW_LINE DEDENT print ( " } " , end = " " ) NEW_LINE DEDENT def smallestInCol ( mat , n , m ) : NEW_LINE INDENT print ( " { ▁ " , end = " " ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT minm = mat [ 0 ] [ i ] NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ j ] [ i ] < minm ) : NEW_LINE INDENT minm = mat [ j ] [ i ]
def minAbsDiff ( n ) : NEW_LINE INDENT mod = n % 4 NEW_LINE if ( mod == 0 or mod == 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 1 NEW_LINE DEDENT n = 5 NEW_LINE print ( minAbsDiff ( n ) ) NEW_LINE
while True : NEW_LINE INDENT n , k , s = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += solve ( n - 1 , k - 1 , s - i ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def countP ( n , k ) : NEW_LINE INDENT if ( n == 0 or k == 0 or k > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( k == 1 or k == n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( k * countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) ) NEW_LINE DEDENT print ( countP ( 3 , 2 ) ) NEW_LINE
a , b , c = map ( str , input ( ) . split ( ) ) NEW_LINE if a == b and b == c and c == a : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def calculate ( N ) : NEW_LINE INDENT len1 = len ( N ) NEW_LINE l = ( len1 / 2 ) NEW_LINE count = 0 NEW_LINE for i in range ( 1 , l + 1 ) : NEW_LINE INDENT s = N [ 0 : i ] NEW_LINE l1 = len ( s ) NEW_LINE t = N [ i : l1 + i ] NEW_LINE if ( s [ 0 ] == '0' or t [ 0 ] == '0' ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( s == t ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = "2202200" NEW_LINE print ( calculate ( N ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE N , Q = map ( int , input ( ) . split ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE A = sorted ( A ) NEW_LINE for _ in range ( Q ) : NEW_LINE INDENT q = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT ans = max ( ans , A [ i ] % q ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def printIndices ( n , a ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] . second , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def printPermutations ( n , a , k ) : NEW_LINE INDENT arr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr . append ( [ ] ) NEW_LINE arr [ i ] . append ( a [ i ] ) NEW_LINE DEDENT arr . sort ( ) NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] [ 0 ] == arr [ i - 1 ] [ 0 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count < k ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT for i in range ( k - 1 ) : NEW_LINE INDENT printIndices ( n , arr ) NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ j ] [ 0
from math import sqrt NEW_LINE def countNumbers ( n ) : NEW_LINE INDENT c = 0 NEW_LINE limit = int ( sqrt ( n ) ) NEW_LINE prime = [ i for i in range ( limit + 1 ) ] NEW_LINE for i in range ( 1 , limit + 1 ) : NEW_LINE INDENT prime [ i ] = i NEW_LINE DEDENT for i in range ( 2 , int ( sqrt ( limit ) ) + 1 ) : NEW_LINE INDENT if ( prime [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , limit + 1 , i ) : NEW_LINE INDENT if ( prime [ j ] == j ) : NEW_LINE INDENT prime [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( 2 , limit + 1 ) : NEW_LINE INDENT p = prime [ i ] NEW_LINE q = prime [ i // prime [ i ] ] NEW_LINE if ( p * q == i and q != 1 and p != q ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif ( prime [ i ] == i ) : NEW_LINE INDENT if ( pow ( i
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE print ( n // k - n % k ) NEW_LINE DEDENT
n , q = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( q ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if a [ i ] == b [ j ] : NEW_LINE INDENT c [ j ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT c [ a [ i ] - 1 ] += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( c [ i ] ) NEW_LINE DEDENT
def smallestPoss ( s , n ) : NEW_LINE INDENT ans = " " NEW_LINE arr = [ 0 for i in range ( 10 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ ord ( s [ i ] ) - 48 ] += 1 NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT for j in range ( arr [ i ] ) : NEW_LINE INDENT ans = ans + str ( i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 15 NEW_LINE K = "325343273113434" NEW_LINE print ( smallestPoss ( K , N ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE def solve ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT for j in range ( 1 , 10 ) : NEW_LINE INDENT for k in range ( 1 , 10 ) : NEW_LINE INDENT if i == 0 and j == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if i * 10 + j <= n : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT if i * 10 + k <= n : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT
s = input ( ) NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 26 ) : NEW_LINE INDENT if s [ i ] != s [ n - i - 1 ] : NEW_LINE INDENT print ( s [ 0 : i ] + s [ i + 1 : ] ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT DEDENT print ( " NA " ) NEW_LINE
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT PRIME_LIMIT = 1000000 NEW_LINE THRESHOLD = 10000000000 NEW_LINE primes = eulerlib . list_primes ( PRIME_LIMIT ) NEW_LINE for n in range ( 5 , len ( primes ) + 1 , 2 ) : NEW_LINE INDENT rem = n * primes [ n - 1 ] * 2 NEW_LINE if rem > THRESHOLD : NEW_LINE INDENT return str ( n ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
s = input ( ) NEW_LINE a = s . count ( ' + ' ) NEW_LINE b = s . count ( ' - ' ) NEW_LINE if a % b == 0 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ i ] = b [ i ] - 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if b [ i ] % b [ j ] == 0 : NEW_LINE INDENT print ( " NO " ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT
INT_SIZE = 32 NEW_LINE class TrieNode : NEW_LINE INDENT def __init__ ( self , value ) : NEW_LINE INDENT self . value = value NEW_LINE self . arr = [ None ] * 2 NEW_LINE DEDENT DEDENT def insert ( pre_xor ) : NEW_LINE INDENT temp = root NEW_LINE for i in range ( INT_SIZE - 1 , - 1 , - 1 ) : NEW_LINE INDENT val = ( pre_xor & ( 1 << i ) ) >= 1 NEW_LINE if ( temp . arr [ val ] == None ) : NEW_LINE INDENT temp . arr [ val ] = TrieNode ( ) NEW_LINE DEDENT temp = temp . arr [ val ] NEW_LINE DEDENT temp . value = pre_xor NEW_LINE DEDENT def query ( pre_xor ) : NEW_LINE INDENT temp = root NEW_LINE for i in range ( INT_SIZE - 1 , - 1 , - 1 ) : NEW_LINE INDENT val = ( pre_xor & ( 1 << i ) ) >= 1 NEW_LINE if ( temp . arr [ 1 - val ] != None ) : NEW_LINE INDENT temp = temp . arr [ 1 - val
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif n == 2 : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT elif n == 3 : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 4 ) NEW_LINE DEDENT
def sumSubarrayMins ( A , n ) : NEW_LINE INDENT left = [ 0 for i in range ( n ) ] NEW_LINE right = [ 0 for i in range ( n ) ] NEW_LINE s1 = [ ] NEW_LINE s2 = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt = 1 NEW_LINE while ( len ( s1 ) > 0 and s1 [ - 1 ] [ 0 ] > A [ i ] ) : NEW_LINE INDENT cnt += s1 [ - 1 ] [ 1 ] NEW_LINE s1 . pop ( ) NEW_LINE DEDENT s1 . append ( ( A [ i ] , cnt ) ) NEW_LINE left [ i ] = cnt NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT cnt = 1 NEW_LINE while ( len ( s2 ) > 0 and s2 [ - 1 ] [ 0 ] >= A [ i ] ) : NEW_LINE INDENT cnt += s2 [ - 1 ] [ 1 ] NEW_LINE s2 . pop ( ) NEW_LINE DEDENT s2 . append ( ( A [ i ]
def isValid ( n , d ) : NEW_LINE INDENT digit = n % 10 NEW_LINE sum = digit NEW_LINE if ( digit == d ) : NEW_LINE INDENT return False NEW_LINE DEDENT n //= 10 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = n % 10 NEW_LINE if ( digit == d or digit <= sum ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT sum += digit NEW_LINE n //= 10 NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def printGoodNumber ( L , R , d ) : NEW_LINE INDENT for i in range ( L , R + 1 ) : NEW_LINE INDENT if ( isValid ( i , d ) ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT L = 410 NEW_LINE R = 520 NEW_LINE d = 3 NEW_LINE printGoodNumber ( L , R , d ) NEW_LINE
n = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n + 1 , 2 ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def nthprimedigitsnumber ( n ) : NEW_LINE INDENT len = 1 NEW_LINE prev_count = 0 NEW_LINE while True : NEW_LINE INDENT curr_count = ( prev_count + pow ( 4 , len ) ) NEW_LINE if prev_count < n and curr_count >= n : NEW_LINE INDENT break NEW_LINE DEDENT len += 1 NEW_LINE prev_count = curr_count NEW_LINE DEDENT for i in range ( 1 , len + 1 ) : NEW_LINE INDENT for j in range ( 1 , 4 ) : NEW_LINE INDENT if prev_count + pow ( 4 , len - i ) < n : NEW_LINE INDENT prev_count += pow ( 4 , len - i ) NEW_LINE DEDENT else : NEW_LINE INDENT if j == 1 : NEW_LINE INDENT print ( "2" , end = " " ) NEW_LINE DEDENT elif j == 2 : NEW_LINE INDENT print ( "3" , end = " " ) NEW_LINE DEDENT elif j == 3 : NEW_LINE INDENT print ( "5" , end = " " ) NEW_LINE DEDENT elif j == 4 : NEW_LINE INDENT print
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT s = input ( ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE c = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] not in a : NEW_LINE INDENT a . append ( s [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT b . append ( s [ i ] ) NEW_LINE DEDENT DEDENT c . append ( [ ] ) NEW_LINE for i in range ( len ( b ) ) : NEW_LINE INDENT if b [ i ] not in c : NEW_LINE INDENT c . append ( b [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT c . append ( b [ i ] ) NEW_LINE DEDENT DEDENT if len ( c ) == 3 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( min ( len ( c ) - len ( b ) , len ( c ) - len ( a ) ) ) NEW_LINE DEDENT DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( i + 1 ) NEW_LINE DEDENT b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT b . append ( i + 1 ) NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT b . append ( i + 1 ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( b [ i ] , end = " ▁ " ) NEW_LINE DEDENT
def maxAND ( L , R ) : NEW_LINE INDENT maximum = L & R NEW_LINE for i in range ( L , R ) : NEW_LINE INDENT for j in range ( i + 1 , R + 1 ) : NEW_LINE INDENT maximum = max ( maximum , ( i & j ) ) NEW_LINE DEDENT DEDENT return maximum NEW_LINE DEDENT L = 1 NEW_LINE R = 632 NEW_LINE print ( maxAND ( L , R ) ) NEW_LINE
def Minimum_Operations ( a , n ) : NEW_LINE INDENT np = [ 0 for i in range ( n + 1 ) ] NEW_LINE np [ n ] = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT np [ i ] = np [ i + 1 ] NEW_LINE if ( a [ i ] <= 0 ) : NEW_LINE INDENT np [ i ] += 1 NEW_LINE DEDENT DEDENT pos = 0 NEW_LINE ans = n NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] >= 0 ) : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT ans = min ( ans , pos + np [ i + 1 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ - 1 , 0 , 1 , 2 ] NEW_LINE n = len ( a ) NEW_LINE print ( Minimum_Operations ( a , n ) ) NEW_LINE DEDENT
a , b , k = map ( int , input ( ) . split ( ) ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT if a + i <= b : NEW_LINE INDENT print ( a + i ) NEW_LINE DEDENT DEDENT for i in range ( k - 1 , - 1 , - 1 ) : NEW_LINE INDENT if b - i > a + k - 1 : NEW_LINE INDENT print ( b - i ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT c = 0 NEW_LINE for k in range ( n ) : NEW_LINE INDENT c += a [ i ] [ k ] NEW_LINE c += a [ k ] [ j ] NEW_LINE if c < ans : NEW_LINE INDENT ans = c NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
def toNegativeBase ( n , negBase ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return "0" NEW_LINE DEDENT converted = " " NEW_LINE while ( n != 0 ) : NEW_LINE INDENT remainder = n % negBase NEW_LINE n //= negBase NEW_LINE if ( remainder < 0 ) : NEW_LINE INDENT remainder += ( - negBase ) NEW_LINE n += 1 NEW_LINE DEDENT converted = str ( remainder ) + converted NEW_LINE DEDENT return converted NEW_LINE DEDENT n = 13 NEW_LINE negBase = - 2 NEW_LINE print ( toNegativeBase ( n , negBase ) ) NEW_LINE
a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( len ( a ) - 1 ) : NEW_LINE INDENT ans += a [ i + 1 ] - a [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE
def RSF ( n ) : NEW_LINE INDENT while ( n >= 10 ) : NEW_LINE INDENT x = n NEW_LINE l = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = n // 10 NEW_LINE l += 1 NEW_LINE DEDENT a = [ 0 ] * l NEW_LINE i = l - 1 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT a [ i ] = x % 10 NEW_LINE x = x // 10 NEW_LINE i -= 1 NEW_LINE DEDENT for j in range ( l - 1 ) : NEW_LINE INDENT n = n * 10 + abs ( a [ j ] - a [ j + 1 ] ) NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT n = 6972 NEW_LINE ans = RSF ( n ) NEW_LINE print ( ans ) NEW_LINE
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def circular ( head ) : NEW_LINE INDENT start = head NEW_LINE while ( head . next != None ) : NEW_LINE INDENT head = head . next NEW_LINE DEDENT head . next = start NEW_LINE return start NEW_LINE DEDENT def push ( head , data ) : NEW_LINE INDENT newNode = Node ( data ) NEW_LINE newNode . data = data NEW_LINE newNode . next = ( head ) NEW_LINE ( head ) = newNode NEW_LINE return head NEW_LINE DEDENT def displayList ( head ) : NEW_LINE INDENT start = head NEW_LINE while ( node . next != start ) : NEW_LINE INDENT print ( node . data , end = " ▁ " ) NEW_LINE node = node . next NEW_LINE DEDENT print ( node . data , end = " ▁ " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT head = None NEW_LINE head = push (
class Solution ( object ) : NEW_LINE INDENT def licenseKeyFormatting ( self , s , k ) : NEW_LINE INDENT for i in range ( len ( s ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if s [ i ] != ' - ' : NEW_LINE INDENT if len ( s ) % ( k + 1 ) == k : NEW_LINE INDENT print ( ' - ' , end = ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ i ] , end = ' ' ) NEW_LINE DEDENT DEDENT DEDENT return s [ : : - 1 ] NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE s = "5F3Z - 2e - 9 - w " NEW_LINE k = 4 NEW_LINE out = sObj . licenseKeyFormatting ( s , k ) NEW_LINE print ( out ) NEW_LINE DEDENT
EPS = 1E-15 NEW_LINE def findMinValue ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += ( math . log10 ( arr [ i ] ) + EPS ) NEW_LINE DEDENT xl = ( sum / n + EPS ) NEW_LINE res = pow ( 10.0 , xl ) + EPS NEW_LINE return ceil ( res + EPS ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 2 , 1 , 10 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMinValue ( arr , n ) ) NEW_LINE DEDENT
def digroot ( n ) : NEW_LINE INDENT root = 0 NEW_LINE while ( n > 0 or root > 9 ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT n = root NEW_LINE root = 0 NEW_LINE DEDENT root += n % 10 NEW_LINE n //= 10 NEW_LINE DEDENT return root NEW_LINE DEDENT n = 65785412 NEW_LINE print ( digroot ( n ) ) NEW_LINE
m , n = map ( int , input ( ) . split ( ) ) NEW_LINE if m == n : NEW_LINE INDENT print ( " YES " ) NEW_LINE print ( len ( str ( n ) ) ) NEW_LINE print ( * str ( n // 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def k_sum ( a , n , k ) : NEW_LINE INDENT r = 0 NEW_LINE sum = 0 NEW_LINE ans = 0 NEW_LINE for l in range ( 0 , n ) : NEW_LINE INDENT while ( sum < k ) : NEW_LINE INDENT if ( r == n ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT sum += a [ r ] NEW_LINE r += 1 NEW_LINE DEDENT DEDENT if ( sum < k ) : NEW_LINE INDENT break NEW_LINE DEDENT ans += n - r + 1 NEW_LINE sum -= a [ l ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 6 , 1 , 2 , 7 ] NEW_LINE k = 10 NEW_LINE n = len ( a ) NEW_LINE print ( k_sum ( a , n , k ) ) NEW_LINE DEDENT
def getChar ( str ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT sum += ( ord ( str [ i ] ) - ord ( ' a ' ) + 1 ) NEW_LINE DEDENT if ( sum % 26 == 0 ) : NEW_LINE INDENT return ' z ' NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum % 26 NEW_LINE return chr ( ord ( ' a ' ) + sum - 1 ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " gfg " NEW_LINE print ( getChar ( str ) ) NEW_LINE DEDENT
def sumNth ( A , B , m , n ) : NEW_LINE INDENT res = 0 NEW_LINE if ( n == 1 ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT res = res + A [ i ] NEW_LINE DEDENT DEDENT elif ( n == 2 ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT res = res + B [ i ] * m NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT f = [ 0 ] * n NEW_LINE f [ 0 ] = 0 NEW_LINE f [ 1 ] = 1 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT f [ i ] = f [ i - 1 ] + f [ i - 2 ] NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT res = res + ( m * ( B [ i ] * f [ n - 1 ] ) ) + ( m * ( A [ i ] * f [ n - 2 ] ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE
def odd_even ( arr , n ) : NEW_LINE INDENT odd_indexes = [ ] NEW_LINE even_indexes = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT odd_indexes . append ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT even_indexes . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT odd_indexes . sort ( ) NEW_LINE even_indexes . sort ( ) NEW_LINE for i in range ( 0 , len ( odd_indexes ) ) : NEW_LINE INDENT print ( odd_indexes [ i ] , end = " ▁ " ) NEW_LINE DEDENT for i in range ( 0 , len ( even_indexes ) ) : NEW_LINE INDENT print ( even_indexes [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 2 , 7 , 6 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE odd_even ( arr , n ) NEW
def printFirstNegativeInteger ( arr , n , k ) : NEW_LINE INDENT flag = False NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT flag = False NEW_LINE for j in range ( k ) : NEW_LINE INDENT if ( arr [ i + j ] < 0 ) : NEW_LINE INDENT print ( ( arr [ i + j ] ) , end = " ▁ " ) NEW_LINE flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT print ( "0" , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 12 , - 1 , - 7 , 8 , - 15 , 30 , 16 , 28 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE printFirstNegativeInteger ( arr , n , k ) NEW_LINE DEDENT
def fillPrefixSum ( arr , n , prefixSum ) : NEW_LINE INDENT prefixSum [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefixSum [ i ] = prefixSum [ i - 1 ] + arr [ i ] NEW_LINE DEDENT DEDENT arr = [ 10 , 4 , 16 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE fillPrefixSum ( arr , n , prefixSum ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( prefixSum [ i ] , end = " ▁ " ) NEW_LINE DEDENT
import sys NEW_LINE for line in sys . stdin : NEW_LINE INDENT x1 , y1 , x2 , y2 , x3 , y3 = map ( float , line . split ( ' , ' ) ) NEW_LINE if x1 == x2 : NEW_LINE INDENT x1 = x3 NEW_LINE DEDENT elif y1 == y2 : NEW_LINE INDENT y1 = y3 NEW_LINE DEDENT elif x3 == x2 : NEW_LINE INDENT x3 = x2 - x3 NEW_LINE DEDENT elif y3 == y2 : NEW_LINE INDENT y3 = y2 - y3 NEW_LINE DEDENT else : NEW_LINE INDENT x3 = x1 - x3 NEW_LINE DEDENT x = ( x3 ** 2 + y3 ** 2 ) ** 0.5 NEW_LINE y = ( y3 ** 2 + x1 ** 2 - y1 ** 2 ) ** 0.5 NEW_LINE x = ( x3 ** 2 + y1 ** 2 ) ** 0.5 NEW_LINE y = ( y3 ** 2 + x1 ** 2 - y1 ** 2 ) ** 0.5 NEW_LINE DEDENT print ( '
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n - 201 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT ans = max ( ans , ( i + 1 ) * ( j + 1 ) - k * ( a [ i ] | a [ j ] ) ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
MAX_CHAR = 26 ; NEW_LINE def commonCharacters ( str1 , n ) : NEW_LINE INDENT prim = [ True ] * MAX_CHAR ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sec = [ False ] * MAX_CHAR ; NEW_LINE for j in range ( len ( str1 [ i ] ) ) : NEW_LINE INDENT if prim [ ord ( str1 [ i ] [ j ] ) - ord ( ' a ' ) ] : NEW_LINE INDENT sec [ ord ( str1 [ i ] [ j ] ) - ord ( ' a ' ) ] = True ; NEW_LINE DEDENT DEDENT print ( " ▁ " . join ( map ( str . ord , sec ) ) ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str1 = [ " geeksforgeeks " , " gemkstones " , " acknowledges " , " aguelikes " ] ; NEW_LINE n = len ( str1 ) ; NEW_LINE commonCharacters ( str1 , n ) ; NEW_LINE DEDENT
class Solution ( object ) : NEW_LINE INDENT def findDisappearedNumbers ( self , nums ) : NEW_LINE INDENT ret = [ ] NEW_LINE for i in range ( len ( nums ) ) : NEW_LINE INDENT val = abs ( nums [ i ] ) - 1 NEW_LINE if nums [ val ] > 0 : NEW_LINE INDENT nums [ val ] = - nums [ val ] NEW_LINE DEDENT DEDENT for i in range ( len ( nums ) ) : NEW_LINE INDENT if nums [ i ] > 0 : NEW_LINE INDENT ret . append ( i + 1 ) NEW_LINE DEDENT DEDENT return ret NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE nums = [ 4 , 3 , 2 , 7 , 8 , 2 , 3 , 1 ] NEW_LINE out = sObj . findDisappearedNumbers ( nums ) NEW_LINE print ( out ) NEW_LINE DEDENT
def findMaxValue ( ) : NEW_LINE INDENT res = 2 ; NEW_LINE fact = 2 ; NEW_LINE while ( True ) : NEW_LINE INDENT if ( fact < 0 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT res += 1 ; NEW_LINE fact = fact * res ; NEW_LINE DEDENT return res - 1 ; NEW_LINE DEDENT print ( " Maximum ▁ value ▁ of ▁ integer : " , findMaxValue ( ) ) ; NEW_LINE
a , b = map ( str , input ( ) . split ( ) ) NEW_LINE c = 0 NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT if a [ i ] == b [ j ] : NEW_LINE INDENT c = 1 NEW_LINE DEDENT DEDENT DEDENT if c == 1 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( len ( set ( a ) - set ( a ) ) ) NEW_LINE DEDENT
def primesieve ( prime ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE for p in range ( 2 , 650 + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , 650 + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def sum_sqsum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE sqsum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT x = n % 10 NEW_LINE sum += x NEW_LINE sqsum += x * x NEW_LINE n //= 10 NEW_LINE DEDENT return ( ( sum , sqsum ) ) NEW_LINE DEDENT def countnumber ( L , R ) : NEW_LINE INDENT prime = [ True ] * 651 NEW_LINE primesieve ( prime ) NEW_LINE cnt = 0 NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT digit = sum_sqsum ( i ) NEW_LINE if ( prime [ digit [ 0 ] ] and prime [ digit [
def printRepeating ( arr , size ) : NEW_LINE INDENT s = set ( ) NEW_LINE s . add ( arr ) NEW_LINE print ( s ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 3 , 2 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE printRepeating ( arr , n ) NEW_LINE DEDENT
import sys NEW_LINE def compute ( ) : NEW_LINE INDENT INDEX = 124 NEW_LINE def has_tribonacci_multiple ( modulus ) : NEW_LINE INDENT slow = [ 1 , 1 , 1 ] NEW_LINE fast = slow [ : ] NEW_LINE for head in range ( True , False , 2 ) : NEW_LINE INDENT if ( slow [ 0 ] % modulus == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( head == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( slow [ 0 ] % modulus == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( fast != slow ) : NEW_LINE INDENT return False NEW_LINE DEDENT tribonacci ( slow , modulus ) NEW_LINE tribonacci ( fast , modulus ) NEW_LINE tribonacci ( fast , modulus ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def solution ( a , b , n ) : NEW_LINE INDENT for i in range ( 0 , n + 1 ) : NEW_LINE INDENT if ( ( n - ( i * a ) ) % b == 0 ) : NEW_LINE INDENT print ( " x ▁ = " , i , " , ▁ y ▁ = " , ( n - ( i * a ) ) // b ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT print ( " No ▁ solution " ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 2 ; b = 3 ; n = 7 ; NEW_LINE solution ( a , b , n ) ; NEW_LINE DEDENT
x , y = map ( int , input ( ) . split ( ) ) NEW_LINE if x == y : NEW_LINE INDENT print ( ' = ' ) NEW_LINE DEDENT elif x > y : NEW_LINE INDENT print ( ' > ' ) NEW_LINE DEDENT elif x < y : NEW_LINE INDENT print ( ' < ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' > ' ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE print ( n - s . find ( " xx " ) + 1 ) NEW_LINE
H , W = map ( int , input ( ) . split ( ) ) NEW_LINE A = [ ] NEW_LINE for i in range ( H ) : NEW_LINE INDENT A . append ( list ( input ( ) ) ) NEW_LINE DEDENT for i in range ( H ) : NEW_LINE INDENT for j in range ( W ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT if j % 2 == 0 : NEW_LINE INDENT A [ i ] [ j ] = ' # ' NEW_LINE DEDENT else : NEW_LINE INDENT A [ i ] [ j ] = ' . ' NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( H ) : NEW_LINE INDENT for j in range ( W ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT if j % 2 == 0 : NEW_LINE INDENT A [ i ] [ j ] = ' # ' NEW_LINE DEDENT else : NEW_LINE INDENT A [ i ] [ j ] = ' . ' NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT for i in range ( H ) : NEW_LINE INDENT for j in range ( W
def unitDigitXRaisedY ( x , y ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( y ) : NEW_LINE INDENT res = ( res * x ) % 10 NEW_LINE DEDENT return res NEW_LINE DEDENT print ( unitDigitXRaisedY ( 4 , 2 ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE count = 0 NEW_LINE for i in range ( 1 , int ( n / 2 ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE print ( max ( 0 , min ( n , k - 1 ) - k // 2 ) ) NEW_LINE
import math NEW_LINE def checkCollision ( a , b , c , x , y , radius ) : NEW_LINE INDENT dist = ( abs ( a * x + b * y + c ) ) / math . sqrt ( a * a + b * b ) NEW_LINE if ( radius == dist ) : NEW_LINE INDENT print ( " Touch " ) NEW_LINE DEDENT elif ( radius > dist ) : NEW_LINE INDENT print ( " Intersect " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Outside " ) NEW_LINE DEDENT DEDENT radius = 5 NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE a = 3 NEW_LINE b = 4 NEW_LINE c = 25 NEW_LINE checkCollision ( a , b , c , x , y , radius ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE exit ( ) NEW_LINE DEDENT if k == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT if k == 2 : NEW_LINE INDENT print ( 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT if k == 3 : NEW_LINE INDENT print ( 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT if k == 4 : NEW_LINE INDENT print ( 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT if k == 5 : NEW_LINE INDENT print ( 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT if k == 6 : NEW_LINE INDENT print ( 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT if k == 7 : NEW_LINE INDENT print ( 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT print ( k - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT if k == 8 : NEW_LINE INDENT print ( 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT print (
def DivisibleBy41 ( first , second , c , n ) : NEW_LINE INDENT digit = [ 0 for i in range ( n ) ] NEW_LINE digit [ 0 ] = first NEW_LINE digit [ 1 ] = second NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT digit [ i ] = ( digit [ i - 1 ] * c + digit [ i - 2 ] ) % 10 NEW_LINE DEDENT ans = digit [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans = ( ans * 10 + digit [ i ] ) % 41 NEW_LINE DEDENT if ( ans % 41 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT first = 1 NEW_LINE second = 2 NEW_LINE c = 1 NEW_LINE n = 3 NEW_LINE if ( DivisibleBy41 ( first , second , c , n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print (
N , M = map ( int , input ( ) . split ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE A . sort ( ) NEW_LINE dp = [ 0 ] * ( N + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if i - A [ j ] >= 0 and dp [ i - A [ j ] ] == 0 : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ i - A [ j ] ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( M ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if i - A [ j ] >= 0 and dp [ i - A [ j ] ] == 0 : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ i - A [ j ] ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT print ( dp [ N ] ) NEW_LINE
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT area = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y = map ( float , input ( ) . split ( ) ) NEW_LINE area += ( x ** 2 - y ** 2 ) / 2 NEW_LINE DEDENT area += ( x ** 2 - y ** 2 ) / 2 NEW_LINE area += ( x ** 2 - y ** 2 ) / 2 NEW_LINE print ( str ( area ) + " ▁ " + str ( area - 1 ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( sum ( l ) - max ( l ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT h , m = map ( int , input ( ) . split ( ) ) NEW_LINE print ( 60 * h - m ) NEW_LINE DEDENT
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE if max ( a , b , c ) == 100 : NEW_LINE INDENT print ( " A " ) NEW_LINE DEDENT elif ( a + b ) / 2 >= 90 : NEW_LINE INDENT print ( " A " ) NEW_LINE DEDENT elif ( a + b ) / 3 >= 80 : NEW_LINE INDENT print ( " A " ) NEW_LINE DEDENT elif ( a + b ) / 3 >= 70 : NEW_LINE INDENT print ( " B " ) NEW_LINE DEDENT elif ( a + b ) / 3 >= 50 : NEW_LINE INDENT print ( " B " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " C " ) NEW_LINE DEDENT DEDENT DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE print ( a [ n - k ] ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE a = s . count ( '1' ) NEW_LINE b = s . count ( '0' ) NEW_LINE if a == 0 and b == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif a == 0 and b > 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == '1' : NEW_LINE INDENT c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT c -= 1 NEW_LINE DEDENT if c % k == 0 and ( b - c ) // k >= 0 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE DEDENT DEDENT
def search ( arr , l , h , key ) : NEW_LINE INDENT if ( l > h ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( l + h ) // 2 NEW_LINE if ( arr [ mid ] == key ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( arr [ l ] <= arr [ mid ] ) : NEW_LINE INDENT if ( key >= arr [ l ] and key <= arr [ mid ] ) : NEW_LINE INDENT return search ( arr , l , mid - 1 , key ) NEW_LINE DEDENT return search ( arr , mid + 1 , h , key ) NEW_LINE DEDENT if ( key >= arr [ mid ] and key <= arr [ h ] ) : NEW_LINE INDENT return search ( arr , mid + 1 , h , key ) NEW_LINE DEDENT return search ( arr , l , mid - 1 , key ) NEW_LINE DEDENT arr = [ 4 , 5 , 6 , 7 , 8 , 9 , 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE key = 6 NEW_LINE i = search ( arr , 0 , n - 1 , key ) NEW_
def fillWithFreq ( arr , n ) : NEW_LINE INDENT temp = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE DEDENT DEDENT arr = [ 5 , 2 , 3 , 4 , 5 , 5 , 4 , 5 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE fillWithFreq ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT
import math NEW_LINE def convert_To_Len_th_base ( n , arr , len , L ) : NEW_LINE INDENT for i in range ( L ) : NEW_LINE INDENT print ( arr [ n % len ] , end = " " ) NEW_LINE n //= len NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def print ( arr , len , L ) : NEW_LINE INDENT for i in range ( int ( math . pow ( len , L ) ) ) : NEW_LINE INDENT convert_To_Len_th_base ( i , arr , len , L ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 ] NEW_LINE len = len ( arr ) NEW_LINE L = 2 NEW_LINE print ( arr , len , L ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE d = { } NEW_LINE for _ in range ( m ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE d [ a - 1 ] = d . get ( a - 1 , 0 ) + 1 NEW_LINE d [ b - 1 ] = d . get ( b - 1 , 0 ) + 1 NEW_LINE DEDENT if d . get ( 1 , 0 ) == 0 : NEW_LINE INDENT print ( " ring ▁ topology " ) NEW_LINE DEDENT elif d . get ( 2 , 0 ) == 0 : NEW_LINE INDENT print ( " bus ▁ topology " ) NEW_LINE DEDENT elif d . get ( 2 , 0 ) == 1 : NEW_LINE INDENT print ( " star ▁ topology " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " unknown ▁ topology " ) NEW_LINE DEDENT
import math NEW_LINE def max_gcd ( n , p ) : NEW_LINE INDENT count = 0 NEW_LINE gcd = 1 NEW_LINE while ( p % 2 == 0 ) : NEW_LINE INDENT p >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT if ( count > 0 ) : NEW_LINE INDENT gcd *= pow ( 2 , count // n ) NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( p ) ) + 1 , 2 ) : NEW_LINE INDENT count = 0 NEW_LINE while ( p % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE p = p // i NEW_LINE DEDENT if ( count > 0 ) : NEW_LINE INDENT gcd *= pow ( i , count // n ) NEW_LINE DEDENT DEDENT if ( p > 2 ) : NEW_LINE INDENT gcd *= pow ( p , 1 / n ) NEW_LINE DEDENT return gcd NEW_LINE DEDENT n = 3 NEW_LINE p = 80 NEW_LINE print ( max_gcd ( n , p ) ) NEW_LINE
def maxArea ( perimeter ) : NEW_LINE INDENT length = int ( perimeter / 4 ) NEW_LINE breadth = int ( perimeter / 4 ) NEW_LINE return length * breadth NEW_LINE DEDENT n = 38 NEW_LINE print ( " Maximum ▁ Area ▁ = " , maxArea ( n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 1 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE c . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a_i = a [ i ] - 0.1 NEW_LINE b_i = b [ i ] + 0.1 NEW_LINE c_i = c [ i ] - 0.1 NEW_LINE c_i = c [ i ] + 0.1 NEW_LINE ans += ( a_i ** 2 + b_i ** 2 + c_i ** 2 ) ** 0.5 NEW_LINE DEDENT print ( ans ) NEW_LINE
def calculate_angle ( n , i , j , k ) : NEW_LINE INDENT if ( i < j ) : NEW_LINE INDENT x = j - i ; NEW_LINE DEDENT else : NEW_LINE INDENT x = j + n - i ; NEW_LINE DEDENT if ( j < k ) : NEW_LINE INDENT y = k - j ; NEW_LINE DEDENT else : NEW_LINE INDENT y = k + n - j ; NEW_LINE DEDENT return ( 180 - ang1 - ang2 ) ; NEW_LINE DEDENT n = 5 ; NEW_LINE a1 = 1 ; NEW_LINE a2 = 2 ; NEW_LINE a3 = 5 ; NEW_LINE print ( calculate_angle ( n , a1 , a2 , a3 ) ) ; NEW_LINE
def solve ( arr , n ) : NEW_LINE INDENT k = len ( arr ) NEW_LINE mp = [ 0 for i in range ( n + 2 ) ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT leftSegment = arr [ 0 ] - 1 NEW_LINE for i in range ( 1 , k ) : NEW_LINE INDENT leftSegment = max ( leftSegment , arr [ i ] - arr [ i - 1 ] - 1 ) NEW_LINE DEDENT rightSegment = n - arr [ k - 1 ] NEW_LINE maxSegment = max ( leftSegment , rightSegment ) NEW_LINE if ( maxSegment & 1 ) : NEW_LINE INDENT tim = ( maxSegment // 2 ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT tim = maxSegment // 2 NEW_LINE DEDENT return tim NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 5 NEW_LINE arr = [ 1 , 4 ] NEW_LINE print ( solve ( arr , N ) ) NEW_LINE DEDENT
def findCombinationsUtil ( arr , index , n , red_num ) : NEW_LINE INDENT s = set ( ) NEW_LINE sum = 0 NEW_LINE if ( red_num < 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( red_num == 0 ) : NEW_LINE INDENT for i in range ( index ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT for itr in s : NEW_LINE INDENT sum = sum + itr NEW_LINE DEDENT if ( sum == n ) : NEW_LINE INDENT for i in s : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE return NEW_LINE DEDENT DEDENT prev = arr [ index - 1 ] NEW_LINE for k in range ( prev , n + 1 ) : NEW_LINE INDENT if ( index < n ) : NEW_LINE INDENT arr [ index ] = k NEW_LINE findCombinationsUtil ( arr , index + 1 , n , red_num - k ) NEW_LINE DEDENT DEDENT DEDENT def findCombinations ( n ) : NEW_LINE INDENT a = [
def KthMinValAfterMconcatenate ( A , N , M , K ) : NEW_LINE INDENT V = [ ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT V . append ( A [ j ] ) NEW_LINE DEDENT DEDENT V . sort ( ) NEW_LINE return V [ K - 1 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = [ 3 , 1 , 2 ] NEW_LINE M = 3 NEW_LINE K = 4 NEW_LINE N = len ( A ) NEW_LINE print ( KthMinValAfterMconcatenate ( A , N , M , K ) ) NEW_LINE DEDENT
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE input = sys . stdin . readline NEW_LINE from collections import deque NEW_LINE from collections import defaultdict NEW_LINE def main ( ) : NEW_LINE INDENT A , B = map ( int , input ( ) . split ( ) ) NEW_LINE d = defaultdict ( int ) NEW_LINE d [ A ] = 1 NEW_LINE q = deque ( ) NEW_LINE q . append ( A ) NEW_LINE while q : NEW_LINE INDENT x = q . popleft ( ) NEW_LINE if d [ x ] == 1 : NEW_LINE INDENT d [ x ] = 0 NEW_LINE q . append ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT d [ x ] += 1 NEW_LINE q . append ( x ) NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE while q : NEW_LINE INDENT x = q . popleft ( ) NEW_LINE if d [ x ] == 1 : NEW_LINE INDENT ans += 1 NEW_LINE d [ x ] = 0 NEW_LINE q . append ( x ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def numberOfSolutions ( n ) : NEW_LINE INDENT c = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT c += n % 2 NEW_LINE n //= 2 NEW_LINE DEDENT return pow ( 2 , c ) NEW_LINE DEDENT n = 3 NEW_LINE print ( numberOfSolutions ( n ) ) NEW_LINE
n , x = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( ' YES ' if x == sum ( a ) - 1 else ' NO ' ) NEW_LINE
import math NEW_LINE def compute ( ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , 20 ) : NEW_LINE INDENT ans = math . gcd ( ans , i ) * i NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def Profit ( costPrice , sellingPrice ) : NEW_LINE INDENT profit = ( sellingPrice - costPrice ) NEW_LINE return profit NEW_LINE DEDENT def Loss ( costPrice , sellingPrice ) : NEW_LINE INDENT Loss = ( costPrice - sellingPrice ) NEW_LINE return Loss NEW_LINE DEDENT costPrice = 1500 NEW_LINE sellingPrice = 2000 NEW_LINE if ( sellingPrice == costPrice ) : NEW_LINE INDENT print ( " No ▁ profit ▁ nor ▁ Loss " ) NEW_LINE DEDENT elif ( sellingPrice > costPrice ) : NEW_LINE INDENT print ( Profit ( costPrice , sellingPrice ) , " Profit ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( Loss ( costPrice , sellingPrice ) , " Loss ▁ " ) NEW_LINE DEDENT
n , h , k = map ( int , input ( ) . split ( ) ) NEW_LINE print ( min ( h + n + k , n - h + k ) ) NEW_LINE
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT S = int ( input ( ) ) NEW_LINE if S == 1 : NEW_LINE INDENT print ( 2 ) NEW_LINE return NEW_LINE DEDENT if S % 2 == 0 : NEW_LINE INDENT print ( 3 ) NEW_LINE return NEW_LINE DEDENT if S % 2 == 1 : NEW_LINE INDENT print ( 2 ) NEW_LINE return NEW_LINE DEDENT if S % 2 == 0 : NEW_LINE INDENT print ( 3 ) NEW_LINE return NEW_LINE DEDENT S += 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
while True : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 : break NEW_LINE print ( sum ( map ( int , input ( ) . split ( ) ) ) // n ) NEW_LINE DEDENT
pr = [ True ] * ( 10000000 + 1 ) ; NEW_LINE prime = [ False ] * ( 10000000 + 1 ) ; NEW_LINE def sieve ( n ) : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT prime [ i ] = True ; NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT pr . append ( p ) ; NEW_LINE DEDENT DEDENT DEDENT def SemiPrimeSum ( N ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( len ( pr ) ) : NEW_LINE INDENT for j in range ( i , len ( pr ) ) : NEW_LINE INDENT if ( pr [ i ] * pr [ j ] > N ) : NEW_LINE INDENT break ;
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE if n % 2 == 0 : NEW_LINE INDENT print ( n + k * 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT if k % 2 == 0 : NEW_LINE INDENT print ( n + k * 2 - 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n + k * 2 - 2 ) NEW_LINE DEDENT DEDENT DEDENT
import math NEW_LINE def isPrime ( N ) : NEW_LINE INDENT if ( N < 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( N < 4 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( ( N & 1 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( N % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT curr = 5 NEW_LINE s = int ( math . sqrt ( N ) ) NEW_LINE while ( curr <= s ) : NEW_LINE INDENT if ( N % curr == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT curr += 2 NEW_LINE if ( N % curr == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT curr += 4 NEW_LINE DEDENT return True NEW_LINE DEDENT def check ( s , p , prefix_sum , n ) : NEW_LINE INDENT satisfies = True NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i + s - 1 >= n ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( prefix_sum [ i + s - 1
import math NEW_LINE def checkPerfectSquare ( n ) : NEW_LINE INDENT d = math . sqrt ( n ) NEW_LINE if ( d * d == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def largestPerfectSquareNumber ( a , n ) : NEW_LINE INDENT maxi = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( checkPerfectSquare ( a [ i ] ) ) : NEW_LINE INDENT maxi = max ( a [ i ] , maxi ) NEW_LINE DEDENT DEDENT return maxi NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 16 , 20 , 25 , 2 , 3 , 10 ] NEW_LINE n = len ( a ) NEW_LINE print ( largestPerfectSquareNumber ( a , n ) ) NEW_LINE DEDENT
class Solution ( object ) : NEW_LINE INDENT def compress ( self , chars ) : NEW_LINE INDENT anchor = 0 NEW_LINE write = 0 NEW_LINE for i in range ( len ( chars ) ) : NEW_LINE INDENT if i + 1 == len ( chars ) or chars [ i + 1 ] != chars [ i ] : NEW_LINE INDENT chars [ write ] = chars [ anchor ] NEW_LINE write += 1 NEW_LINE DEDENT anchor = i + 1 NEW_LINE DEDENT return write NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE chars = [ ' a ' , ' a ' , ' b ' , ' b ' , ' c ' , ' c ' , ' c ' ] NEW_LINE out = sObj . compress ( chars ) NEW_LINE print ( out ) NEW_LINE DEDENT
def checkPalindrome ( num ) : NEW_LINE INDENT str = str ( num ) NEW_LINE l = 0 NEW_LINE r = len ( str ) - 1 NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( str [ l ] != str [ r ] ) : NEW_LINE INDENT print ( " No " ) NEW_LINE return NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT print ( " Yes " ) NEW_LINE return NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 19 NEW_LINE k = 3 NEW_LINE checkPalindrome ( n + k ) NEW_LINE DEDENT
def isVowel ( c ) : NEW_LINE INDENT return ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' ) NEW_LINE DEDENT def countSubstringsUtil ( s ) : NEW_LINE INDENT count = 0 NEW_LINE mp = dict ( ) NEW_LINE n = len ( s ) NEW_LINE start = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] in mp : NEW_LINE INDENT mp [ s [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ s [ i ] ] = 1 NEW_LINE DEDENT DEDENT while ( mp . count ( ' a ' ) and mp . count ( ' e ' ) and mp . count ( ' i ' ) and mp . count ( ' o ' ) and mp . count ( ' u ' ) ) : NEW_LINE INDENT count += n - i NEW_LINE mp [ s [ start ] ] -= 1 NEW_LINE start += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def countSubstrings ( s ) : NEW_LINE INDENT count = 0 NEW
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n , q = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE for _ in range ( q ) : NEW_LINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEW_LINE c = s [ l - 1 : r - 1 ] NEW_LINE d = { } NEW_LINE for i in c : NEW_LINE INDENT if i in d : NEW_LINE INDENT d [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] = 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in d : NEW_LINE INDENT if i in d : NEW_LINE INDENT ans += d [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT ans += d [ i ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def setAllBitsAfterMSB ( n ) : NEW_LINE INDENT n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE return n NEW_LINE DEDENT def toggle ( n ) : NEW_LINE INDENT n = n ^ setAllBitsAfterMSB ( n ) NEW_LINE return n NEW_LINE DEDENT n = 10 NEW_LINE n = toggle ( n ) NEW_LINE print ( n ) NEW_LINE
class Data : NEW_LINE INDENT def __init__ ( self , x , y ) : NEW_LINE INDENT self . x = x NEW_LINE self . y = y NEW_LINE DEDENT DEDENT def inv_interpolate ( d , n , y ) : NEW_LINE INDENT x = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xi = d [ i ] . x NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( j != i ) : NEW_LINE INDENT xi = xi * ( y - d [ j ] . y ) / ( d [ i ] . y - d [ j ] . y ) NEW_LINE DEDENT DEDENT x += xi NEW_LINE DEDENT return x NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT d = [ Data ( 1.27 , 2.3 ) , Data ( 2.25 , 2.95 ) , Data ( 2.5 , 3.5 ) , Data ( 3.6 , 5.1 ) ] NEW_LINE n = 4 NEW_LINE y = 4.5 NEW_LINE print ( " Value ▁ of
def findElement ( arr , n ) : NEW_LINE INDENT prefixMul = [ 0 ] * n ; NEW_LINE prefixMul [ 0 ] = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefixMul [ i ] = prefixMul [ i - 1 ] * arr [ i ] ; NEW_LINE DEDENT suffixMul = [ 0 ] * n ; NEW_LINE suffixMul [ n - 1 ] = arr [ n - 1 ] ; NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT suffixMul [ i ] = suffixMul [ i + 1 ] * arr [ i ] ; NEW_LINE DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( prefixMul [ i ] == suffixMul [ i ] ) : NEW_LINE INDENT return arr [ i ] ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 1 , 4 , 6 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE
def numberOfDays ( a , b , n ) : NEW_LINE INDENT Days = b * ( n + a ) // ( a + b ) NEW_LINE return Days NEW_LINE DEDENT a = 10 NEW_LINE b = 20 NEW_LINE n = 5 NEW_LINE print ( numberOfDays ( a , b , n ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE s1 = s [ : : - 1 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if s1 [ i ] > s [ i - 1 ] : NEW_LINE INDENT s1 = s1 [ : i - 1 ] + s1 [ i - 1 : ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( s1 ) NEW_LINE DEDENT
MAX = 100005 NEW_LINE fibonacci = set ( ) NEW_LINE def createHash ( ) : NEW_LINE INDENT prev = 0 NEW_LINE curr = 1 NEW_LINE fibonacci . add ( prev ) NEW_LINE fibonacci . add ( curr ) NEW_LINE while ( curr <= MAX ) : NEW_LINE INDENT temp = curr + prev NEW_LINE fibonacci . add ( temp ) NEW_LINE prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT def checkArray ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( fibonacci . count ( arr [ i ] ) ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT if ( fibonacci . count ( sum ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 8 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def solve ( health , n ) : NEW_LINE INDENT currentgcd = gcd ( health [ 0 ] , health [ 1 ] ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT currentgcd = gcd ( currentgcd , health [ i ] ) NEW_LINE DEDENT return currentgcd NEW_LINE DEDENT health = [ 4 , 6 , 8 , 12 ] NEW_LINE n = len ( health ) NEW_LINE print ( solve ( health , n ) ) NEW_LINE
import math NEW_LINE def squarearea ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = 4 * ( math . pow ( r , 2 ) / 5 ) NEW_LINE return a NEW_LINE DEDENT r = 5 NEW_LINE print ( squarearea ( r ) ) NEW_LINE
class Graph : NEW_LINE INDENT def __init__ ( self , V ) : NEW_LINE INDENT self . V = V NEW_LINE self . adj = [ [ ] for i in range ( V ) ] NEW_LINE DEDENT def addEdge ( v , w ) : NEW_LINE INDENT adj [ v ] . append ( w ) NEW_LINE DEDENT def DFSUtil ( s , visited ) : NEW_LINE INDENT stack = [ ] NEW_LINE while ( len ( stack ) != 0 ) : NEW_LINE INDENT s = stack . pop ( ) NEW_LINE if ( visited [ s ] == False ) : NEW_LINE INDENT print ( s , end = " ▁ " ) NEW_LINE visited [ s ] = True NEW_LINE DEDENT itr = adj [ s ] NEW_LINE while ( itr ) : NEW_LINE INDENT v = itr . next ( ) NEW_LINE if ( not visited [ v ] ) : NEW_LINE INDENT stack . append ( v ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT G = Graph ( ) NEW_LINE G . dfs ( 0 ) NEW_
class Graph : NEW_LINE INDENT def __init__ ( self , V ) : NEW_LINE INDENT self . V = V NEW_LINE self . adj = [ [ ] for i in range ( V ) ] NEW_LINE DEDENT DEDENT def addEdge ( v , w ) : NEW_LINE INDENT adj [ v ] . append ( w ) NEW_LINE DEDENT def DFS ( s ) : NEW_LINE INDENT visited = [ False ] * V NEW_LINE stack = [ ] NEW_LINE while len ( stack ) != 0 : NEW_LINE INDENT s = stack . pop ( ) NEW_LINE if visited [ s ] == False : NEW_LINE INDENT print ( s , end = " ▁ " ) NEW_LINE visited [ s ] = True NEW_LINE DEDENT itr = adj [ s ] NEW_LINE while ( len ( itr ) != 0 ) : NEW_LINE INDENT v = itr [ 0 ] NEW_LINE if not visited [ v ] : NEW_LINE INDENT stack . append ( v ) NEW_LINE DEDENT itr . pop ( ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT g = Graph
s = input ( ) NEW_LINE n = len ( s ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if s [ i ] == s [ i + 1 ] : NEW_LINE INDENT print ( i + 1 , i + 2 ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( - 1 , - 1 ) NEW_LINE
def sequence ( n ) : NEW_LINE INDENT f = [ 0 ] * ( n + 1 ) ; NEW_LINE f [ 0 ] = 0 ; NEW_LINE f [ 1 ] = 1 ; NEW_LINE f [ 2 ] = 1 ; NEW_LINE print ( f [ 1 ] , f [ 2 ] , end = " ▁ " ) ; NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ; NEW_LINE print ( f [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT n = 13 ; NEW_LINE sequence ( n ) ; NEW_LINE
n , p , q , r = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = max ( ans , p * a [ i ] + q * a [ i ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE
def compute ( ) : NEW_LINE INDENT ans = 0 NEW_LINE for n in range ( 1 , 9 ) : NEW_LINE INDENT for k in range ( 1 , 21 ) : NEW_LINE INDENT if n ** k == k : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
import math NEW_LINE n = 12 NEW_LINE print ( math . sqrt ( n ) ) NEW_LINE
import math NEW_LINE def findSum ( n ) : NEW_LINE INDENT return math . sqrt ( 3 ) * ( n * ( n + 1 ) / 2 ) NEW_LINE DEDENT n = 10 NEW_LINE print ( findSum ( n ) ) NEW_LINE
import math NEW_LINE def findNth ( n ) : NEW_LINE INDENT nthElement = 19 + ( n - 1 ) * 9 NEW_LINE outliersCount = int ( math . log10 ( nthElement ) ) - 1 NEW_LINE nthElement += 9 * outliersCount NEW_LINE return nthElement NEW_LINE DEDENT print ( findNth ( 5 ) ) NEW_LINE
def per ( a , b ) : NEW_LINE INDENT return ( a + b ) ; NEW_LINE DEDENT def area ( s ) : NEW_LINE INDENT return ( s / 2 ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 7 ; b = 8 ; s = 10 ; NEW_LINE print ( per ( a , b ) ) ; NEW_LINE print ( area ( s ) ) ; NEW_LINE DEDENT
def isBinary ( n ) : NEW_LINE INDENT while ( n != 0 ) : NEW_LINE INDENT temp = n % 10 NEW_LINE if ( temp != 0 and temp != 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = n // 10 NEW_LINE DEDENT return True NEW_LINE DEDENT def formBinaryStr ( n , a ) : NEW_LINE INDENT flag = True NEW_LINE s = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( isBinary ( a [ i ] ) ) : NEW_LINE INDENT s += a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT print ( s , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT a = [ 10 , 1 , 0 , 11 , 10 ] NEW_LINE N = len ( a ) NEW_LINE formBinaryStr ( N , a ) NEW_LINE
import math NEW_LINE def calculateAND ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE prime = [ True for i in range ( max_val + 1 ) ] NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( math . sqrt ( max_val ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT S1 = 0 NEW_LINE S2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT S1 += arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] != 1 ) : NEW_LINE INDENT S2 += arr [ i ] NEW_LINE DEDENT DEDENT return ( S1 & S2 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT a = [ ] NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE a . append ( x ) NEW_LINE b . append ( y ) NEW_LINE DEDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE dp = [ [ 0 ] * ( n + 1 ) for _ in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT dp [ i + 1 ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ j - b [ i ] ] + b [ i ] ) NEW_LINE DEDENT DEDENT print ( max ( dp ) ) NEW_LINE DEDENT
def findIndex ( str ) : NEW_LINE INDENT len = len ( str ) NEW_LINE open = [ 0 ] * ( len + 1 ) NEW_LINE close = [ 0 ] * ( len + 1 ) NEW_LINE index = - 1 NEW_LINE open [ 0 ] = 0 NEW_LINE close [ len ] = 0 NEW_LINE if ( str [ 0 ] == ' ( ' ) : NEW_LINE INDENT open [ 1 ] = 1 NEW_LINE DEDENT if ( str [ len - 1 ] == ' ) ' ) : NEW_LINE INDENT close [ len - 1 ] = 1 NEW_LINE DEDENT for i in range ( 1 , len ) : NEW_LINE INDENT if ( str [ i ] == ' ( ' ) : NEW_LINE INDENT open [ i + 1 ] = open [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT open [ i + 1 ] = open [ i ] NEW_LINE DEDENT DEDENT for i in range ( len - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( str [ i ] == ' ) ' ) : NEW_LINE INDENT close [ i ] = close [ i + 1 ] + 1 NEW_
def sumOfDigit ( K ) : NEW_LINE INDENT sod = 0 NEW_LINE while ( K != 0 ) : NEW_LINE INDENT sod += K % 10 NEW_LINE K //= 10 NEW_LINE DEDENT return sod NEW_LINE DEDENT def totalNumbersWithSpecificDifference ( N , diff ) : NEW_LINE INDENT low = 1 NEW_LINE high = N NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( mid - sumOfDigit ( mid ) < diff ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return ( N - high ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 13 NEW_LINE diff = 2 NEW_LINE print ( totalNumbersWithSpecificDifference ( N , diff ) ) NEW_LINE DEDENT
def numOfsubarrays ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT product = arr [ i ] NEW_LINE sum = arr [ i ] NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( product == sum ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT product *= arr [ j ] NEW_LINE sum += arr [ j ] NEW_LINE DEDENT if ( product == sum ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( numOfsubarrays ( arr , n ) ) NEW_LINE DEDENT
import math NEW_LINE n = int ( input ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 1 , 1 ) NEW_LINE DEDENT elif n == 2 : NEW_LINE INDENT print ( 2 , 2 ) NEW_LINE DEDENT elif n % 2 == 0 : NEW_LINE INDENT print ( 3 , 3 ) NEW_LINE DEDENT elif n % 2 == 0 : NEW_LINE INDENT print ( 4 , 4 ) NEW_LINE DEDENT elif n % 2 == 1 : NEW_LINE INDENT print ( 5 , 6 ) NEW_LINE DEDENT elif n % 2 == 0 : NEW_LINE INDENT print ( 6 , 7 ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = n - 2 * m NEW_LINE b = 0 NEW_LINE while a > 0 : NEW_LINE INDENT b += 1 NEW_LINE a -= b NEW_LINE DEDENT print ( a , b ) NEW_LINE
def getMaxNum ( a , b , c ) : NEW_LINE INDENT if ( b % c == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT x = ( ( b // c ) * c ) NEW_LINE if ( x >= a and x <= b ) : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT a = 2 NEW_LINE b = 10 NEW_LINE c = 3 NEW_LINE print ( getMaxNum ( a , b , c ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = n // 12 NEW_LINE b = n - ( a * 12 ) NEW_LINE print ( a , b ) NEW_LINE
c = 0 NEW_LINE def HailstoneNumbers ( N ) : NEW_LINE INDENT print ( N , end = " ▁ " ) NEW_LINE if ( N == 1 and c == 0 ) : NEW_LINE INDENT return c NEW_LINE DEDENT elif ( N == 1 and c != 0 ) : NEW_LINE INDENT c += 1 NEW_LINE return c NEW_LINE DEDENT elif ( N == 1 and c != 0 ) : NEW_LINE INDENT c += 1 NEW_LINE return c NEW_LINE DEDENT elif ( N % 2 == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE HailstoneNumbers ( N // 2 ) NEW_LINE DEDENT elif ( N % 2 != 0 ) : NEW_LINE INDENT c += 1 NEW_LINE HailstoneNumbers ( 3 * N + 1 ) NEW_LINE DEDENT return c NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 7 NEW_LINE x = HailstoneNumbers ( N ) NEW_LINE print ( " Number ▁ of ▁ Steps : " , x ) NEW_LINE DEDENT
class Solution ( object ) : NEW_LINE INDENT def binaryGap ( self , N ) : NEW_LINE INDENT last = - 1 NEW_LINE ans = 0 NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT if ( ( N >> i ) & 1 ) : NEW_LINE INDENT if ( last >= 0 ) : NEW_LINE INDENT ans = max ( ans , i - last ) NEW_LINE last = i NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE N = 22 NEW_LINE out = sObj . binaryGap ( N ) NEW_LINE print ( out ) NEW_LINE DEDENT
s , h , m = map ( int , input ( ) . split ( ) ) NEW_LINE t = h * 60 + m NEW_LINE while t > 0 : NEW_LINE INDENT t -= s NEW_LINE h -= 1 NEW_LINE if t < 0 : h = 23 NEW_LINE print ( h ) NEW_LINE DEDENT
def canFormTeam ( n , m ) : NEW_LINE INDENT if ( n >= 1 and m >= 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( m >= 1 and n >= 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def maxTeams ( n , m ) : NEW_LINE INDENT count = 0 NEW_LINE while ( canFormTeam ( n , m ) ) : NEW_LINE INDENT if ( n > m ) : NEW_LINE INDENT n -= 2 NEW_LINE m -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT m -= 2 NEW_LINE n -= 1 NEW_LINE DEDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE m = 5 NEW_LINE print ( maxTeams ( n , m ) ) NEW_LINE DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res // ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def catalan ( n ) : NEW_LINE INDENT c = binomialCoeff ( 2 * n , n ) NEW_LINE return c // ( n + 1 ) NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT print ( catalan ( i ) , end = " ▁ " ) NEW_LINE DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( 0 , k ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def catalan ( n ) : NEW_LINE INDENT c = binomialCoeff ( 2 * n , n ) NEW_LINE return c // ( n + 1 ) NEW_LINE DEDENT n = 3 NEW_LINE print ( catalan ( n ) ) NEW_LINE
def removeDuplicates ( str ) : NEW_LINE INDENT lhs = set ( ) NEW_LINE for i in str : NEW_LINE INDENT lhs . add ( i ) NEW_LINE DEDENT for i in lhs : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " geeksforgeeks " NEW_LINE removeDuplicates ( str ) NEW_LINE DEDENT
def getPosition ( a , n , m ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT a [ i ] = ( a [ i ] // m + a [ i ] % m ) NEW_LINE DEDENT ans = - 1 NEW_LINE max = - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if max < a [ i ] : NEW_LINE INDENT max = a [ i ] NEW_LINE ans = i NEW_LINE DEDENT DEDENT return ans + 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 2 , 5 , 4 ] NEW_LINE n = len ( a ) NEW_LINE m = 2 NEW_LINE print ( getPosition ( a , n , m ) ) NEW_LINE DEDENT
days = [ 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] NEW_LINE def dayOfYear ( date ) : NEW_LINE INDENT year = int ( date [ 0 : 4 ] ) NEW_LINE month = int ( date [ 5 : 7 ] ) NEW_LINE day = int ( date [ 8 : ] ) NEW_LINE if ( month > 2 and year % 4 == 0 and ( year % 100 != 0 or year % 400 == 0 ) ) : NEW_LINE INDENT day += 1 NEW_LINE DEDENT while ( month > 0 ) : NEW_LINE INDENT day = day + days [ month - 1 ] NEW_LINE month -= 1 NEW_LINE DEDENT return day NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT date = "2019-01-09" NEW_LINE print ( dayOfYear ( date ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n % 2 == 0 : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT print ( i - 1 , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( i + 1 , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 1 , n - 2 ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT print ( i - 1 , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( i + 1 , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( n , n - 2 , n - 1 ) NEW_LINE DEDENT DEDENT
cnt = 0 NEW_LINE graph = [ ] NEW_LINE weight = [ ] NEW_LINE def isPalindrome ( x ) : NEW_LINE INDENT n = len ( x ) NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT if ( x [ i ] != x [ n - 1 - i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def dfs ( node , parent ) : NEW_LINE INDENT x = weight [ node ] NEW_LINE if ( isPalindrome ( x ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT for i in range ( len ( graph [ node ] ) ) : NEW_LINE INDENT if ( graph [ node ] [ i ] == parent ) : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( graph [ node ] [ i ] , node ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT weight . append ( " abc " ) NEW_LINE weight . append ( " aba " ) NEW_LINE weight . append ( " bcb " ) NEW_LINE weight . append ( "
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if a [ 1 ] == a [ 13 ] : NEW_LINE INDENT print ( " no " ) NEW_LINE continue NEW_LINE DEDENT if a [ 1 ] == a [ 13 ] : NEW_LINE INDENT print ( " yes " ) NEW_LINE continue NEW_LINE DEDENT if a [ 1 ] == a [ 8 ] : NEW_LINE INDENT print ( " yes " ) NEW_LINE continue NEW_LINE DEDENT if a [ 1 ] == a [ 6 ] : NEW_LINE INDENT print ( " no " ) NEW_LINE continue NEW_LINE DEDENT if a [ 1 ] == a [ 6 ] : NEW_LINE INDENT print ( " yes " ) NEW_LINE continue NEW_LINE DEDENT if a [ 1 ] == a [ 8 ] : NEW_LINE INDENT print ( " yes " ) NEW_LINE continue NEW_LINE DEDENT if a [ 1 ] == a [ 6 ] : NEW_LINE INDENT print ( " no " ) NEW_LINE continue NEW_LINE DEDENT if a [ 1 ] == a
import sys NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE if N == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT if N == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE return NEW_LINE DEDENT if N == 2 : NEW_LINE INDENT print ( 1 ) NEW_LINE return NEW_LINE DEDENT if N == 3 : NEW_LINE INDENT print ( 1 ) NEW_LINE return NEW_LINE DEDENT if N == 4 : NEW_LINE INDENT print ( 1 ) NEW_LINE return NEW_LINE DEDENT if N == 5 : NEW_LINE INDENT print ( 1 ) NEW_LINE return NEW_LINE DEDENT if N == 6 : NEW_LINE INDENT print ( 1 ) NEW_LINE return NEW_LINE DEDENT if N == 7 : NEW_LINE INDENT print ( 1 ) NEW_LINE return NEW_LINE DEDENT if N == 8 : NEW_LINE INDENT print ( 1 ) NEW_LINE return NEW_LINE DEDENT if N == 9 : NEW_
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = [ ] NEW_LINE e = [ ] NEW_LINE t = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . append ( input ( ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if s [ i ] == s [ j ] : NEW_LINE INDENT e . append ( j ) NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if s [ i ] == s [ j ] : NEW_LINE INDENT ans += 3 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
while True : NEW_LINE INDENT w , h = map ( int , input ( ) . split ( ) ) NEW_LINE if w == 0 : NEW_LINE INDENT break NEW_LINE DEDENT sx , sy = map ( int , input ( ) . split ( ) ) NEW_LINE gx , gy = map ( int , input ( ) . split ( ) ) NEW_LINE n = int ( input ( ) ) NEW_LINE g = [ [ - 1 for i in range ( 105 ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT c , d , x , y = map ( int , input ( ) . split ( ) ) NEW_LINE if d == 1 : NEW_LINE INDENT g [ x ] [ y ] = c NEW_LINE DEDENT elif d == 2 : NEW_LINE INDENT g [ x ] [ y ] = c NEW_LINE DEDENT else : NEW_LINE INDENT g [ x ] [ y ] = c NEW_LINE DEDENT DEDENT if g [ sx ] [ sy ] == - 1 : NEW_LINE INDENT print ( " NG " ) NEW_LINE DEDENT else : NEW_LINE INDENT print
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( a - b , b ) NEW_LINE DEDENT return gcd ( a , b - a ) NEW_LINE DEDENT a = 98 NEW_LINE b = 56 NEW_LINE print ( " GCD ▁ of " , a , " and " , b , " is " , gcd ( a , b ) ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT a = 98 NEW_LINE b = 56 NEW_LINE print ( " GCD ▁ of " , a , " and " , b , " is " , gcd ( a , b ) ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) // gcd ( a , b ) NEW_LINE DEDENT a = 15 NEW_LINE b = 20 NEW_LINE print ( " LCM ▁ of " , a , " and " , b , " is " , lcm ( a , b ) ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) // gcd ( a , b ) NEW_LINE DEDENT a = 15 NEW_LINE b = 20 NEW_LINE print ( " LCM ▁ of " , a , " and " , b , " is " , lcm ( a , b ) ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( a - b , b ) NEW_LINE DEDENT return gcd ( a , b - a ) NEW_LINE DEDENT a = 98 NEW_LINE b = 56 NEW_LINE print ( " GCD ▁ of " , a , " and " , b , " is " , gcd ( a , b ) ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT a = 98 NEW_LINE b = 56 NEW_LINE print ( " GCD ▁ of " , a , " and " , b , " is " , gcd ( a , b ) ) NEW_LINE
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT return str ( tetrationMod ( 1777 , 1855 , eulerlib . pow ( 10 , 8 ) ) ) NEW_LINE DEDENT def tetrationMod ( x , y , m ) : NEW_LINE INDENT if y == 1 : NEW_LINE INDENT return x % m NEW_LINE DEDENT else : NEW_LINE INDENT return eulerlib . pow_mod ( x , tetrationMod ( x , y - 1 , eulerlib . totient ( m ) ) , m ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( tetrationMod ( 1777 , 1855 , eulerlib . pow ( 10 , 8 ) ) ) NEW_LINE DEDENT
def min_sum ( n , k , a ) : NEW_LINE INDENT a . sort ( ) NEW_LINE if ( a [ 0 ] < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT if ( a [ 0 ] == a [ n - 1 ] ) : NEW_LINE INDENT return ( n * a [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT f = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT p = a [ i ] - a [ 0 ] NEW_LINE if ( p % k == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT f = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( f > 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT return ( n * ( a [ 0 ] % k ) ) NEW_LINE DEDENT DEDENT
class ListNode : NEW_LINE INDENT def __init__ ( self , v ) : NEW_LINE INDENT self . val = v NEW_LINE self . next = None NEW_LINE DEDENT DEDENT class Solution ( object ) : NEW_LINE INDENT def removeNthFromEnd ( self , head , n ) : NEW_LINE INDENT slow = head NEW_LINE fast = head NEW_LINE fast = head NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT fast = fast . next NEW_LINE DEDENT if ( fast == None ) : NEW_LINE INDENT head = head . next NEW_LINE return head NEW_LINE DEDENT while ( fast . next != None ) : NEW_LINE INDENT fast = fast . next NEW_LINE slow = slow . next NEW_LINE DEDENT curr = slow . next NEW_LINE slow . next = curr . next NEW_LINE return head NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE nums = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = 2 NEW_LINE head = None NEW_LINE lastNode = None NEW_
def findMaxLenEven ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE i = 0 NEW_LINE currlen = 0 NEW_LINE maxlen = 0 NEW_LINE st = - 1 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( str [ i ] == ' ▁ ' ) : NEW_LINE INDENT if ( currlen % 2 == 0 ) : NEW_LINE INDENT if ( maxlen < currlen ) : NEW_LINE INDENT maxlen = currlen NEW_LINE st = i - currlen NEW_LINE DEDENT DEDENT currlen = 0 NEW_LINE DEDENT else : NEW_LINE INDENT currlen += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( currlen % 2 == 0 ) : NEW_LINE INDENT if ( maxlen < currlen ) : NEW_LINE INDENT maxlen = currlen NEW_LINE st = i - currlen NEW_LINE DEDENT DEDENT if ( st == - 1 ) : NEW_LINE INDENT return " - 1" NEW_LINE DEDENT return str [ st : st + maxlen ] NEW_LINE DEDENT if __name__ ==
def pairsInSortedRotated ( arr , n , x ) : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT l = ( i + 1 ) % n NEW_LINE r = i NEW_LINE cnt = 0 NEW_LINE while ( l != r ) : NEW_LINE INDENT if ( arr [ l ] + arr [ r ] == x ) : NEW_LINE INDENT cnt += 1 NEW_LINE if ( l == ( r - 1 + n ) % n ) : NEW_LINE INDENT return cnt NEW_LINE DEDENT l = ( l + 1 ) % n NEW_LINE r = ( r - 1 + n ) % n NEW_LINE DEDENT elif ( arr [ l ] + arr [ r ] < x ) : NEW_LINE INDENT l = ( l + 1 ) % n NEW_LINE DEDENT else : NEW_LINE INDENT r = ( n + r - 1 ) % n NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 6 NEW_LINE while True : NEW_LINE INDENT n = LIMIT NEW_LINE if ( findLeastDivisibleRepunit ( n ) > LIMIT ) : NEW_LINE INDENT return str ( n ) NEW_LINE DEDENT n += 1 NEW_LINE DEDENT DEDENT def findLeastDivisibleRepunit ( n ) : NEW_LINE INDENT if ( n % 2 == 0 or n % 5 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n > eulerlib . MAX_INT : NEW_LINE INDENT return " Arithmetic ▁ overflow " NEW_LINE DEDENT if ( n > eulerlib . MAX_INT ) : NEW_LINE INDENT return " Arithmetic ▁ overflow " NEW_LINE DEDENT sum = 1 NEW_LINE pow = 1 NEW_LINE k = 1 NEW_LINE while ( sum % n != 0 ) : NEW_LINE INDENT k += 1 NEW_LINE pow = pow * 10 % n NEW_LINE sum = ( sum + pow ) % n NEW_LINE DEDENT return k NEW_LINE DEDENT if __name__ == " _ _ main
def getPassingCars ( A , n ) : NEW_LINE INDENT countOne = 0 NEW_LINE result = 0 NEW_LINE while ( n >= 1 ) : NEW_LINE INDENT if ( A [ n - 1 ] == 1 ) : NEW_LINE INDENT countOne += 1 NEW_LINE DEDENT else : NEW_LINE INDENT result += countOne NEW_LINE DEDENT n -= 1 NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = [ 0 , 1 , 0 , 1 , 1 ] NEW_LINE n = len ( A ) NEW_LINE print ( getPassingCars ( A , n ) ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT for i in range ( 9 , 0 , - 2 ) : NEW_LINE INDENT if not satisfies_conjecture ( i ) : NEW_LINE INDENT return str ( i ) NEW_LINE DEDENT DEDENT DEDENT def satisfies_conjecture ( n ) : NEW_LINE INDENT if n % 2 == 0 or eulerlib . is_prime ( n ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT if eulerlib . is_prime ( n - i * i * 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT a [ i + 1 ] = a [ i ] - max ( 0 , a [ i ] - k ) NEW_LINE if a [ i + 1 ] < 0 : NEW_LINE INDENT print ( " NO " ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT
def findMinRemoval ( arr , n ) : NEW_LINE INDENT value , maximum = 0 , 0 NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( i != 0 and i != n - 1 ) : NEW_LINE INDENT value = value + abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE temp = abs ( arr [ i ] - arr [ i + 1 ] ) + abs ( arr [ i ] - arr [ i - 1 ] ) - abs ( arr [ i - 1 ] - arr [ i + 1 ] ) NEW_LINE DEDENT elif ( i == 0 ) : NEW_LINE INDENT value = value + abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE temp = abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT temp = abs ( arr [ i ] - arr [ i - 1 ] ) NEW_LINE DEDENT maximum = max ( maximum , temp ) NEW_LINE DEDENT return ( value - maximum ) NEW_LINE DEDENT if __name
def find ( n ) : NEW_LINE INDENT arr = [ " " for i in range ( n + 1 ) ] NEW_LINE arr [ 0 ] = " " NEW_LINE size = 1 NEW_LINE m = 1 NEW_LINE while ( size <= n ) : NEW_LINE INDENT for i in range ( 0 , m and ( size + i ) <= n ) : NEW_LINE INDENT arr [ size + i ] = "3" + arr [ size - m + i ] NEW_LINE DEDENT for i in range ( 0 , m and ( size + m + i ) <= n ) : NEW_LINE INDENT arr [ size + m + i ] = "4" + arr [ size - m + i ] NEW_LINE DEDENT m = m << 1 NEW_LINE size = size + m NEW_LINE DEDENT print ( arr [ n ] ) NEW_LINE DEDENT for i in range ( 1 , 16 ) : NEW_LINE INDENT find ( i ) NEW_LINE DEDENT
def maxValue ( a , b ) : NEW_LINE INDENT b . sort ( ) NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE j = m - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( j < 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( b [ j ] > a [ i ] ) : NEW_LINE INDENT a [ i ] = b [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT return a NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = "1234" NEW_LINE b = "4321" NEW_LINE print ( maxValue ( a , b ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE a . append ( x ) NEW_LINE b . append ( y ) NEW_LINE DEDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] [ 0 ] < 0 : NEW_LINE INDENT ans += a [ i ] [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT ans += b [ i ] [ 0 ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
import math NEW_LINE def geometricMean ( arr , n ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT product = product * arr [ i ] NEW_LINE DEDENT gm = math . pow ( product , 1 / n ) NEW_LINE return gm NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( geometricMean ( arr , n ) ) NEW_LINE
def display ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 , 2 ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT print ( j , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE display ( n ) NEW_LINE
def countXorPair ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( ( arr [ i ] ^ arr [ j ] ) % 2 == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countXorPair ( arr , n ) ) NEW_LINE DEDENT
def Square ( n , i , j ) : NEW_LINE INDENT mid = ( i + j ) / 2 NEW_LINE mul = mid * mid NEW_LINE if ( ( mul == n ) or ( abs ( mul - n ) < 0.00001 ) ) : NEW_LINE INDENT return mid NEW_LINE DEDENT elif ( mul < n ) : NEW_LINE INDENT return Square ( n , mid , j ) NEW_LINE DEDENT else : NEW_LINE INDENT return Square ( n , i , mid ) NEW_LINE DEDENT DEDENT def findSqrt ( n ) : NEW_LINE INDENT i = 1 NEW_LINE found = False NEW_LINE while ( not found ) : NEW_LINE INDENT if ( i * i == n ) : NEW_LINE INDENT print ( i ) NEW_LINE found = True NEW_LINE DEDENT elif ( i * i > n ) : NEW_LINE INDENT res = Square ( n , i - 1 , i ) NEW_LINE print ( res ) NEW_LINE found = True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT n = 3 NEW_LINE findSqrt ( n ) NEW_LINE
import sys NEW_LINE from sys import stdin NEW_LINE input = stdin . readline NEW_LINE def main ( args ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE z = 0 NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT for j in range ( i + 1 , 9 ) : NEW_LINE INDENT if a [ i ] + b [ j ] < a [ i ] : NEW_LINE INDENT z += 1 NEW_LINE DEDENT DEDENT DEDENT print ( z ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
def combinationUtil ( arr , data , start , end , index , r ) : NEW_LINE INDENT if ( index == r ) : NEW_LINE INDENT for j in range ( r ) : NEW_LINE INDENT print ( data [ j ] , end = " ▁ " ) ; NEW_LINE DEDENT print ( " " ) ; NEW_LINE return ; NEW_LINE DEDENT for i in range ( start , end , r + 1 ) : NEW_LINE INDENT data [ index ] = arr [ i ] ; NEW_LINE combinationUtil ( arr , data , i + 1 , end , index + 1 , r ) ; NEW_LINE DEDENT DEDENT def printCombination ( arr , n , r ) : NEW_LINE INDENT data = [ 0 ] * r ; NEW_LINE combinationUtil ( arr , data , 0 , n - 1 , 0 , r ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] ; NEW_LINE r = 3 ; NEW_LINE n = len ( arr ) ; NEW_LINE printCombination ( arr , n , r ) ; NEW_LINE DE
def combinationUtil ( arr , n , r , index , data , i ) : NEW_LINE INDENT if ( index == r ) : NEW_LINE INDENT for j in range ( r ) : NEW_LINE INDENT print ( data [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( " " ) NEW_LINE return NEW_LINE DEDENT if ( i >= n ) : NEW_LINE INDENT return NEW_LINE DEDENT data [ index ] = arr [ i ] NEW_LINE combinationUtil ( arr , n , r , index + 1 , data , i + 1 ) NEW_LINE combinationUtil ( arr , n , r , index , data , i + 1 ) NEW_LINE combinationUtil ( arr , n , r , index , data , i + 1 ) NEW_LINE DEDENT def printCombination ( arr , n , r ) : NEW_LINE INDENT data = [ 0 ] * r NEW_LINE combinationUtil ( arr , n , r , 0 , data ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE r = 3 NEW_LINE
def bitwiseAndOdd ( n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 3 , n + 1 , 2 ) : NEW_LINE INDENT result = ( result & i ) NEW_LINE DEDENT return result NEW_LINE DEDENT n = 10 NEW_LINE print ( bitwiseAndOdd ( n ) ) NEW_LINE
def findTangent ( A , x , y ) : NEW_LINE INDENT dif = A - x * 2 NEW_LINE if ( y == ( 2 * x - x * x ) ) : NEW_LINE INDENT if ( dif < 0 ) : NEW_LINE INDENT print ( " y ▁ = " , dif , " x " , ( x * dif + y ) ) NEW_LINE DEDENT elif ( dif > 0 ) : NEW_LINE INDENT print ( " y ▁ = " , dif , " x , - x * dif + y ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ possible " ) NEW_LINE DEDENT DEDENT DEDENT A = 2 NEW_LINE x = 2 NEW_LINE y = 0 NEW_LINE findTangent ( A , x , y ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( max ( a ) - min ( a ) ) NEW_LINE DEDENT
def countRotationsDivBy8 ( n ) : NEW_LINE INDENT len = len ( n ) NEW_LINE count = 0 NEW_LINE if ( len == 1 ) : NEW_LINE INDENT oneDigit = ord ( n [ 0 ] ) - ord ( '0' ) NEW_LINE if ( oneDigit % 8 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( len == 2 ) : NEW_LINE INDENT first = ( ord ( n [ 0 ] ) - ord ( '0' ) ) * 10 + ( ord ( n [ 1 ] ) - ord ( '0' ) ) NEW_LINE second = ( ord ( n [ 1 ] ) - ord ( '0' ) ) * 10 + ( ord ( n [ 0 ] ) - ord ( '0' ) ) NEW_LINE if ( first % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( second % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT threeDigit = ( ord ( n [ len - 1 ] ) - ord ( '0' ) ) * 100 + (
def primeCount ( arr , n ) : NEW_LINE INDENT max_val = max_element ( arr ) NEW_LINE prime = [ True for i in range ( max_val + 1 ) ] NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( max_val ** 0.5 ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT def getPrefixArray ( arr , n , pre ) : NEW_LINE INDENT pre [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + arr [ i ] NEW_LINE DEDENT return pre NEW
def interLeaveQueue ( q ) : NEW_LINE INDENT if ( len ( q ) % 2 != 0 ) : NEW_LINE INDENT print ( " Input ▁ even ▁ number ▁ of ▁ integers . " ) NEW_LINE DEDENT s = [ ] NEW_LINE halfSize = int ( len ( q ) / 2 ) NEW_LINE for i in range ( halfSize ) : NEW_LINE INDENT s . append ( q [ i ] ) NEW_LINE q . pop ( ) NEW_LINE DEDENT for i in range ( halfSize ) : NEW_LINE INDENT q . append ( q [ i ] ) NEW_LINE q . pop ( ) NEW_LINE DEDENT for i in range ( halfSize ) : NEW_LINE INDENT s . append ( q [ i ] ) NEW_LINE q . pop ( ) NEW_LINE DEDENT while ( len ( s ) != 0 ) : NEW_LINE INDENT s . append ( q [ i ] ) NEW_LINE s . pop ( ) NEW_LINE DEDENT while ( len ( s ) != 0 ) : NEW_LINE INDENT q . append ( s [ i ] ) NEW_LINE s . pop ( )
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE for _ in range ( N ) : NEW_LINE INDENT A , B , C = map ( int , input ( ) . split ( ) ) NEW_LINE A -= 1 NEW_LINE B -= 1 NEW_LINE C -= 1 NEW_LINE if A < 0 : NEW_LINE INDENT print ( B ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( C ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def GCD ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return GCD ( b , a % b ) NEW_LINE DEDENT def findRatio ( m , n ) : NEW_LINE INDENT Am = m - 5 NEW_LINE An = n - 5 NEW_LINE numerator = Am // GCD ( Am , An ) NEW_LINE denominator = An // GCD ( Am , An ) NEW_LINE print ( numerator , " / " , denominator ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT m = 10 NEW_LINE n = 20 NEW_LINE findRatio ( m , n ) NEW_LINE DEDENT
import math NEW_LINE M_E = 2.71828182845904523536 NEW_LINE M_PI = 3.141592654 NEW_LINE def findDigits ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT x = ( n * math . log10 ( n / M_E ) + math . log10 ( 2 * M_PI * n ) / 2.0 ) NEW_LINE return int ( math . floor ( x ) + 1 ) NEW_LINE DEDENT print ( findDigits ( 1 ) ) NEW_LINE print ( findDigits ( 50000000 ) ) NEW_LINE print ( findDigits ( 1000000000 ) ) NEW_LINE print ( findDigits ( 120 ) ) NEW_LINE
def find_sum ( n , k ) : NEW_LINE INDENT total_sum = ( n * ( n + 1 ) ) // 2 NEW_LINE power = k NEW_LINE while ( power <= n ) : NEW_LINE INDENT total_sum -= power NEW_LINE power *= k NEW_LINE DEDENT return total_sum NEW_LINE DEDENT n = 11 NEW_LINE k = 2 NEW_LINE print ( find_sum ( n , k ) ) NEW_LINE
import math NEW_LINE def FirstDigit ( arr , n ) : NEW_LINE INDENT S = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT S = S + math . log10 ( arr [ i ] * 1.0 ) NEW_LINE DEDENT fract_S = S - math . floor ( S ) NEW_LINE ans = pow ( 10 , fract_S ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 8 , 3 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( FirstDigit ( arr , n ) ) NEW_LINE DEDENT
def findSum ( arr , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % k == 0 ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT arr = [ 15 , 16 , 10 , 9 , 6 , 7 , 17 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( findSum ( arr , n , k ) ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ 0 ] * n NEW_LINE for i in range ( m ) : NEW_LINE INDENT x , y , z = map ( int , input ( ) . split ( ) ) NEW_LINE a [ x - 1 ] += z NEW_LINE a [ y - 1 ] -= z NEW_LINE DEDENT print ( sum ( a ) // 2 ) NEW_LINE
while True : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 : break NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( int ( input ( ) ) ) NEW_LINE DEDENT for j in range ( m ) : NEW_LINE INDENT b . append ( int ( input ( ) ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if a [ i ] + b [ j ] == a [ i ] + b [ j ] : NEW_LINE INDENT print ( a [ i ] , b [ j ] ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT
class Solution ( object ) : NEW_LINE INDENT def fixedPoint ( self , A ) : NEW_LINE INDENT l = 0 NEW_LINE h = len ( A ) NEW_LINE while ( l <= h ) : NEW_LINE INDENT mid = ( l + h ) // 2 NEW_LINE if ( A [ mid ] > mid ) : NEW_LINE INDENT h = mid - 1 NEW_LINE DEDENT elif ( A [ mid ] < mid ) : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return mid NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE A = [ - 10 , - 5 , 0 , 3 , 7 ] NEW_LINE out = sObj . fixedPoint ( A ) NEW_LINE print ( out ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT l . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT ans += min ( l [ i ] [ j ] , l [ j ] [ i ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def remAnagram ( str1 , str2 ) : NEW_LINE INDENT count1 = [ 0 for i in range ( 26 ) ] NEW_LINE count2 = [ 0 for i in range ( 26 ) ] NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT count1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( str2 ) ) : NEW_LINE INDENT count2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT result += abs ( count1 [ i ] - count2 [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str1 = " bcadeh " NEW_LINE str2 = " hea " NEW_LINE print ( remAnagram ( str1 , str2 ) ) NEW_LINE DEDENT
import math NEW_LINE def polyarea ( n , r ) : NEW_LINE INDENT if ( r < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = ( ( r * r * n ) * math . sin ( ( 360 / n ) * 3.14159 / 180 ) ) / 2 NEW_LINE return A NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT r = 9 NEW_LINE n = 6 NEW_LINE print ( " % . 3f " % polyarea ( n , r ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT s = input ( ) NEW_LINE a = set ( s ) NEW_LINE if len ( a ) == 1 or len ( s ) == 1 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT if len ( a ) == 1 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT
def surfaceArea ( b , s ) : NEW_LINE INDENT return 2 * b * s + pow ( b , 2 ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT b = 3 ; s = 4 ; NEW_LINE print ( surfaceArea ( b , s ) ) ; NEW_LINE DEDENT
MAX = 1000 NEW_LINE cur = 0 NEW_LINE dig = 0 NEW_LINE sum = [ 0 ] * MAX NEW_LINE dp = [ [ 0 for i in range ( 3 ) ] for j in range ( MAX ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , len ( s ) + 1 ) : NEW_LINE INDENT dig = ord ( s [ i - 1 ] ) - 48 NEW_LINE cur += dig NEW_LINE cur %= 3 NEW_LINE sum [ i ] = cur NEW_LINE dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] NEW_LINE dp [ i ] [ 1 ] = dp [ i - 1 ] [ 1 ] NEW_LINE dp [ i ] [ 2 ] = dp [ i - 1 ] [ 2 ] NEW_LINE dp [ i ] [ sum [ i ] ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE dprev = 0 NEW_LINE value = 0 NEW_LINE dprev2 = 0 NEW_LINE for i in range ( 1 , len ( s ) + 1 ) : NEW_LINE INDENT dig = ord ( s [ i - 1 ] )
def sieve ( maxm , prime ) : NEW_LINE INDENT prime [ 0 ] = prime [ 1 ] = 1 NEW_LINE for i in range ( 2 , int ( maxm ** 0.5 ) + 1 ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( 2 * i , maxm + 1 , i ) : NEW_LINE INDENT prime [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def countPair ( a , n ) : NEW_LINE INDENT maxm = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] > maxm ) : NEW_LINE INDENT maxm = a [ i ] NEW_LINE DEDENT DEDENT prime = [ 0 ] * ( maxm + 1 ) NEW_LINE sieve ( maxm , prime ) NEW_LINE countPrimes = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( prime [ a [ i ] ] == 0 ) : NEW_LINE INDENT countPrimes += 1 NEW_LINE DEDENT DEDENT nonPrimes = n - count
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE count = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if s [ i ] == s [ i + 1 ] and s [ i ] == s [ i + 2 ] : NEW_LINE INDENT count += 1 NEW_LINE i += 3 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE
def sortString ( s ) : NEW_LINE INDENT arr = sorted ( s ) NEW_LINE print ( arr ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE sortString ( s ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE print ( n ) NEW_LINE print ( * [ i + 1 for i in range ( n ) ] ) NEW_LINE DEDENT
def printNumber ( n ) : NEW_LINE INDENT count = [ 0 for i in range ( 10 ) ] NEW_LINE while ( n > 0 ) : NEW_LINE INDENT count [ n % 10 ] += 1 NEW_LINE n //= 10 NEW_LINE DEDENT for i in range ( 1 , 10 ) : NEW_LINE INDENT for j in range ( count [ i ] * i ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT DEDENT n = 3225 NEW_LINE printNumber ( n ) NEW_LINE
def maxPrimefactorNum ( N ) : NEW_LINE INDENT arr = [ 0 for i in range ( N + 1 ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( arr [ i ] > max ) : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT def maxPrimefactorNum ( N ) : NEW_LINE INDENT arr = [ 0 for i in range ( N + 1 ) ] NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT for j in range ( 2 * i , N + 1 , i ) : NEW_LINE INDENT arr [ j ] += 1 NEW_LINE DEDENT DEDENT arr [ i ] = 1 NEW_LINE DEDENT return getMax ( arr ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 40 NEW_LINE print ( maxPrimefactorNum ( N ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( l . count ( min ( l ) ) ) NEW_LINE print ( n ) NEW_LINE
