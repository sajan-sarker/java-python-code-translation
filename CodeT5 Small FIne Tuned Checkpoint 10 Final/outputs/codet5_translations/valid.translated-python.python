def calculateSquareSum ( n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT fibo = [ 0 ] * ( n + 1 ) NEW_LINE fibo [ 0 ] = 0 NEW_LINE fibo [ 1 ] = 1 NEW_LINE sum = ( fibo [ 0 ] * fibo [ 0 ] ) + ( fibo [ 1 ] * fibo [ 1 ] ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] NEW_LINE sum += ( fibo [ i ] * fibo [ i ] ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 6 NEW_LINE print ( " Sum ▁ of ▁ squares ▁ of ▁ Fibonacci ▁ numbers ▁ is ▁ : " , calculateSquareSum ( n ) ) NEW_LINE
s1 = input ( ) NEW_LINE s2 = input ( ) NEW_LINE k = int ( input ( ) ) NEW_LINE if s1 == s2 : NEW_LINE INDENT print ( 0 ) NEW_LINE exit ( ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , len ( s1 ) ) : NEW_LINE INDENT if s1 [ i ] == s2 [ i ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT if k % 2 == 0 : NEW_LINE INDENT ans %= 1000000007 NEW_LINE DEDENT else : NEW_LINE INDENT ans %= 1000000007 NEW_LINE DEDENT print ( ans ) NEW_LINE
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . append ( list ( input ( ) . split ( ) ) ) NEW_LINE DEDENT s . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if s [ j ] [ 0 ] == s [ j ] [ 1 ] : NEW_LINE INDENT print ( s [ j ] [ 0 ] , s [ j ] [ 1 ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if a [ i ] == 0 and a [ i - 1 ] == 1 and a [ i + 1 ] == 1 : NEW_LINE INDENT ans += 1 NEW_LINE if i <= n - 4 : NEW_LINE INDENT if a [ i + 2 ] == 1 and a [ i + 3 ] == 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
def val ( c ) : NEW_LINE INDENT if ( c >= '0' and c <= '9' ) : NEW_LINE INDENT return ord ( c ) - ord ( '0' ) NEW_LINE DEDENT else : NEW_LINE INDENT return ord ( c ) - ord ( ' A ' ) + 10 NEW_LINE DEDENT DEDENT def toDeci ( str , base ) : NEW_LINE INDENT len = len ( str ) NEW_LINE power = 1 NEW_LINE num = 0 NEW_LINE for i in range ( len - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( val ( str [ i ] ) >= base ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT num += val ( str [ i ] ) * power NEW_LINE power = power * base NEW_LINE DEDENT return num NEW_LINE DEDENT def checkCorrespond ( str , x ) : NEW_LINE INDENT counter = 0 NEW_LINE n = len ( str ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 2 , 36 ) : NEW_LINE INDENT if ( toDeci ( str [ i ] , j ) == x
s = input ( ) NEW_LINE a = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT a . append ( int ( s [ i ] ) ) NEW_LINE DEDENT for i in range ( len ( s ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if s [ i ] == '0' : NEW_LINE INDENT a . append ( int ( s [ i ] ) ) NEW_LINE DEDENT DEDENT print ( max ( a ) ) NEW_LINE
n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > b [ i ] : NEW_LINE INDENT print ( " YES " ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
import heapq NEW_LINE from collections import deque NEW_LINE from enum import Enum NEW_LINE import sys NEW_LINE import math NEW_LINE from _heapq import heappush , heappop NEW_LINE import copy NEW_LINE BIG_NUM = 2000000000 NEW_LINE HUGE_NUM = 99999999999999999 NEW_LINE MOD = 1000000007 NEW_LINE EPS = 0.000000001 NEW_LINE sys . setrecursionlimit ( 100000 ) NEW_LINE N = int ( input ( ) ) NEW_LINE A = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE A . append ( ( a , b ) ) NEW_LINE DEDENT A . sort ( ) NEW_LINE S = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT S += A [ i ] [ 0 ] NEW_LINE while S < S : NEW_LINE INDENT S -= A [ i ] [ 0 ] NEW_LINE S -= A [ i ] [ 1 ] NEW_LINE DEDENT if S > S : NEW_LINE INDENT S = S NEW_LINE
def maxDivide ( a , b ) : NEW_LINE INDENT while ( a % b == 0 ) : NEW_LINE INDENT a = a // b NEW_LINE DEDENT return a NEW_LINE DEDENT def isUgly ( no ) : NEW_LINE INDENT no = maxDivide ( no , 2 ) NEW_LINE no = maxDivide ( no , 3 ) NEW_LINE no = maxDivide ( no , 5 ) NEW_LINE return ( no == 1 ) NEW_LINE DEDENT def getNthUglyNo ( n ) : NEW_LINE INDENT i = 1 NEW_LINE count = 1 NEW_LINE while ( n > count ) : NEW_LINE INDENT i += 1 NEW_LINE if ( isUgly ( i ) == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return i NEW_LINE DEDENT no = getNthUglyNo ( 150 ) NEW_LINE print ( " 150th ▁ ugly ▁ no . ▁ is " , no ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l [ i ] > l [ i ] : NEW_LINE INDENT print ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT
import math NEW_LINE def perfectSquares ( l , r ) : NEW_LINE INDENT number = math . ceil ( math . sqrt ( l ) ) NEW_LINE n2 = number * number NEW_LINE number = ( number * 2 ) + 1 NEW_LINE while ( ( n2 >= l and n2 <= r ) ) : NEW_LINE INDENT print ( n2 , end = " ▁ " ) NEW_LINE n2 = n2 + number NEW_LINE number += 2 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l = 2 NEW_LINE r = 24 NEW_LINE perfectSquares ( l , r ) NEW_LINE DEDENT
import math NEW_LINE def CheckArray ( arr , n ) : NEW_LINE INDENT prod = 1 NEW_LINE freq = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq . append ( arr [ i ] ) NEW_LINE prod *= arr [ i ] NEW_LINE DEDENT root = int ( math . sqrt ( prod ) ) NEW_LINE if ( root * root == prod ) : NEW_LINE INDENT if ( freq . contains ( root ) and freq . lastIndexOf ( root ) != ( len ( freq ) ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 12 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE if ( CheckArray ( arr , n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def findNumbers ( N ) : NEW_LINE INDENT i = 1 NEW_LINE while ( i <= N ) : NEW_LINE INDENT print ( ( i * i * i ) , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT N = 4 NEW_LINE findNumbers ( N ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if a [ i ] + a [ j ] < m : NEW_LINE INDENT m -= a [ i ] + a [ j ] NEW_LINE a [ j ] = i NEW_LINE DEDENT DEDENT DEDENT print ( ' NA ' ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE if a [ 0 ] == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif a [ - 1 ] == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 0 : NEW_LINE INDENT print ( i + 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT print ( a [ 0 ] + a [ - 1 ] ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] != a [ i ] : NEW_LINE INDENT ans += abs ( a [ i ] - a [ i ] ) NEW_LINE DEDENT if a [ i ] != a [ i ] : NEW_LINE INDENT ans += abs ( a [ i ] - a [ i ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = len ( input ( ) ) NEW_LINE d = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT d [ ord ( input ( ) ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT DEDENT d = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT d [ ord ( input ( ) ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT d [ ord ( input ( ) ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if d [ i ] [ j ] == 1 : NEW_LINE INDENT ans += d [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
def countIntervals ( arr , V , N ) : NEW_LINE INDENT count = 0 NEW_LINE li = ri = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT li = arr [ i ] [ 0 ] NEW_LINE ri = arr [ i ] [ 1 ] NEW_LINE if ( V >= li and V <= ri ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ [ 1 , 10 ] , [ 5 , 10 ] , [ 15 , 25 ] , [ 7 , 12 ] , [ 20 , 25 ] ] NEW_LINE V = 7 NEW_LINE N = len ( arr ) NEW_LINE print ( countIntervals ( arr , V , N ) ) NEW_LINE
def msbPos ( n ) : NEW_LINE INDENT msb_p = - 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = n >> 1 NEW_LINE msb_p += 1 NEW_LINE DEDENT return msb_p NEW_LINE DEDENT def andOperator ( x , y ) : NEW_LINE INDENT res = 0 NEW_LINE while ( x > 0 and y > 0 ) : NEW_LINE INDENT msb_p1 = msbPos ( x ) NEW_LINE msb_p2 = msbPos ( y ) NEW_LINE if ( msb_p1 != msb_p2 ) : NEW_LINE INDENT break NEW_LINE DEDENT msb_val = ( 1 << msb_p1 ) NEW_LINE res = res + msb_val NEW_LINE x = x - msb_val NEW_LINE y = y - msb_val NEW_LINE DEDENT return res NEW_LINE DEDENT x = 10 NEW_LINE y = 15 NEW_LINE print ( andOperator ( x , y ) ) NEW_LINE
def lengthOfLastWord ( a ) : NEW_LINE INDENT char_flag = False NEW_LINE len = 0 NEW_LINE for i in range ( len ( a ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if a [ i ] . isupper ( ) : NEW_LINE INDENT char_flag = True NEW_LINE len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if char_flag == True : NEW_LINE INDENT return len NEW_LINE DEDENT DEDENT DEDENT return len NEW_LINE DEDENT input = " Geeks ▁ For ▁ Geeks ▁ " NEW_LINE print ( " The ▁ length ▁ of ▁ last ▁ word ▁ is " , lengthOfLastWord ( input ) ) NEW_LINE
import math NEW_LINE r , x , y = map ( int , input ( ) . split ( ) ) NEW_LINE n = int ( input ( ) ) NEW_LINE p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE p . sort ( ) NEW_LINE s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s += p [ i ] NEW_LINE s += p [ i ] NEW_LINE s += p [ i ] NEW_LINE DEDENT print ( " ▁ " . join ( [ str ( math . pi * r ) * math . sin ( r ) * math . cos ( r ) * math . sin ( r ) * math . sin ( r ) * math . cos ( r ) * math . sin ( r ) * math . sin ( r ) * math . cos ( r ) * math . sin ( r ) * math . sin ( r ) * math . cos ( r ) * math . sin ( r ) * math . sin ( r ) * math . sin ( r ) * math . sin ( r ) * math . cos ( r ) * math . sin ( r ) * math .
def partSort ( arr , N , a , b ) : NEW_LINE INDENT l = min ( a , b ) NEW_LINE r = max ( a , b ) NEW_LINE temp = [ 0 ] * ( r - l + 1 ) NEW_LINE j = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT temp . sort ( ) NEW_LINE j = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT arr [ i ] = temp [ j ] NEW_LINE j += 1 NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 7 , 8 , 4 , 5 , 2 ] NEW_LINE a = 1 NEW_LINE b = 4 NEW_LINE N = len ( arr ) NEW_LINE partSort ( arr , N , a , b ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if a [ i ] ** 2 != a [ i + 1 ] ** 2 : NEW_LINE INDENT print ( a [ i ] ) NEW_LINE break NEW_LINE DEDENT DEDENT
def countSolutions ( a ) : NEW_LINE INDENT count = bitCount ( a ) NEW_LINE count = pow ( 2 , count ) NEW_LINE return count NEW_LINE DEDENT a = 3 NEW_LINE print ( countSolutions ( a ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( n * ( n + 1 ) ) // 2 ) NEW_LINE DEDENT
import math NEW_LINE N = 1000005 NEW_LINE MAX = 1e18 NEW_LINE powers = [ ] NEW_LINE s = [ ] NEW_LINE def powersPrecomputation ( ) : NEW_LINE INDENT for i in range ( 2 , N ) : NEW_LINE INDENT squares . append ( i * i ) NEW_LINE if i in squares : NEW_LINE INDENT continue NEW_LINE DEDENT temp = i NEW_LINE while i * i <= MAX // temp : NEW_LINE INDENT temp *= ( i * i ) NEW_LINE s . append ( temp ) NEW_LINE DEDENT DEDENT for x in s : NEW_LINE INDENT powers . append ( x ) NEW_LINE DEDENT DEDENT def calculateAnswer ( L , R ) : NEW_LINE INDENT powersPrecomputation ( ) NEW_LINE perfectSquares = ( math . floor ( math . sqrt ( R ) ) - math . floor ( math . sqrt ( L - 1 ) ) ) NEW_LINE high = powers [ R ] NEW_LINE low = powers [ L ] NEW_LINE perfectPowers = perfectSquares + ( high - low ) NEW_LINE ans = ( R - L + 1
dp = [ [ 0 for i in range ( 1000 ) ] for j in range ( 1000 ) ] NEW_LINE def sum ( a , i , j ) : NEW_LINE INDENT ans = 0 NEW_LINE for m in range ( i , j + 1 ) : NEW_LINE INDENT ans = ( ans + a [ m ] ) % 100 NEW_LINE DEDENT return ans NEW_LINE DEDENT def solve ( a , i , j ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT dp [ i ] [ j ] = 100000000 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , ( solve ( a , i , k ) + solve ( a , k + 1 , j ) + solve ( a , k + 1 , j ) + ( sum ( a , i , k ) * sum ( a , k + 1 , j ) ) ) NEW_LINE DEDENT return
def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE return NEW_LINE DEDENT def printSequencesRecur ( arr , n , k , index ) : NEW_LINE INDENT if ( k == 0 ) : NEW_LINE INDENT printArray ( arr , index ) NEW_LINE DEDENT if ( k > 0 ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT arr [ index ] = i NEW_LINE printSequencesRecur ( arr , n , k - 1 , index + 1 ) NEW_LINE DEDENT DEDENT DEDENT def printSequences ( n , k ) : NEW_LINE INDENT arr = [ 0 ] * k NEW_LINE printSequencesRecur ( arr , n , k , 0 ) NEW_LINE return NEW_LINE DEDENT n = 3 NEW_LINE k = 2 NEW_LINE printSequences ( n , k ) NEW_LINE
a = 0 NEW_LINE b = 0 NEW_LINE c = 0 NEW_LINE while True : NEW_LINE INDENT try : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( " , " ) ) NEW_LINE DEDENT except : NEW_LINE INDENT break NEW_LINE DEDENT if a * a + b * b == c * c : NEW_LINE INDENT a += 1 NEW_LINE DEDENT if a == b : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( a ) NEW_LINE print ( b ) NEW_LINE
def maxValue ( a , n ) : NEW_LINE INDENT first = dict ( ) NEW_LINE last = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT first [ a [ i ] ] = 0 NEW_LINE last [ a [ i ] ] = 0 NEW_LINE DEDENT pr = [ 0 ] * n NEW_LINE pr [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pr [ i ] = pr [ i - 1 ] + a [ i ] NEW_LINE if ( first [ a [ i ] ] == 0 ) : NEW_LINE INDENT first [ a [ i ] ] = i NEW_LINE DEDENT last [ a [ i ] ] = i NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT start = int ( first [ a [ i ] ] ) NEW_LINE end = int ( last [ a [ i ] ] ) NEW_LINE if ( start != 0 ) : NEW_LINE INDENT ans = max ( ans , pr [ end ] - pr [ start - 1 ] ) NEW_LINE DEDENT DEDENT return ans NEW_
def getPairs ( a , n ) : NEW_LINE INDENT visited1 = set ( ) NEW_LINE un = set ( ) NEW_LINE un [ n - 1 ] = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT if ( visited1 . add ( a [ i ] ) ) : NEW_LINE INDENT un [ i - 1 ] = count NEW_LINE DEDENT else : NEW_LINE INDENT un [ i - 1 ] = count NEW_LINE DEDENT count += 1 NEW_LINE DEDENT visited2 = set ( ) NEW_LINE answer = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( visited2 . add ( a [ i ] ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT answer += un [ i ] NEW_LINE visited2 . add ( a [ i ] ) NEW_LINE DEDENT return answer NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 2 , 2 , 4 , 2 , 5 , 3 , 5 ] NEW_LINE n = len ( a )
def isTwoAlter ( s ) : NEW_LINE INDENT for i in range ( len ( s ) - 2 ) : NEW_LINE INDENT if ( s [ i ] != s [ i + 2 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if ( s [ 0 ] == s [ 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " ABAB " NEW_LINE if ( isTwoAlter ( str ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def findRemainder ( n ) : NEW_LINE INDENT l = n % 10 NEW_LINE while ( n >= 10 ) : NEW_LINE INDENT n //= 10 NEW_LINE DEDENT f = n NEW_LINE remainder = f % l NEW_LINE print ( remainder ) NEW_LINE DEDENT n = 5223 NEW_LINE findRemainder ( n ) NEW_LINE
n = int ( input ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( " Sheldon " ) NEW_LINE DEDENT elif n == 2 : NEW_LINE INDENT print ( " Leonard " ) NEW_LINE DEDENT elif n == 3 : NEW_LINE INDENT print ( " Penny " ) NEW_LINE DEDENT elif n == 4 : NEW_LINE INDENT print ( " Rajesh " ) NEW_LINE DEDENT elif n == 5 : NEW_LINE INDENT print ( " Penny " ) NEW_LINE DEDENT elif n == 6 : NEW_LINE INDENT print ( " Rajesh " ) NEW_LINE DEDENT elif n == 7 : NEW_LINE INDENT print ( " Sheldon " ) NEW_LINE DEDENT elif n == 8 : NEW_LINE INDENT print ( " Penny " ) NEW_LINE DEDENT elif n == 9 : NEW_LINE INDENT print ( " Rajesh " ) NEW_LINE DEDENT elif n == 9 : NEW_LINE INDENT print ( " Sheldon " ) NEW_LINE DEDENT elif n == 9 : NEW_LINE INDENT print ( " Penny " ) NEW_LINE DEDENT
def findSumofEle ( arr1 , m , arr2 , n , k ) : NEW_LINE INDENT arraySum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT arraySum += arr2 [ i ] NEW_LINE DEDENT mean = arraySum / n NEW_LINE sumOfElements = 0 NEW_LINE difference = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT difference = arr1 [ i ] - mean NEW_LINE if ( ( difference < 0 ) and ( k > ( - 1 ) * difference ) ) : NEW_LINE INDENT sumOfElements += arr1 [ i ] NEW_LINE DEDENT if ( ( difference >= 0 ) and ( k > difference ) ) : NEW_LINE INDENT sumOfElements += arr1 [ i ] NEW_LINE DEDENT DEDENT return sumOfElements NEW_LINE DEDENT arr1 = [ 1 , 2 , 3 , 4 , 7 , 9 ] NEW_LINE arr2 = [ 0 , 1 , 2 , 1 , 1 , 4 ] NEW_LINE k = 2 NEW_LINE m = len ( arr1 ) NEW_LINE n = len ( arr2 ) NEW_LINE print ( findSumofEle
def CountWays ( n , flag ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT sum = 0 NEW_LINE if ( flag == False and n > 1 ) : NEW_LINE INDENT sum = sum + CountWays ( n - 1 , False ) + CountWays ( n - 2 , True ) NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + CountWays ( n - 1 , False ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 5 NEW_LINE print ( CountWays ( n , False ) ) NEW_LINE
def MaxSumDifference ( a , n ) : NEW_LINE INDENT finalSequence = [ ] NEW_LINE a . sort ( ) NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT finalSequence . append ( a [ i ] ) NEW_LINE finalSequence . append ( a [ n - i - 1 ] ) NEW_LINE DEDENT if ( n % 2 != 0 ) : NEW_LINE INDENT finalSequence . append ( a [ n // 2 ] ) NEW_LINE DEDENT MaximumSum = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT MaximumSum = MaximumSum + abs ( finalSequence [ i ] - finalSequence [ i + 1 ] ) NEW_LINE DEDENT MaximumSum = MaximumSum + abs ( finalSequence [ n - 1 ] - finalSequence [ 0 ] ) NEW_LINE return MaximumSum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 2 , 4 , 8 ] NEW_LINE n = len ( a ) NEW_LINE print ( MaxSumDifference ( a , n ) ) NEW_LINE DEDENT
def reverse ( n ) : NEW_LINE INDENT rev = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT d = n % 10 NEW_LINE rev = rev * 10 + d NEW_LINE n = n // 10 NEW_LINE DEDENT return rev NEW_LINE DEDENT def isPalin ( n ) : NEW_LINE INDENT return ( n == reverse ( n ) ) NEW_LINE DEDENT def countDigits ( n ) : NEW_LINE INDENT c = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = n // 10 NEW_LINE c += 1 NEW_LINE DEDENT return c NEW_LINE DEDENT def countPalinDigits ( arr , n ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < 10 or isPalin ( arr [ i ] ) ) : NEW_LINE INDENT s += countDigits ( arr [ i ] ) NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT arr = [ 121 , 56 , 434 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPalinDigits ( arr , n )
def lenoflongestnonpalindrome ( s ) : NEW_LINE INDENT max1 = 1 NEW_LINE len = 0 NEW_LINE new_str = input ( ) NEW_LINE for i in range ( len - 1 ) : NEW_LINE INDENT if ( new_str [ i ] == new_str [ i + 1 ] ) : NEW_LINE INDENT len = 0 NEW_LINE DEDENT elif ( i > 0 and ( new_str [ i + 1 ] == new_str [ i - 1 ] ) ) : NEW_LINE INDENT len = 1 NEW_LINE DEDENT else : NEW_LINE INDENT len += 1 NEW_LINE DEDENT max1 = max ( max1 , len + 1 ) NEW_LINE DEDENT if ( max1 == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return max1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " synapse " NEW_LINE print ( lenoflongestnonpalindrome ( s ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if a [ i ] == 0 : NEW_LINE INDENT a [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT a [ i ] = 1 NEW_LINE DEDENT DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT if a [ i ] == 0 : NEW_LINE INDENT a [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT a [ i ] = 1 NEW_LINE DEDENT DEDENT print ( * a ) NEW_LINE DEDENT
def ellipse ( l , b ) : NEW_LINE INDENT if ( l < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = ( 3.14 * l * b ) / 4 NEW_LINE return x NEW_LINE DEDENT a = 5 NEW_LINE b = 3 NEW_LINE print ( ellipse ( a , b ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if len ( b ) % 2 == 1 : NEW_LINE INDENT print ( a [ 0 ] ) NEW_LINE DEDENT elif len ( b ) % 2 == 1 : NEW_LINE INDENT print ( b [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT if len ( b ) % 2 == 1 : NEW_LINE INDENT print ( a [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a [ 1 ] ) NEW_LINE DEDENT DEDENT
def alternate ( a , b , x ) : NEW_LINE INDENT return x = a ^ b ^ x NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = - 10 NEW_LINE b = 15 NEW_LINE x = a NEW_LINE print ( " x ▁ is ▁ : " , x ) NEW_LINE x = alternate ( a , b , x ) NEW_LINE print ( " After ▁ exchange ▁ " , x ) NEW_LINE print ( " x ▁ is ▁ : " , x ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT DEDENT for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT DEDENT a . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in a : NEW_LINE INDENT if i % i == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
x1 = 1 NEW_LINE x2 = 3 NEW_LINE x3 = 6 NEW_LINE y1 = 2 NEW_LINE y2 = - 4 NEW_LINE y3 = - 7 NEW_LINE x = ( x1 + x2 + x3 ) / 3 NEW_LINE y = ( y1 + y2 + y3 ) / 3 NEW_LINE print ( " Centroid ▁ = ▁ ( " , x , " , " , y , " ) " ) NEW_LINE
def areElementsContiguous ( arr , n ) : NEW_LINE INDENT max = sys . maxsize NEW_LINE min = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT max = max ( max , arr [ i ] ) NEW_LINE min = min ( min , arr [ i ] ) NEW_LINE DEDENT m = max - min + 1 NEW_LINE if ( m > n ) : NEW_LINE INDENT return False NEW_LINE DEDENT visited = [ False ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT visited [ arr [ i ] - min ] = True NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT if ( visited [ i ] == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE if ( areElementsContiguous ( arr , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_
def count_ ( count , e ) : NEW_LINE INDENT hash = [ False ] * 10 NEW_LINE while ( e > 0 ) : NEW_LINE INDENT if ( hash [ e % 10 ] == False ) : NEW_LINE INDENT count [ e % 10 ] += 1 NEW_LINE DEDENT hash [ e % 10 ] = True NEW_LINE e //= 10 NEW_LINE DEDENT DEDENT def find_subsequence ( arr , n ) : NEW_LINE INDENT count = [ 0 ] * 10 NEW_LINE for i in range ( n ) : NEW_LINE INDENT count_ ( count , arr [ i ] ) NEW_LINE DEDENT longest = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT longest = max ( count [ i ] , longest ) NEW_LINE DEDENT print ( longest ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 11 , 12 , 23 , 74 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE find_subsequence ( arr , n ) NEW_LINE DEDENT
MAXN = 1000001 NEW_LINE spf = [ 0 ] * MAXN NEW_LINE def sieve ( ) : NEW_LINE INDENT for i in range ( 1 , MAXN ) : NEW_LINE INDENT spf [ i ] = i NEW_LINE DEDENT for i in range ( 4 , MAXN , 2 ) : NEW_LINE INDENT spf [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , int ( MAXN ** 0.5 ) , 2 ) : NEW_LINE INDENT if ( spf [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , MAXN , i ) : NEW_LINE INDENT if ( spf [ j ] == j ) : NEW_LINE INDENT spf [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def countSubArray ( arr , n ) : NEW_LINE INDENT ind = [ - 1 ] * MAXN NEW_LINE count = 0 NEW_LINE last_ind = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( arr [ i ] > 1 ) : NEW_LINE INDENT div = spf [ arr [ i ]
N = 3 NEW_LINE def multiply ( mat , res ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT res [ i ] [ j ] = 0 NEW_LINE for k in range ( N ) : NEW_LINE INDENT res [ i ] [ j ] += mat [ i ] [ k ] * mat [ k ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT def InvolutoryMatrix ( mat ) : NEW_LINE INDENT res = [ [ 0 for i in range ( N ) ] for j in range ( N ) ] NEW_LINE multiply ( mat , res ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( i == j and res [ i ] [ j ] != 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( i != j and res [ i ] [ j ] != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT mat = [ [ 1 , 0 , 0 ] , [ 0 , - 1
def first ( n ) : NEW_LINE INDENT a = n NEW_LINE c = 1 NEW_LINE while ( a != 0 ) : NEW_LINE INDENT a //= 10 NEW_LINE c = c * 10 NEW_LINE DEDENT c = c // 10 NEW_LINE fi = n // c NEW_LINE return fi NEW_LINE DEDENT def prime ( n ) : NEW_LINE INDENT if ( n == 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( n == 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( n == 5 ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( n == 7 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def check ( n , k ) : NEW_LINE INDENT l = n % 10 NEW_LINE f = first ( n ) NEW_LINE lp = prime ( l ) NEW_LINE fp = prime ( f ) NEW_LINE if ( lp and fp ) : NEW_LINE INDENT if ( l + f < k ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE
import math NEW_LINE def lengthSquare ( p1 , p2 ) : NEW_LINE INDENT xDiff = p1 . x - p2 . x NEW_LINE yDiff = p1 . y - p2 . y NEW_LINE return xDiff * xDiff + yDiff * yDiff NEW_LINE DEDENT def printAngle ( A , B , C ) : NEW_LINE INDENT a2 = lengthSquare ( B , C ) NEW_LINE b2 = lengthSquare ( A , B ) NEW_LINE c = lengthSquare ( A , B ) NEW_LINE a = sqrt ( a2 ) NEW_LINE b = sqrt ( b2 ) NEW_LINE c = sqrt ( c2 ) NEW_LINE alpha = acos ( ( b2 + c2 - a2 ) / ( 2 * b * c ) ) NEW_LINE betta = acos ( ( a2 + c2 - b2 ) / ( 2 * a * c ) ) NEW_LINE gamma = acos ( ( a2 + b2 - c2 ) / ( 2 * a * b ) ) NEW_LINE alpha = acos ( ( a2 + c2 - b2 ) / ( 2 * a * c
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for j in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if a [ j ] != a [ j + 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def maxEvenSum ( arr , n ) : NEW_LINE INDENT pos_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT pos_sum += arr [ i ] NEW_LINE DEDENT DEDENT if ( pos_sum % 2 == 0 ) : NEW_LINE INDENT return pos_sum NEW_LINE DEDENT ans = - 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 != 0 ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT ans = ans > ( pos_sum - arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = ( pos_sum + arr [ i ] ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT a = [ - 2 , 2 , - 3 , 1 ] NEW_LINE print ( maxEvenSum ( a , len ( a ) ) ) NEW_LINE
def xorOfArray ( arr , n ) : NEW_LINE INDENT xor_arr = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xor_arr = xor_arr ^ arr [ i ] NEW_LINE DEDENT return xor_arr NEW_LINE DEDENT arr = [ 3 , 9 , 12 , 13 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( xorOfArray ( arr , n ) ) NEW_LINE
def updateFreq ( n , freq ) : NEW_LINE INDENT while ( n > 0 ) : NEW_LINE INDENT digit = n % TEN NEW_LINE freq [ digit ] += 1 NEW_LINE n //= TEN NEW_LINE DEDENT DEDENT def areAnagrams ( a , b ) : NEW_LINE INDENT freqA = [ 0 ] * TEN NEW_LINE freqB = [ 0 ] * TEN NEW_LINE updateFreq ( a , freqA ) NEW_LINE updateFreq ( b , freqB ) NEW_LINE for i in range ( TEN ) : NEW_LINE INDENT if ( freqA [ i ] != freqB [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT a = 204 NEW_LINE b = 240 NEW_LINE if ( areAnagrams ( a , b ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def evenFib ( n ) : NEW_LINE INDENT if ( n < 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) NEW_LINE DEDENT n = 7 NEW_LINE print ( evenFib ( n ) ) NEW_LINE
import math NEW_LINE def minOperations ( N ) : NEW_LINE INDENT x = math . log ( N ) / math . log ( 2 ) NEW_LINE ans = int ( math . ceil ( x ) ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 10 NEW_LINE print ( minOperations ( N ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE t , a = [ ] , [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT t . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i - 1 ] , ( t [ i - 1 ] + t [ i ] - 1 ) // t [ i ] ) NEW_LINE dp [ i ] = max ( dp [ i ] , ( a [ i - 1 ] + a [ i ] - 1 ) // a [ i ] ) NEW_LINE DEDENT print ( dp [ n - 1 ] ) NEW_LINE
def check ( k , d0 , d1 ) : NEW_LINE INDENT s = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 6 * ( d0 + d1 ) ) % 10 NEW_LINE a = ( k - 3 ) % 4 NEW_LINE x = 0 NEW_LINE if a == 0 : NEW_LINE INDENT x = 0 NEW_LINE DEDENT elif a == 1 : NEW_LINE INDENT x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 NEW_LINE DEDENT elif 2 : NEW_LINE INDENT x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 ) NEW_LINE DEDENT elif 3 : NEW_LINE INDENT x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 ) NEW_LINE DEDENT if sum
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT l1 , r1 , l2 , r2 = map ( int , input ( ) . split ( ) ) NEW_LINE for i in range ( l1 , r1 + 1 ) : NEW_LINE INDENT for j in range ( l2 , r2 + 1 ) : NEW_LINE INDENT if i != j : NEW_LINE INDENT print ( i , j ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT
from collections import deque NEW_LINE from enum import Enum NEW_LINE import sys NEW_LINE import math NEW_LINE from _heapq import heappush , heappop NEW_LINE import copy NEW_LINE BIG_NUM = 2000000000 NEW_LINE HUGE_NUM = 99999999999999999 NEW_LINE MOD = 1000000007 NEW_LINE EPS = 0.000000001 NEW_LINE sys . setrecursionlimit ( 100000 ) NEW_LINE sys . setrecursionlimit ( 100000 ) NEW_LINE SIZE = 9 NEW_LINE table = [ 0 ] * SIZE NEW_LINE for i in range ( SIZE ) : NEW_LINE INDENT table [ i ] += table [ i ] NEW_LINE DEDENT for i in range ( SIZE ) : NEW_LINE INDENT table [ i ] += table [ i ] NEW_LINE DEDENT for i in range ( SIZE ) : NEW_LINE INDENT table [ i ] += table [ i ] NEW_LINE DEDENT for i in range ( 1 , SIZE ) : NEW_LINE INDENT if table [ i ] % 3 == 0 : NEW_LINE INDENT table [ i ] %= 3 NEW_LINE DEDENT DEDENT for i in range ( 1 , SIZE ) : NEW_
import eulerlib NEW_LINE LENGTH = 20 NEW_LINE BASE = 10 NEW_LINE MOD = 10 ** 9 NEW_LINE def compute ( ) : NEW_LINE INDENT MAX_SQR_DIGIT_SUM = ( BASE - 1 ) * ( BASE - 1 ) * LENGTH NEW_LINE sum = [ 0 ] * ( MAX_SQR_DIGIT_SUM + 1 ) NEW_LINE count = [ 0 ] * ( MAX_SQR_DIGIT_SUM + 1 ) NEW_LINE count [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , LENGTH + 1 ) : NEW_LINE INDENT for j in range ( BASE ) : NEW_LINE INDENT for k in range ( 0 , MAX_SQR_DIGIT_SUM + 1 ) : NEW_LINE INDENT sum [ i ] [ k + j * j ] = ( sum [ i ] [ k + j * j ] + sum [ i - 1 ] [ k ] ) % MOD NEW_LINE count [ i ] [ k + j * j ] = ( count [ i ] [ k + j * j ] + count [ i - 1 ] [ k ] ) % MOD NEW_LINE DEDENT count [
import sys NEW_LINE input = sys . stdin . readline NEW_LINE q = int ( input ( ) ) NEW_LINE S = set ( ) NEW_LINE for _ in range ( q ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 0 : NEW_LINE INDENT S . add ( b ) NEW_LINE print ( len ( S ) ) NEW_LINE DEDENT elif a == 1 : NEW_LINE INDENT if b in S : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT DEDENT
MAX = 10000002 NEW_LINE prime = [ 0 ] * MAX NEW_LINE prime_count = [ 0 ] * MAX NEW_LINE def sieve ( ) : NEW_LINE INDENT prime [ 0 ] = prime [ 1 ] = 1 NEW_LINE for i in range ( 2 , int ( MAX ** ( 1 / 2 ) ) + 1 ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i * 2 , MAX , i ) : NEW_LINE INDENT if ( prime [ j ] == 0 ) : NEW_LINE INDENT prime [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( 2 , MAX ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT prime [ i ] = i NEW_LINE DEDENT DEDENT DEDENT def numberOfDivisorsOfProduct ( arr , n ) : NEW_LINE INDENT prime_count = [ 0 ] * MAX NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE while ( temp != 1 ) : NEW_LINE INDENT prime_count [ prime [ temp ] ]
def check ( num ) : NEW_LINE INDENT digitSum = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT digitSum = digitSum + num % 10 NEW_LINE num = num // 10 NEW_LINE DEDENT temp = digitSum NEW_LINE reverseDigitSum = 0 NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT rem = temp % 10 NEW_LINE reverseDigitSum = reverseDigitSum * 10 + rem NEW_LINE temp = temp // 10 NEW_LINE DEDENT number = digitSum * reverseDigitSum NEW_LINE return number NEW_LINE DEDENT num = 1729 NEW_LINE x = check ( num ) NEW_LINE if ( num == x ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
arr = [ 12 , 3 , 4 , 15 ] NEW_LINE def sum ( ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT print ( " Sum ▁ of ▁ given ▁ array ▁ is " , sum ( ) ) NEW_LINE
def ways ( n ) : NEW_LINE INDENT first = 2 NEW_LINE second = 3 NEW_LINE res = 0 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT res = first + second NEW_LINE first = second NEW_LINE second = res NEW_LINE DEDENT return res NEW_LINE DEDENT n = 7 NEW_LINE print ( " Total ▁ ways ▁ are : " , ways ( n ) ) NEW_LINE
import math NEW_LINE pi = math . pi NEW_LINE def volume ( r , R , h ) : NEW_LINE INDENT return ( 1 / 3 * pi * h * ( r * r + R * R + r * R ) ) NEW_LINE DEDENT def curved_surface_area ( r , R , l , h ) : NEW_LINE INDENT return pi * l * ( R + r ) + pi * ( r * r + R * R ) NEW_LINE DEDENT small_radius = 3 NEW_LINE big_radius = 8 NEW_LINE slant_height = 13 NEW_LINE height = 12 NEW_LINE print ( " Volume ▁ Of ▁ Frustum ▁ of ▁ Cone ▁ : ▁ " , volume ( small_radius , big_radius , height ) ) NEW_LINE print ( " Curved ▁ Surface ▁ Area ▁ Of ▁ Frustum ▁ of ▁ Cone ▁ : ▁ " , curved_surface_area ( small_radius , big_radius , slant_
def digitSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT sum += ( n % 10 ) NEW_LINE n //= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def isPalindrome ( n ) : NEW_LINE INDENT divisor = 1 NEW_LINE while ( n // divisor >= 10 ) : NEW_LINE INDENT divisor *= 10 NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT leading = n // divisor NEW_LINE trailing = n % 10 NEW_LINE if ( leading != trailing ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = ( n % divisor ) // 10 NEW_LINE divisor = divisor // 100 NEW_LINE DEDENT return True NEW_LINE DEDENT def isDigitSumPalindrome ( n ) : NEW_LINE INDENT sum = digitSum ( n ) NEW_LINE if ( isPalindrome ( sum ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 56 NEW_LINE if ( isDigitSumPalindrome ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n <= 6 : NEW_LINE INDENT print ( 15 ) NEW_LINE DEDENT else : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT n += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( n * 5 ) NEW_LINE DEDENT DEDENT DEDENT
def getPercentile ( rank , students ) : NEW_LINE INDENT result = ( students - rank ) / students * 100 NEW_LINE return result NEW_LINE DEDENT your_rank = 805 NEW_LINE total_students = 97481 NEW_LINE print ( getPercentile ( your_rank , total_students ) ) NEW_LINE
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT n = 17 NEW_LINE if ( isPrime ( n ) and ( n % 16 == 1 ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT n = 13 NEW_LINE if ( isPrime ( n ) and ( n % 4 == 1 ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , int ( n ** 0.5 ) + 1 , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isPowerOfTwo ( n ) : NEW_LINE INDENT return n != 0 and ( ( n & ( n - 1 ) ) == 0 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 43 NEW_LINE if ( isPrime ( n ) and ( isPowerOfTwo ( n * 3 - 1 ) ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT a . sort ( ) NEW_LINE if a [ 0 ] == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT DEDENT
def countOfSubstringWithKOnes ( s , K ) : NEW_LINE INDENT N = len ( s ) NEW_LINE res = 0 NEW_LINE countOfOne = 0 NEW_LINE freq = [ 0 ] * ( N + 1 ) NEW_LINE freq [ 0 ] = 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT countOfOne += ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE if ( countOfOne >= K ) : NEW_LINE INDENT res += freq [ countOfOne - K ] NEW_LINE DEDENT freq [ countOfOne ] += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = "10010" NEW_LINE K = 1 NEW_LINE print ( countOfSubstringWithKOnes ( s , K ) ) NEW_LINE DEDENT
def kth ( arr1 , arr2 , m , n , k ) : NEW_LINE INDENT sorted1 = [ 0 for i in range ( m + n ) ] NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE d = 0 NEW_LINE while ( i < m and j < n ) : NEW_LINE INDENT if ( arr1 [ i ] < arr2 [ j ] ) : NEW_LINE INDENT sorted1 [ d ] = arr1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT sorted1 [ d ] = arr2 [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT while ( i < m ) : NEW_LINE INDENT sorted1 [ d ] = arr1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT while ( j < n ) : NEW_LINE INDENT sorted1 [ d ] = arr2 [ j ] NEW_LINE j += 1 NEW_LINE DEDENT return sorted1 [ k - 1 ] NEW_LINE DEDENT arr1 = [ 2 , 3 , 6 , 7 , 9 ] NEW_LINE arr2 = [ 1 , 4 , 8 , 10 ] NEW_LINE
MAX = 256 NEW_LINE freq = [ [ 0 for i in range ( 256 ) ] for j in range ( 256 ) ] NEW_LINE def preCalculate ( str , n ) : NEW_LINE INDENT freq [ ord ( str [ 0 ] ) ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ch = str [ i ] NEW_LINE for j in range ( MAX ) : NEW_LINE INDENT charToUpdate = chr ( j ) NEW_LINE if ( charToUpdate == ch ) : NEW_LINE INDENT freq [ j ] [ i ] = freq [ j ] [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ j ] [ i ] = freq [ j ] [ i - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT def getFrequency ( ch , l , r ) : NEW_LINE INDENT if ( l == 0 ) : NEW_LINE INDENT return freq [ ch ] [ r ] NEW_LINE DEDENT else : NEW_LINE INDENT return ( freq [ ch ] [ r ] - freq [ ch ] [ l - 1 ] ) NEW_LINE DEDENT DEDENT def firstNonRepeating
MAX = 256 NEW_LINE freq = [ [ 0 for i in range ( 256 ) ] for j in range ( 256 ) ] NEW_LINE def preCalculate ( str , n ) : NEW_LINE INDENT freq [ ord ( str [ 0 ] ) ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ch = str [ i ] NEW_LINE for j in range ( MAX ) : NEW_LINE INDENT charToUpdate = chr ( j ) NEW_LINE if ( charToUpdate == ch ) : NEW_LINE INDENT freq [ j ] [ i ] = freq [ j ] [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ j ] [ i ] = freq [ j ] [ i - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT def getFrequency ( ch , l , r ) : NEW_LINE INDENT if ( l == 0 ) : NEW_LINE INDENT return freq [ ch ] [ r ] NEW_LINE DEDENT else : NEW_LINE INDENT return ( freq [ ch ] [ r ] - freq [ ch ] [ l - 1 ] ) NEW_LINE DEDENT DEDENT def lastNonRepeating
def divide ( a , b ) : NEW_LINE INDENT for i in range ( 2 , min ( a , b ) + 1 ) : NEW_LINE INDENT while ( a % i == 0 and b % i == 0 ) : NEW_LINE INDENT a = a // i NEW_LINE b = b // i NEW_LINE DEDENT DEDENT print ( " A ▁ = " , a , " , ▁ B ▁ = " , b ) NEW_LINE DEDENT A = 10 NEW_LINE B = 15 NEW_LINE divide ( A , B ) NEW_LINE
import math NEW_LINE permutation = [ ] NEW_LINE def printPermutation ( ) : NEW_LINE INDENT permutation . append ( ) NEW_LINE DEDENT def give_random_number ( l , r ) : NEW_LINE INDENT x = ( math . random ( ) % ( r - l + 1 ) + l ) NEW_LINE return x NEW_LINE DEDENT def generate_random_permutation ( l , r ) : NEW_LINE INDENT if ( l > r ) : NEW_LINE INDENT return NEW_LINE DEDENT n = give_random_number ( l , r ) NEW_LINE permutation . append ( n ) NEW_LINE generate_random_permutation ( l , n - 1 ) NEW_LINE generate_random_permutation ( n + 1 , r ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l = 5 NEW_LINE r = 15 NEW_LINE generate_random_permutation ( l , r ) NEW_LINE printPermutation ( ) NEW_LINE DEDENT
N , D = map ( int , input ( ) . split ( ) ) NEW_LINE if D == 1 : NEW_LINE INDENT print ( N * ( N - 1 ) // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( N * ( N - D ) // 2 ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == m : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif n == m : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif n == m : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif n == m : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif n == m : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif n == m : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif n == m : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif n == m : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif n == m : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif n == m : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif n == m : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT
n , a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE if 2 * a < n : print ( " NO " ) NEW_LINE else : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if i == " R " : NEW_LINE INDENT a += 1 NEW_LINE DEDENT elif i == " P " : NEW_LINE INDENT b += 1 NEW_LINE DEDENT elif i == " R " : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif i == " P " : NEW_LINE INDENT c -= 1 NEW_LINE DEDENT elif i == " R " : NEW_LINE INDENT b += 1 NEW_LINE DEDENT elif i == " P " : NEW_LINE INDENT c -= 1 NEW_LINE DEDENT elif i == " S " : NEW_LINE INDENT a += 1 NEW_LINE DEDENT elif i == " P " : NEW_LINE INDENT b += 1 NEW_LINE DEDENT elif i == " R " : NEW_LINE INDENT c -= 1 NEW_LINE DEDENT elif i == " P " : NEW_LINE INDENT a += 1 NEW_LINE DEDENT elif i == " S
t , z = map ( int , input ( ) . split ( ) ) NEW_LINE color = [ ] NEW_LINE for i in range ( t ) : NEW_LINE INDENT s = input ( ) NEW_LINE for j in range ( z ) : NEW_LINE INDENT if s [ j ] == " C " or s [ j ] == " M " or s [ j ] == " Y " : NEW_LINE INDENT color . append ( 1 ) NEW_LINE DEDENT DEDENT if color == [ ] : NEW_LINE INDENT print ( " # Color " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " # Black & White " ) NEW_LINE DEDENT DEDENT
def exponent ( A , B ) : NEW_LINE INDENT if ( A == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( B == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT y = 0 NEW_LINE if ( B % 2 == 0 ) : NEW_LINE INDENT y = exponent ( A , B // 2 ) NEW_LINE y = ( y * y ) NEW_LINE DEDENT else : NEW_LINE INDENT y = A NEW_LINE y = ( y * exponent ( A , B - 1 ) ) NEW_LINE DEDENT return y NEW_LINE DEDENT def sum ( k , n ) : NEW_LINE INDENT sum = exponent ( k , n + 1 ) - exponent ( k - 1 , n + 1 ) NEW_LINE return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE K = 3 NEW_LINE print ( sum ( K , n ) ) NEW_LINE DEDENT
s = input ( ) NEW_LINE print ( s [ : : - 1 ] ) NEW_LINE
pref = [ 0 ] * 100001 ; NEW_LINE def checkPalindrome ( num ) : NEW_LINE INDENT str = str ( num ) ; NEW_LINE l = 0 ; r = len ( str ) - 1 ; NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( str [ l ] != str [ r ] ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT l += 1 ; NEW_LINE r -= 1 ; NEW_LINE DEDENT return num ; NEW_LINE DEDENT def preCompute ( ) : NEW_LINE INDENT for i in range ( 1 , 100000 ) : NEW_LINE INDENT pref [ i ] = pref [ i - 1 ] + checkPalindrome ( i ) ; NEW_LINE DEDENT DEDENT def printSum ( L , R ) : NEW_LINE INDENT print ( pref [ R ] - pref [ L - 1 ] ) ; NEW_LINE DEDENT def printSumPalindromic ( arr , Q ) : NEW_LINE INDENT preCompute ( ) ; NEW_LINE for i in range ( Q ) : NEW_LINE INDENT printSum ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ) ; NEW_
N , K = map ( int , input ( ) . split ( ) ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE def f ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n == 3 : NEW_LINE INDENT return 2 NEW_LINE DEDENT if n == 4 : NEW_LINE INDENT return 2 NEW_LINE DEDENT if n == 5 : NEW_LINE INDENT return 2 NEW_LINE DEDENT if n == 6 : NEW_LINE INDENT return 2 NEW_LINE DEDENT if n == 7 : NEW_LINE INDENT return 2 NEW_LINE DEDENT if n == 8 : NEW_LINE INDENT return 2 NEW_LINE DEDENT if n == 9 : NEW_LINE INDENT return 2 NEW_LINE DEDENT if n == 9 : NEW_LINE INDENT return 2 NEW_LINE DEDENT if n == 9 : NEW_LINE INDENT return 2 NEW_LINE DEDENT if n == 9 : NEW_LINE INDENT return 2 NEW_LINE DEDENT if n == 9 : NEW_LINE INDENT return 2 NEW_LINE DEDENT if n == 9 : NEW_
N = 3 NEW_LINE def interchangeDiagonals ( array ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT if ( i != N // 2 ) : NEW_LINE INDENT temp = array [ i ] [ i ] NEW_LINE array [ i ] [ i ] = array [ i ] [ N - i - 1 ] NEW_LINE array [ i ] [ N - i - 1 ] = temp NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT print ( array [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT array = [ [ 4 , 5 , 6 ] , [ 1 , 2 , 3 ] , [ 7 , 8 , 9 ] ] NEW_LINE interchangeDiagonals ( array ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT s , a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( s // c ) * b + s // a ) NEW_LINE DEDENT
MAX = 100000 NEW_LINE prime = [ False ] * 100002 NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT p = 2 NEW_LINE while ( p * p <= MAX ) : NEW_LINE INDENT if ( prime [ p ] == False ) : NEW_LINE INDENT for i in range ( p * 2 , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT DEDENT p += p NEW_LINE DEDENT DEDENT def superpower ( n ) : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE superPower = 0 NEW_LINE factor = 0 NEW_LINE i = 2 NEW_LINE while ( n > 1 and i <= MAX ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT factor = 0 NEW_LINE while ( n % i == 0 and n > 1 ) : NEW_LINE INDENT factor += 1 NEW_LINE n = n // i NEW_LINE DEDENT if ( superPower < factor ) : NEW_LINE INDENT superPower = factor NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return superPower
def printSubArrays ( arr , start , end ) : NEW_LINE INDENT if ( end == len ( arr ) ) : NEW_LINE INDENT return ; NEW_LINE DEDENT elif ( start > end ) : NEW_LINE INDENT printSubArrays ( arr , 0 , end + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " [ " , end = " , ▁ " ) ; NEW_LINE for i in range ( start , end ) : NEW_LINE INDENT print ( arr [ i ] , end = " , ▁ " ) ; NEW_LINE DEDENT print ( arr [ end ] , end = " ] " ) ; NEW_LINE printSubArrays ( arr , start + 1 , end ) ; NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 ] ; NEW_LINE printSubArrays ( arr , 0 , 0 ) ; NEW_LINE
def isDivisible999 ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE if ( n == 0 and num [ 0 ] == '0' ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 3 == 1 ) : NEW_LINE INDENT num = "00" + num NEW_LINE DEDENT if ( n % 3 == 2 ) : NEW_LINE INDENT num = "0" + num NEW_LINE DEDENT gSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT group = 0 NEW_LINE group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100 NEW_LINE group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10 NEW_LINE group += ( ord ( num [ i ] ) - ord ( '0' ) ) NEW_LINE gSum += group NEW_LINE DEDENT if ( gSum > 1000 ) : NEW_LINE INDENT num = str ( gSum ) NEW_LINE n = len ( num ) NEW_LINE gSum = 1 if ( gSum == 999 ) else 0 NEW_LINE DEDENT return ( gSum ==
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = sum ( l ) NEW_LINE ans = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT ans += s / n NEW_LINE DEDENT while ans < k : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT print ( ans ) NEW_LINE
def sumOfSeries ( a , n ) : NEW_LINE INDENT res = 0 NEW_LINE prev = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT prev *= ( a / i ) NEW_LINE res = res + prev NEW_LINE DEDENT return ( res ) NEW_LINE DEDENT n = 5 NEW_LINE a = 2 NEW_LINE print ( sumOfSeries ( a , n ) ) NEW_LINE
def printTheArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def generateAllBinaryStrings ( n , arr , i ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT printTheArray ( arr , n ) NEW_LINE return NEW_LINE DEDENT arr [ i ] = 0 NEW_LINE generateAllBinaryStrings ( n , arr , i + 1 ) NEW_LINE arr [ i ] = 1 NEW_LINE generateAllBinaryStrings ( n , arr , i + 1 ) NEW_LINE DEDENT n = 4 NEW_LINE arr = [ 0 ] * n NEW_LINE generateAllBinaryStrings ( n , arr , 0 ) NEW_LINE
def numberSequence ( n ) : NEW_LINE INDENT num = ( pow ( 4 , n ) - pow ( 2 , n ) ) - 1 NEW_LINE return num NEW_LINE DEDENT n = 4 NEW_LINE print ( numberSequence ( n ) ) NEW_LINE
def digitProduct ( n ) : NEW_LINE INDENT prod = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT prod = prod * ( n % 10 ) NEW_LINE n = n // 10 NEW_LINE DEDENT return prod NEW_LINE DEDENT def printMultiplicativePrimes ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) NEW_LINE prime [ 0 ] = prime [ 1 ] = False NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ i ] and prime [ digitProduct ( i ) ] ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT n = 10 NEW_LINE printMultiplicativePrimes ( n ) NEW_LINE
def minMoves ( arr , n ) : NEW_LINE INDENT expectedItem = n NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] == expectedItem ) : NEW_LINE INDENT expectedItem -= 1 NEW_LINE DEDENT DEDENT return expectedItem NEW_LINE DEDENT arr = [ 4 , 3 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minMoves ( arr , n ) ) NEW_LINE
def largestGCDSubsequence ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE maxele = max ( arr ) NEW_LINE for i in range ( 2 , maxele + 1 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT ans = max ( ans , count ) NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 3 , 6 , 2 , 5 , 4 ] NEW_LINE size = len ( arr ) NEW_LINE print ( largestGCDSubsequence ( arr , size ) ) NEW_LINE
def calculateSum ( n ) : NEW_LINE INDENT a1 = 1 NEW_LINE a2 = 2 NEW_LINE r = 2 NEW_LINE d = 1 NEW_LINE return ( n ) * ( 2 * a1 + ( n - 1 ) * d ) // 2 + a2 * ( pow ( r , n ) - 1 ) // ( r - 1 ) NEW_LINE DEDENT n = 5 NEW_LINE print ( " Sum ▁ = " , calculateSum ( n ) ) NEW_LINE
def count ( str1 , str2 ) : NEW_LINE INDENT c = 0 NEW_LINE j = 0 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT if ( str2 . find ( str1 [ i ] ) >= 0 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( " No . ▁ of ▁ matching ▁ characters ▁ are : " , c ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str1 = " aabcddekll12 @ " NEW_LINE str2 = " bb2211@55k " NEW_LINE count ( str1 , str2 ) NEW_LINE DEDENT
import sys NEW_LINE def MinimumX ( a , b , c , k ) : NEW_LINE INDENT x = sys . maxsize NEW_LINE if ( k <= c ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT h = k - c NEW_LINE l = 0 NEW_LINE while ( l <= h ) : NEW_LINE INDENT m = ( l + h ) // 2 NEW_LINE if ( ( a * m * m ) + ( b * m ) > ( k - c ) ) : NEW_LINE INDENT x = min ( x , m ) NEW_LINE h = m - 1 NEW_LINE DEDENT elif ( ( a * m * m ) + ( b * m ) < ( k - c ) ) : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return m NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 3 NEW_LINE b = 2 NEW_LINE c = 4 NEW_LINE k = 15 NEW_LINE print ( MinimumX ( a , b , c , k ) ) NEW_LINE DEDENT
def minLettersNeeded ( n ) : NEW_LINE INDENT if ( n % 26 == 0 ) : NEW_LINE INDENT return ( n // 26 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( n // 26 ) + 1 ) NEW_LINE DEDENT DEDENT n = 52 NEW_LINE print ( minLettersNeeded ( n ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE a = [ 0 ] * 26 NEW_LINE for i in s : NEW_LINE INDENT a [ ord ( i ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n // k ) : NEW_LINE INDENT a [ ord ( i ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n // k ) : NEW_LINE INDENT a [ ord ( i ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n // k ) : NEW_LINE INDENT a [ i ] = a [ i ] - a [ i + 1 ] NEW_LINE DEDENT for i in range ( n // k ) : NEW_LINE INDENT print ( a [ i ] , end = ' ' ) NEW_LINE DEDENT DEDENT
a = int ( input ( ) ) NEW_LINE b = int ( input ( ) ) NEW_LINE c = int ( input ( ) ) NEW_LINE d = int ( input ( ) ) NEW_LINE if max ( 3 * a // 250 , a - a * c // 250 ) < max ( 3 * b // 250 , b - b * d // 250 ) : NEW_LINE INDENT print ( " Misha " ) NEW_LINE DEDENT elif max ( 3 * a // 10 , a - a * c // 250 ) < max ( 3 * b // 10 , b - b * d // 250 ) : NEW_LINE INDENT print ( " Vasya " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Tie " ) NEW_LINE DEDENT
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if abs ( a - b ) < 2 : NEW_LINE INDENT print ( " : ( " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Yay ! " ) NEW_LINE DEDENT
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a > b : NEW_LINE INDENT print ( a - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def f ( x ) : NEW_LINE INDENT while x % x == 0 : NEW_LINE INDENT x //= x NEW_LINE DEDENT return x NEW_LINE DEDENT a . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if f ( a [ i ] ) : NEW_LINE INDENT print ( 0 ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT DEDENT print ( 1 ) NEW_LINE
def ways ( s , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT dp [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT temp = " " NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT temp += s [ j ] NEW_LINE test = " " NEW_LINE for k in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT test += s [ k ] NEW_LINE if ( test < temp ) : NEW_LINE INDENT dp [ i ] [ j ] += dp [ k ] [ i - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += dp [ i ] [ n - 1 ] NEW_LINE DE
a , b , c = input ( ) . split ( ) NEW_LINE a = int ( a ) NEW_LINE b = int ( b ) NEW_LINE c = int ( c ) NEW_LINE if a == b : NEW_LINE INDENT print ( " abcdefghijklmnopqrstuvwxyz " ) NEW_LINE DEDENT elif a == b : NEW_LINE INDENT print ( " abcdefghijklmnopqrstuvwxyz " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " abcdefghijklmnopqrstuvwxyz " ) NEW_LINE DEDENT
def isOdd ( arr , n ) : NEW_LINE INDENT flag = 0 NEW_LINE flag1 = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE if ( arr [ i ] % 2 == 0 and flag == 0 ) : NEW_LINE INDENT flag = 1 NEW_LINE l = arr [ i ] NEW_LINE DEDENT if ( arr [ i ] % 2 != 0 and flag1 == 0 ) : NEW_LINE INDENT r = arr [ i ] NEW_LINE flag1 = 1 NEW_LINE DEDENT DEDENT if ( sum % 2 != 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT if ( flag1 == 1 and flag == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT ar = [ 5 , 4 , 4 , 5 , 1 , 3 ] NEW_LINE n = len ( ar ) NEW_LINE res = isOdd ( ar , n ) NEW_
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE i = 0 NEW_LINE j = len ( s ) - 1 NEW_LINE while i < j : NEW_LINE INDENT if s [ i ] != s [ j ] : NEW_LINE INDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT def maxCommonFactors ( a , b ) : NEW_LINE INDENT __gcd = gcd ( a , b ) NEW_LINE ans = 1 NEW_LINE for i in range ( 2 , int ( math . sqrt ( __gcd ) ) + 1 ) : NEW_LINE INDENT if ( __gcd % i == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE while ( __gcd % i == 0 ) : NEW_LINE INDENT __gcd //= i NEW_LINE DEDENT DEDENT DEDENT if ( __gcd != 1 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 12 NEW_LINE b = 18 NEW_LINE print ( maxCommonFactors ( a , b ) ) NEW_LINE DEDENT
def allCharactersSame ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] != s [ 0 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s = " aaa " NEW_LINE if ( allCharactersSame ( s ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , a , b = map ( int , input ( ) . split ( ) ) NEW_LINE a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE b = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE if a [ 0 ] > b [ 0 ] : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def printUnsorted ( arr , n ) : NEW_LINE INDENT s = 0 NEW_LINE e = n - 1 NEW_LINE for s in range ( n - 1 ) : NEW_LINE INDENT if ( arr [ s ] > arr [ s + 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( s == n - 1 ) : NEW_LINE INDENT print ( " The ▁ complete ▁ array ▁ is ▁ sorted " ) NEW_LINE return NEW_LINE DEDENT for e in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT if ( arr [ e ] < arr [ e - 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT max = arr [ s ] NEW_LINE min = arr [ s ] NEW_LINE for i in range ( s + 1 , e + 1 ) : NEW_LINE INDENT if ( arr [ i ] > max ) : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT if ( arr [ i ] < min ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE DEDENT DEDENT for i in
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if a [ i ] >= a [ i + 1 ] : NEW_LINE INDENT c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT c = 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE
l , d = map ( int , input ( ) . split ( ) ) NEW_LINE print ( l // d + l % d ) NEW_LINE
def check ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE digitSum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT digitSum += ( ord ( str [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT return ( digitSum % 9 == 0 ) NEW_LINE DEDENT str = "99333" NEW_LINE if ( check ( str ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def check ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE if ( ( ord ( str [ n - 1 ] ) - ord ( '0' ) ) % 2 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT digitSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT digitSum += ( ord ( str [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT return ( digitSum % 3 == 0 ) NEW_LINE DEDENT str = "1332" NEW_LINE if ( check ( str ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
class Solution ( object ) : NEW_LINE INDENT def letterCasePermutation ( self , S ) : NEW_LINE INDENT ans = [ ] NEW_LINE for c in S : NEW_LINE INDENT if c . islower ( ) : NEW_LINE INDENT for i in range ( len ( ans ) ) : NEW_LINE INDENT ans . append ( str ( ans [ i ] ) ) NEW_LINE ans [ i ] = chr ( ord ( c ) + i ) NEW_LINE ans [ n + i ] = chr ( ord ( c ) + i ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in range ( len ( ans ) ) : NEW_LINE INDENT ans . append ( ans [ i ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE S = " a1b2" NEW_LINE out = sObj . letterCasePermutation ( S ) NEW_LINE print ( out ) NEW_LINE DEDENT
import math NEW_LINE def countDigits ( n ) : NEW_LINE INDENT return int ( n * math . log10 ( 2 ) + 1 ) NEW_LINE DEDENT n = 5 NEW_LINE print ( countDigits ( n ) ) NEW_LINE
import math NEW_LINE def isPerfectSquare ( N ) : NEW_LINE INDENT sr = math . sqrt ( N ) NEW_LINE return ( sr - math . floor ( sr ) == 0 ) NEW_LINE DEDENT def BetrothedNumbers ( n , m ) : NEW_LINE INDENT Sum1 = 1 NEW_LINE Sum2 = 1 NEW_LINE for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT Sum1 += i + ( isPerfectSquare ( n ) ) NEW_LINE DEDENT DEDENT for i in range ( 2 , int ( math . sqrt ( m ) ) + 1 ) : NEW_LINE INDENT if ( m % i == 0 ) : NEW_LINE INDENT Sum2 += i + ( isPerfectSquare ( m ) ) NEW_LINE DEDENT DEDENT if ( ( n + 1 == Sum2 ) and ( m + 1 == Sum1 ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT if __name__
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT totient = eulerlib . list_totients ( LIMIT - 1 ) NEW_LINE totientChainLength = [ 0 ] * ( LIMIT - 1 ) NEW_LINE sum = 0 NEW_LINE for i in range ( 1 , len ( totient ) ) : NEW_LINE INDENT chainlen = totientChainLength [ totient [ i ] ] + 1 NEW_LINE totientChainLength [ i ] = chainlen NEW_LINE if ( chainlen == 25 and totient [ i ] == i - 1 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return str ( sum ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE cnt = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if a [ i ] + 1 < a [ i + 1 ] : NEW_LINE INDENT cnt += 1 NEW_LINE a [ i ] += 1 NEW_LINE DEDENT elif a [ i ] != a [ i + 1 ] : NEW_LINE INDENT cnt += 1 NEW_LINE a [ i ] += 1 NEW_LINE DEDENT DEDENT print ( cnt ) NEW_LINE DEDENT
import sys NEW_LINE from sys import stdin NEW_LINE input = stdin . readline NEW_LINE def main ( args ) : NEW_LINE INDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT print ( " Case ▁ % d : " % ( n , 3 ) ) NEW_LINE print ( " \n " . join ( [ str ( i ) for i in range ( n ) ] ) ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
def findGreatest ( arr , n ) : NEW_LINE INDENT result = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( arr [ j ] * arr [ k ] == arr [ i ] ) : NEW_LINE INDENT result = max ( result , arr [ i ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT arr = [ 30 , 10 , 9 , 3 , 35 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findGreatest ( arr , n ) ) NEW_LINE
def XorSum ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT k = 0 NEW_LINE for j in range ( 1 , arr [ i ] + 1 ) : NEW_LINE INDENT k ^= arr [ i ] NEW_LINE DEDENT result += k NEW_LINE DEDENT return result NEW_LINE DEDENT arr = [ 1 , 2 , 6 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( XorSum ( arr , n ) ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == s [ i + 1 ] : NEW_LINE INDENT ans += "0" NEW_LINE DEDENT else : NEW_LINE INDENT ans += "0" NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
MAX = 256 NEW_LINE def compare ( arr1 , arr2 ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT if ( arr1 [ i ] != arr2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def search ( pat , txt ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE countP = [ 0 ] * MAX NEW_LINE countTW = [ 0 ] * MAX NEW_LINE for i in range ( M ) : NEW_LINE INDENT ( countP [ pat [ i ] ] ) += 1 NEW_LINE ( countTW [ txt [ i ] ] ) += 1 NEW_LINE DEDENT for i in range ( M , N ) : NEW_LINE INDENT if ( compare ( countP , countTW ) ) : NEW_LINE INDENT print ( " Found ▁ at ▁ Index ▁ " , i - M ) NEW_LINE DEDENT ( countTW [ txt [ i ] ] ) += 1 NEW_LINE countTW [ txt [ i - M ] ] -= 1 NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE b = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE c = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE d = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT d [ i ] = ( d [ i ] + c [ i ] ) % 1000000007 NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT d [ i ] = ( d [ i ] + d [ i ] ) % 1000000007 NEW_LINE DEDENT print ( ( d [ n ] * d [ m ] ) % 1000000007 ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ 0 ] * ( n + 1 ) NEW_LINE b = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] + a [ i - 2 ] NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT b [ i ] = b [ i - 1 ] + b [ i - 2 ] NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE s = input ( ) . strip ( ) NEW_LINE m = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE x = [ ] NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT x . append ( input ( ) ) NEW_LINE DEDENT for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT s = input ( ) NEW_LINE if s in l : NEW_LINE INDENT print ( s ) NEW_LINE l . append ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT l . append ( s ) NEW_LINE DEDENT DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , x = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] + b [ i ] > x : NEW_LINE INDENT print ( " YES " ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def solve ( n ) : NEW_LINE INDENT ans = ( n * n // 4 ) NEW_LINE return ans NEW_LINE DEDENT n = 10 NEW_LINE print ( solve ( n ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n % 2 == 0 : NEW_LINE INDENT print ( " ( " ) NEW_LINE DEDENT elif n % 2 == 0 : NEW_LINE INDENT print ( " ) " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ) " ) NEW_LINE DEDENT DEDENT
def Valid ( a , b , c , d ) : NEW_LINE INDENT if ( a + b + c + d == 360 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT a = 80 NEW_LINE b = 70 NEW_LINE c = 100 NEW_LINE d = 110 NEW_LINE if ( Valid ( a , b , c , d ) ) : NEW_LINE INDENT print ( " Valid ▁ quadilateral " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Invalid ▁ quadilateral " ) NEW_LINE DEDENT
import math NEW_LINE n , R , r = map ( int , input ( ) . split ( ) ) NEW_LINE a = math . radians ( r ) NEW_LINE b = math . sin ( a ) + r NEW_LINE if n == 1 : NEW_LINE INDENT if r >= 2 * r : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if r >= 2 * r : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
MAX = 100001 NEW_LINE prime = [ 0 ] * ( MAX + 1 ) NEW_LINE countdiv = [ 0 ] * ( MAX + 1 ) NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT for i in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i * 2 , MAX + 1 , i ) : NEW_LINE INDENT prime [ j ] = i NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , MAX + 1 ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT prime [ i ] = i NEW_LINE DEDENT DEDENT DEDENT def largestGCDSubsequence ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT element = arr [ i ] NEW_LINE while ( element > 1 ) : NEW_LINE INDENT div = prime [ element ] NEW_LINE countdiv [ div ] = max ( countdiv [ div ] , countdiv [ div ] ) NEW_LINE while ( element % div
def Count ( s , pos ) : NEW_LINE INDENT c = ord ( s [ pos - 1 ] ) NEW_LINE counter = 0 NEW_LINE for i in range ( pos - 1 ) : NEW_LINE INDENT if ( s [ i ] == c ) : NEW_LINE INDENT counter = counter + 1 NEW_LINE DEDENT DEDENT return counter NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " abacsddaa " NEW_LINE n = len ( s ) NEW_LINE query = [ 9 , 3 , 2 ] NEW_LINE Q = len ( query ) NEW_LINE for i in range ( Q ) : NEW_LINE INDENT pos = query [ i ] NEW_LINE print ( Count ( s , pos ) ) NEW_LINE DEDENT DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE if ( b >= a ) : NEW_LINE INDENT print ( b ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( d >= c ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( b + ( c - d ) * ( a - b ) ) NEW_LINE DEDENT DEDENT DEDENT
def printDuplicates ( arr , n ) : NEW_LINE INDENT map = { } NEW_LINE count = 0 NEW_LINE dup = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in map : NEW_LINE INDENT map [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT map [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT for i in map : NEW_LINE INDENT if map [ i ] > 1 : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE dup = True NEW_LINE DEDENT DEDENT print ( - 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 12 , 11 , 40 , 12 , 5 , 6 , 5 , 12 , 11 ] NEW_LINE n = len ( arr ) NEW_LINE printDuplicates ( arr , n ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] % 2 == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT if ans == 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def findMissingUtil ( arr , low , high , diff ) : NEW_LINE INDENT if ( high <= low ) : NEW_LINE INDENT return sys . maxsize NEW_LINE DEDENT mid = low + ( high - low ) // 2 NEW_LINE if ( arr [ mid + 1 ] - arr [ mid ] != diff ) : NEW_LINE INDENT return ( arr [ mid ] + diff ) NEW_LINE DEDENT if ( mid > 0 and arr [ mid ] - arr [ mid - 1 ] != diff ) : NEW_LINE INDENT return ( arr [ mid - 1 ] + diff ) NEW_LINE DEDENT if ( arr [ mid ] == arr [ 0 ] + mid * diff ) : NEW_LINE INDENT return findMissingUtil ( arr , mid + 1 , high , diff ) NEW_LINE DEDENT return findMissingUtil ( arr , low , mid - 1 , diff ) NEW_LINE DEDENT def findMissing ( arr , n ) : NEW_LINE INDENT diff = ( arr [ n - 1 ] - arr [ 0 ] ) // n NEW_LINE return findMissingUtil ( arr , 0 , n - 1 , diff ) NEW_LINE DEDENT arr = [ 2 , 4 , 8 , 10 , 12
def findPair ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT first = second = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT print ( " n ▁ = " , first , " and ▁ r ▁ = " , second ) NEW_LINE DEDENT arr = [ 0 , 2 , 3 , 4 , 1 , 6 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE findPair ( arr , n ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 10 ** 9 NEW_LINE for i in range ( 1 , 101 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT continue NEW_LINE DEDENT if abs ( i + 1 ) - a [ j ] == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if abs ( i + 1 ) - a [ j ] == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT ans = min ( ans , abs ( i - a [ j ] ) ) NEW_LINE DEDENT DEDENT print ( ans , ans ) NEW_LINE
s = input ( ) NEW_LINE l = [ ' w ' , ' k ' , ' s ' , ' t ' , ' n ' , ' h ' , ' m ' , ' y ' , ' r ' , ' o ' ] NEW_LINE ans = [ ' w ' , ' k ' , ' s ' , ' t ' , ' n ' , ' h ' , ' m ' , ' y ' , ' r ' ] NEW_LINE for i in range ( len ( l ) ) : NEW_LINE INDENT if l [ i ] == l [ i + 1 ] : NEW_LINE INDENT ans . append ( ' nn ' ) NEW_LINE DEDENT elif l [ i ] == l [ i + 1 ] : NEW_LINE INDENT ans . append ( ' i ' ) NEW_LINE DEDENT elif l [ i ] == l [ i + 1 ] : NEW_LINE INDENT ans . append ( ' n ' ) NEW_LINE DEDENT elif l [ i ] == l [ i + 1 ] : NEW_LINE INDENT ans . append ( ' h ' ) NEW_LINE DEDENT elif l [ i ] == l [ i + 1 ] : NEW_LINE INDENT ans . append ( ' e
def Square ( row , column , moves ) : NEW_LINE INDENT a = 0 NEW_LINE b = 0 NEW_LINE c = 0 NEW_LINE d = 0 NEW_LINE total = 0 NEW_LINE a = row - moves NEW_LINE b = row + moves NEW_LINE c = column - moves NEW_LINE d = column + moves NEW_LINE if ( a < 1 ) : NEW_LINE INDENT a = 1 NEW_LINE DEDENT if ( c < 1 ) : NEW_LINE INDENT c = 1 NEW_LINE DEDENT if ( b > 8 ) : NEW_LINE INDENT b = 8 NEW_LINE DEDENT if ( d > 8 ) : NEW_LINE INDENT d = 8 NEW_LINE DEDENT total = ( b - a + 1 ) * ( d - c + 1 ) - 1 NEW_LINE return total NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT R = 4 NEW_LINE C = 5 NEW_LINE M = 2 NEW_LINE print ( Square ( R , C , M ) ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( a + b + c ) % 2 ) NEW_LINE DEDENT
import math NEW_LINE def powmod ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def discreteLogarithm ( a , b , m ) : NEW_LINE INDENT n = int ( math . sqrt ( m ) + 1 ) NEW_LINE value = [ 0 ] * m NEW_LINE for i in range ( n , 1 , - 1 ) : NEW_LINE INDENT value [ powmod ( a , i * n , m ) ] = i NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT cur = ( powmod ( a , j , m ) * b ) % m NEW_LINE if ( value [ cur ] > 0 ) : NEW_LINE INDENT ans = value [ cur ] * n - j NEW_LINE if ( ans < m ) : NEW_LINE INDENT return ans NEW_LINE
def Circumference ( l , w ) : NEW_LINE INDENT return ( 2 * ( l + w ) ) NEW_LINE DEDENT l = 8 NEW_LINE w = 4 NEW_LINE c = Circumference ( l , w ) NEW_LINE print ( " Circumference ▁ of ▁ a ▁ rectangle ▁ is " , c ) NEW_LINE
def edgeDisjoint ( n ) : NEW_LINE INDENT result = 0 NEW_LINE result = floor ( n / 2 ) NEW_LINE return result NEW_LINE DEDENT n = 4 NEW_LINE print ( edgeDisjoint ( n ) ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans . append ( a [ i ] ) NEW_LINE ans . append ( a [ i - 1 ] ) NEW_LINE DEDENT print ( * ans ) NEW_LINE
def toInt ( x ) : NEW_LINE INDENT return int ( x ) - ord ( '0' ) NEW_LINE DEDENT def prepareSum ( s ) : NEW_LINE INDENT sum [ 0 ] = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT sum [ i + 1 ] = sum [ i ] + toInt ( s [ i ] ) NEW_LINE DEDENT DEDENT def query ( l , r ) : NEW_LINE INDENT if ( ( sum [ r + 1 ] - sum [ l ] ) % 3 == 0 ) : NEW_LINE INDENT print ( " Divisible ▁ by ▁ 3" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ divisible ▁ by ▁ 3" ) NEW_LINE DEDENT DEDENT n = "12468236544" NEW_LINE prepareSum ( n ) NEW_LINE query ( 0 , 1 ) NEW_LINE query ( 1 , 2 ) NEW_LINE query ( 3 , 6 ) NEW_LINE query ( 0 , 10 ) NEW_LINE
def compute ( ) : NEW_LINE INDENT LIMIT = 100000 NEW_LINE rads = [ 1 ] * ( LIMIT + 1 ) NEW_LINE for i in range ( 2 , len ( rads ) ) : NEW_LINE INDENT if ( rads [ i ] == 1 ) : NEW_LINE INDENT for j in range ( i , len ( rads ) , i ) : NEW_LINE INDENT rads [ j ] *= i NEW_LINE DEDENT DEDENT DEDENT rads . sort ( ) NEW_LINE return str ( rads [ 10000 - 1 ] . b ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] < 15 : NEW_LINE INDENT print ( " NO " ) NEW_LINE break NEW_LINE DEDENT if a [ i ] % 14 >= 1 and a [ i ] <= 6 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE print ( n + ( m - 2 * n ) // 4 ) NEW_LINE
def printFirstNegativeInteger ( arr , n , k ) : NEW_LINE INDENT Di = [ ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT Di . append ( i ) NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( len ( Di ) > 0 ) : NEW_LINE INDENT print ( arr [ Di [ - 1 ] ] , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" , end = " ▁ " ) NEW_LINE DEDENT while ( len ( Di ) > 0 and Di [ - k + 1 ] < ( i - k + 1 ) ) : NEW_LINE INDENT Di . pop ( ) NEW_LINE DEDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT Di . append ( i ) NEW_LINE DEDENT DEDENT if ( len ( Di ) > 0 ) : NEW_LINE INDENT print ( arr [ Di [ - 1 ] ] , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print (
import math NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if a [ i ] % i != 0 : NEW_LINE INDENT print ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if a [ i ] % i != 0 : NEW_LINE INDENT print ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT
import sys NEW_LINE from sys import stdin NEW_LINE input = stdin . readline NEW_LINE def main ( args ) : NEW_LINE INDENT name , num = input ( ) . split ( ) NEW_LINE name = int ( name ) NEW_LINE num = int ( num ) NEW_LINE res = num * 200 NEW_LINE num = int ( num ) NEW_LINE print ( name , num , res ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
import math NEW_LINE x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE m1 = ( y2 - y1 ) / ( x2 - x1 ) NEW_LINE m2 = ( y2 - y1 ) / ( x2 - x1 ) NEW_LINE l1 = ( x2 - x1 ) / ( y2 - y1 ) NEW_LINE l2 = ( y2 - y1 ) / ( x2 - x1 ) NEW_LINE l1 = ( l1 - l2 ) / ( x2 - x1 ) NEW_LINE l2 = ( y2 - y1 ) / ( y2 - y1 ) NEW_LINE l1 = ( l1 - l2 ) / ( x1 - x2 ) NEW_LINE print ( " { : . 6f } ▁ { : . 6f } " . format ( l1 , l2 ) ) NEW_LINE
from math import sqrt NEW_LINE xp1 , yp1 , xp2 , yp2 = map ( int , input ( ) . split ( ) ) NEW_LINE q = int ( input ( ) ) NEW_LINE xp = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] NEW_LINE yp = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( q ) : NEW_LINE INDENT t = ( xp [ i ] [ 0 ] - xp [ i ] [ 0 ] ) ** 2 + ( yp [ i ] [ 1 ] - yp [ i ] [ 1 ] ) ** 2 NEW_LINE ans += t * ( xp [ i ] [ 0 ] - xp [ i ] [ 1 ] ) ** 2 NEW_LINE ans += t * ( yp [ i ] [ 0 ] - yp [ i ] [ 1 ] ) ** 2 NEW_LINE DEDENT print ( ans ) NEW_LINE
def printInitials ( str ) : NEW_LINE INDENT len = len ( str ) NEW_LINE str = str . strip ( ) NEW_LINE t = " " NEW_LINE for i in range ( len ) : NEW_LINE INDENT ch = ord ( str [ i ] ) NEW_LINE if ( ch != ' ▁ ' ) : NEW_LINE INDENT t = t + ch NEW_LINE DEDENT else : NEW_LINE INDENT print ( t , end = " ▁ " ) NEW_LINE t = " " NEW_LINE DEDENT DEDENT temp = " " NEW_LINE for j in range ( len ( t ) ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT temp = temp + chr ( ord ( t [ 0 ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT temp = temp + chr ( ord ( t [ j ] ) ) NEW_LINE DEDENT DEDENT print ( temp ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " ishita ▁ bhuiya " NEW_LINE printInitials ( str ) NEW_LINE DE
def max_sum ( arr , n , k ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE dp [ 0 ] = max ( 0 , arr [ 0 ] ) NEW_LINE i = 1 NEW_LINE while ( i < k ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i - 1 ] , arr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT i = k NEW_LINE while ( i < n ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i - 1 ] , arr [ i ] + dp [ i - k ] ) NEW_LINE i += 1 NEW_LINE DEDENT return dp [ n - 1 ] NEW_LINE DEDENT arr = [ 1 , 2 , - 2 , 4 , 3 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE k = 4 NEW_LINE print ( max_sum ( arr , n , k ) ) NEW_LINE
k = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE if k == 1 : NEW_LINE INDENT print ( s [ 0 ] ) NEW_LINE DEDENT elif k == 2 : NEW_LINE INDENT print ( s [ 1 ] ) NEW_LINE DEDENT elif k == 3 : NEW_LINE INDENT print ( s [ 2 ] ) NEW_LINE DEDENT elif k == 4 : NEW_LINE INDENT print ( s [ 3 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ 4 ] ) NEW_LINE DEDENT
def countX ( a , b ) : NEW_LINE INDENT if ( b > a ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( a == b ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = a - b NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , int ( x ** 0.5 ) + 1 ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT d1 = i NEW_LINE d2 = b - 1 NEW_LINE if ( i * i != x ) : NEW_LINE INDENT d2 = x // i NEW_LINE DEDENT if ( d1 > b ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT if ( d2 > b ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT a = 21 NEW_LINE b = 5 NEW_LINE print ( countX ( a , b ) ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE g = [ [ ] for _ in range ( n ) ] NEW_LINE for _ in range ( m ) : NEW_LINE INDENT l , r , d = map ( int , input ( ) . split ( ) ) NEW_LINE g [ l - 1 ] . append ( ( r - 1 , d ) ) NEW_LINE g [ r - 1 ] . append ( ( l , - d ) ) NEW_LINE DEDENT p = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if g [ i ] [ j ] == 0 : NEW_LINE INDENT p [ i ] = p [ j ] + d NEW_LINE DEDENT else : NEW_LINE INDENT p [ i ] = p [ j ] + d NEW_LINE DEDENT DEDENT DEDENT ans = True NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if g [ i ] [ j ] ==
a , b , k , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if a [ k - 1 ] < b [ b - m ] : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 0 and b == 0 and c == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif a == 0 and b == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT elif a == 0 and b == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif c == 0 : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( - 1 ) NEW_LINE DEDENT elif a == 0 and b == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif b * b - 4 * a * c < 0 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 ) NEW_LINE print ( ( - b - 4 * a ) / ( 2 * a ) ) NEW_LINE DEDENT
def average ( a , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT return sum / n NEW_LINE DEDENT arr = [ 10 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( average ( arr , n ) ) NEW_LINE
def isKSortedArray ( arr , n , k ) : NEW_LINE INDENT aux = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT aux [ i ] = arr [ i ] NEW_LINE DEDENT aux . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = bisect . bisect ( aux , arr [ i ] ) NEW_LINE if ( abs ( i - j ) > k ) : NEW_LINE INDENT return " No " NEW_LINE DEDENT DEDENT return " Yes " NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 2 , 1 , 5 , 6 , 4 ] NEW_LINE k = 2 NEW_LINE print ( " Is ▁ it ▁ a ▁ k ▁ sorted ▁ array ? : " , isKSortedArray ( arr , len ( arr ) , k ) ) NEW_LINE DEDENT
def nCr ( n , k ) : NEW_LINE INDENT C = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] NEW_LINE DEDENT def resultOfAllSubsets ( arr , N ) : NEW_LINE INDENT result = 0.0 NEW_LINE sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for n in range ( 1 , N + 1 ) : NEW_LINE INDENT result += ( sum * ( nCr ( N - 1 , n - 1 ) ) / n ) NEW_LINE DE
import math NEW_LINE def productPrimeFactors ( n ) : NEW_LINE INDENT product = 1 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT product *= 2 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = n / 2 NEW_LINE DEDENT DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT product = product * i NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT n = n / i NEW_LINE DEDENT DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT product = product * n NEW_LINE DEDENT return product NEW_LINE DEDENT n = 44 NEW_LINE print ( productPrimeFactors ( n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if s [ i ] == s [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( reverse = True ) NEW_LINE i = 0 NEW_LINE while i < n - 1 : NEW_LINE INDENT if a [ i ] < 0 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT if i == n - 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] > a [ i - 1 ] + k : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT elif a [ i ] > a [ i - 1 ] + k : NEW_LINE INDENT ans -= 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( y % 2 == 0 ) : NEW_LINE INDENT return power ( x , y // 2 ) * power ( x , y // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return x * power ( x , y // 2 ) * power ( x , y // 2 ) NEW_LINE DEDENT DEDENT x = 2 NEW_LINE y = 3 NEW_LINE print ( power ( x , y ) ) NEW_LINE
def charVal ( s , i ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( s [ i ] == '1' ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT def countMinimalReplacements ( s , i , prev , dp , n ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ prev ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ prev ] NEW_LINE DEDENT val = charVal ( s , i ) NEW_LINE ans = sys . maxsize NEW_LINE if ( val == prev ) : NEW_LINE INDENT val = 0 NEW_LINE for cur in range ( 0 , 2 ) : NEW_LINE INDENT if ( cur == prev ) : NEW_LINE INDENT continue NEW_LINE DEDENT val = 1 + countMinimalReplacements ( s , i + 1 , cur , dp , n ) NEW_LINE ans = min ( ans , val ) NEW_LINE DEDENT DEDENT else : NEW
def xorRange ( pre , l , r ) : NEW_LINE INDENT cntOnes = pre [ r ] NEW_LINE if ( l - 1 >= 0 ) : NEW_LINE INDENT cntOnes -= pre [ l - 1 ] NEW_LINE DEDENT if ( cntOnes % 2 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT def performQueries ( queries , q , a , n ) : NEW_LINE INDENT pre = [ 0 ] * n NEW_LINE pre [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + a [ i ] NEW_LINE DEDENT for i in range ( q ) : NEW_LINE INDENT print ( xorRange ( pre , queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) ) NEW_LINE DEDENT DEDENT a = [ 1 , 0 , 1 , 1 , 1 , 0 , 1 , 1 ] NEW_LINE n = len ( a ) NEW_LINE queries = [ [ 0 , 3 ] , [ 0 , 2 ] ]
import sys NEW_LINE input = sys . stdin . readline NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k , u = map ( int , input ( ) . split ( ) ) NEW_LINE p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE p . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT ans += p [ i + 1 ] - p [ i ] NEW_LINE DEDENT if u > 0 : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT ans += p [ i + 1 ] - p [ i ] NEW_LINE DEDENT DEDENT if u > 0 : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT ans += p [ i + 1 ] - p [ i ] NEW_LINE DEDENT DEDENT if u > 0 : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT ans += p [ i + 1 ] - p [ i ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_
def printArray ( A , n , K ) : NEW_LINE INDENT minEle = sys . maxsize NEW_LINE maxEle = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT minEle = min ( minEle , A [ i ] ) NEW_LINE maxEle = max ( maxEle , A [ i ] ) NEW_LINE DEDENT if ( K != 0 ) : NEW_LINE INDENT if ( K % 2 == 1 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT A [ i ] = maxEle - A [ i ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT A [ i ] = A [ i ] - minEle NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( A [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 8 , 12 , 16 ] NEW_LINE K = 4 NEW_LINE N = len ( arr ) NEW_LINE
import sys NEW_LINE from sys import stdin NEW_LINE input = stdin . readline NEW_LINE def is_prime ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT return False NEW_LINE DEDENT if n == 3 : NEW_LINE INDENT return True NEW_LINE DEDENT if n == 4 : NEW_LINE INDENT return False NEW_LINE DEDENT if n == 5 : NEW_LINE INDENT return False NEW_LINE DEDENT if n == 6 : NEW_LINE INDENT return True NEW_LINE DEDENT if n == 7 : NEW_LINE INDENT return False NEW_LINE DEDENT if n == 8 : NEW_LINE INDENT return True NEW_LINE DEDENT if n == 9 : NEW_LINE INDENT return False NEW_LINE DEDENT if n == 9 : NEW_LINE INDENT return False NEW_LINE DEDENT if n == 9 : NEW_LINE INDENT return True NEW_LINE DEDENT if n == 9 : NEW_LINE INDENT return False NEW_LINE DEDENT if n == 9 : NEW_LINE INDENT return False NEW_LINE DEDENT if n == 9 : NEW_LINE INDENT return True NEW_LINE
MAX = 64 NEW_LINE def maxOR ( L , R ) : NEW_LINE INDENT if ( L == R ) : NEW_LINE INDENT return L NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( MAX - 1 , - 1 , - 1 ) : NEW_LINE INDENT p = 1 << i NEW_LINE lbit = ( L >> i ) & 1 NEW_LINE rbit = ( R >> i ) & 1 NEW_LINE if ( ( rbit == 1 ) and ( lbit == 0 ) ) : NEW_LINE INDENT ans += ( p << 1 ) - 1 NEW_LINE break NEW_LINE DEDENT if ( rbit == 1 ) : NEW_LINE INDENT ans += p NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT L = 4 NEW_LINE R = 5 NEW_LINE print ( maxOR ( L , R ) ) NEW_LINE
while True : NEW_LINE INDENT s = input ( ) NEW_LINE if s == " # " : NEW_LINE INDENT break NEW_LINE DEDENT s = s . replace ( " = " , " " ) NEW_LINE s = s . replace ( " = " , " " ) NEW_LINE s = s . replace ( " = " , " " ) NEW_LINE s = s . replace ( " = " , " " ) NEW_LINE s = s . replace ( " " , " " ) NEW_LINE s = s . replace ( " = " , " " ) NEW_LINE s = s . replace ( " = " , " " ) NEW_LINE s = s . replace ( " = " , " " ) NEW_LINE s = s . replace ( " = " , " " ) NEW_LINE s = s . replace ( " = " , " " ) NEW_LINE s = s . replace ( " = " , " " ) NEW_LINE s = s . replace ( " = " , " " ) NEW_LINE s = s . replace ( " = " , " " ) NEW_LINE s = s . replace ( " , " " ) NEW_LINE if
def findSplit ( arr , n ) : NEW_LINE INDENT preSum = 0 NEW_LINE ind1 = - 1 NEW_LINE ind2 = - 1 NEW_LINE S = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT S += arr [ i ] NEW_LINE DEDENT if ( S % 3 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT S1 = S // 3 NEW_LINE S2 = 2 * S1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT preSum += arr [ i ] NEW_LINE if ( preSum % S1 == 0 and ind1 == - 1 ) : NEW_LINE INDENT ind1 = i NEW_LINE DEDENT elif ( preSum % S2 == 0 ) : NEW_LINE INDENT ind2 = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( ind1 != - 1 and ind2 != - 1 ) : NEW_LINE INDENT print ( " ( " , ind1 , " , " , ind2 , " ) " ) NEW_LINE return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT arr = [ 1 , 3 ,
def NoofTriplets ( N , K ) : NEW_LINE INDENT cnt = [ 0 ] * K NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT cnt [ i % K ] += 1 NEW_LINE DEDENT if ( ( K & 1 ) != 0 ) : NEW_LINE INDENT return cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT return ( cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] + cnt [ K // 2 ] * cnt [ K // 2 ] * cnt [ K // 2 ] ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 3 NEW_LINE K = 2 NEW_LINE print ( NoofTriplets ( N , K ) ) NEW_LINE DEDENT
def printTwoSetBitNums ( n ) : NEW_LINE INDENT x = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT y = 0 NEW_LINE while ( y < x ) : NEW_LINE INDENT print ( ( ( 1 << x ) + ( 1 << y ) ) , end = " ▁ " ) NEW_LINE n -= 1 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT y += 1 NEW_LINE DEDENT x += 1 NEW_LINE DEDENT DEDENT n = 4 NEW_LINE printTwoSetBitNums ( n ) NEW_LINE
def KnapSack ( val , wt , n , W ) : NEW_LINE INDENT dp = [ 0 ] * ( W + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( W , wt [ i ] , - 1 ) : NEW_LINE INDENT dp [ j ] = max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) NEW_LINE DEDENT DEDENT return dp [ W ] NEW_LINE DEDENT val = [ 7 , 8 , 4 ] NEW_LINE wt = [ 3 , 8 , 6 ] NEW_LINE W = 10 NEW_LINE n = 3 NEW_LINE print ( KnapSack ( val , wt , n , W ) ) NEW_LINE
import math NEW_LINE def twoEggDrop ( k ) : NEW_LINE INDENT return math . ceil ( ( - 1.0 + math . sqrt ( 1 + 8 * k ) ) / 2.0 ) NEW_LINE DEDENT k = 100 NEW_LINE print ( twoEggDrop ( k ) ) NEW_LINE
import math NEW_LINE def nextPerfectSquare ( N ) : NEW_LINE INDENT nextN = int ( math . floor ( math . sqrt ( N ) ) + 1 ) NEW_LINE return nextN * nextN NEW_LINE DEDENT n = 35 NEW_LINE print ( nextPerfectSquare ( n ) ) NEW_LINE
x , y = map ( int , input ( ) . split ( ) ) NEW_LINE print ( x // y , x % y ) NEW_LINE print ( x // y , x % y ) NEW_LINE
import math NEW_LINE eps = 1e-6 NEW_LINE def getArea ( base , hypotenuse ) : NEW_LINE INDENT height = math . sqrt ( hypotenuse * hypotenuse - base * base ) NEW_LINE return 0.5 * base * height NEW_LINE DEDENT def printRightAngleTriangle ( hypotenuse , area ) : NEW_LINE INDENT hsquare = hypotenuse * hypotenuse NEW_LINE sideForMaxArea = math . sqrt ( hsquare / 2.0 ) NEW_LINE maxArea = getArea ( sideForMaxArea , hypotenuse ) NEW_LINE if ( area > maxArea ) : NEW_LINE INDENT print ( " Not ▁ possible " ) NEW_LINE return NEW_LINE DEDENT low = 0.0 NEW_LINE high = sideForMaxArea NEW_LINE base = 0 NEW_LINE while ( abs ( high - low ) > eps ) : NEW_LINE INDENT base = ( low + high ) / 2 NEW_LINE if ( getArea ( base , hypotenuse ) >= area ) : NEW_LINE INDENT high = base NEW_LINE DEDENT else : NEW
MAX = 30 NEW_LINE dp = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE v = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE def findCount ( mat , i , j , m ) : NEW_LINE INDENT if ( i == 0 and j == 0 ) : NEW_LINE INDENT if ( m == mat [ 0 ] [ 0 ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( m < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i < 0 or j < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( v [ i ] [ j ] [ m ] ) : NEW_LINE INDENT return dp [ i ] [ j ] [ m ] NEW_LINE DEDENT v [ i ] [ j ] [ m ] = 1 NEW_LINE dp [ i ] [ j ] [ m ] = findCount ( mat , i - 1 , j , m - mat [ i ] [ j ] ) + findCount ( mat , i ,
while True : NEW_LINE INDENT a , b , p = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 0 and b == 0 and p == 0 : NEW_LINE INDENT break NEW_LINE DEDENT dp = [ 0 ] * ( 111111 ) NEW_LINE dp [ 0 ] = 1 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT if i > a : NEW_LINE INDENT dp [ i - a ] += dp [ i - a ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i - a ] %= p NEW_LINE DEDENT DEDENT dp [ 0 ] = 1 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT if i > a : NEW_LINE INDENT dp [ i - a ] += dp [ i - a ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i - a ] %= p NEW_LINE DEDENT DEDENT print ( dp [ a ] ) NEW_LINE DEDENT
def findNormal ( A , x , y ) : NEW_LINE INDENT dif = A - x * 2 NEW_LINE if ( y == ( 2 * x - x * x ) ) : NEW_LINE INDENT if ( dif < 0 ) : NEW_LINE INDENT print ( ( 0 - dif ) , " y ▁ = " , " x " , ( ( 0 - x ) + ( y * dif ) ) ) NEW_LINE DEDENT elif ( dif > 0 ) : NEW_LINE INDENT print ( dif , " y ▁ = " , " - x + " , ( x + dif * y ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " x ▁ = " , x ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " Not ▁ possible " ) NEW_LINE DEDENT DEDENT A = 2 NEW_LINE x = 2 NEW_LINE y = 0 NEW_LINE findNormal ( A , x , y ) NEW_LINE
def pattern ( ) : NEW_LINE INDENT i , j , k , spaces = 0 , 1 , 7 NEW_LINE for i in range ( n , 1 , - 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT if ( i != n ) : NEW_LINE INDENT for k in range ( 1 , spaces + 1 ) : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT spaces = spaces + 2 NEW_LINE DEDENT for j in range ( i , 1 , - 1 ) : NEW_LINE INDENT if ( j != n ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT spaces = spaces - 4 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT if ( i != n ) : NEW_LINE INDENT for k in range (
def answer ( n ) : NEW_LINE INDENT m = 2 NEW_LINE ans = 1 NEW_LINE r = 1 NEW_LINE while ( r < n ) : NEW_LINE INDENT r = ( pow ( 2 , m ) - 1 ) * ( pow ( 2 , m - 1 ) ) NEW_LINE if ( r < n ) : NEW_LINE INDENT ans = r NEW_LINE DEDENT m += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT n = 7 NEW_LINE print ( answer ( n ) ) NEW_LINE
def nPermute ( str , n ) : NEW_LINE INDENT str . sort ( ) NEW_LINE i = 1 NEW_LINE while ( i == n ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while ( next_permutation ( str ) ) : NEW_LINE INDENT print ( str ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT def next_permutation ( p ) : NEW_LINE INDENT for a in range ( len ( p ) - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( p [ a ] < p [ a + 1 ] ) : NEW_LINE INDENT for b in range ( len ( p ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( p [ b ] > p [ a ] ) : NEW_LINE INDENT t = p [ a ] NEW_LINE p [ a ] = p [ b ] NEW_LINE p [ b ] = t NEW_LINE for a in range ( len ( p ) - 1 , b ) : NEW_LINE INDENT t = p [ a ] NEW_LINE p [ a ] = p [ b ] NEW_LINE p [ b ] = t NEW_LINE DE
h , w = map ( int , input ( ) . split ( ) ) NEW_LINE s = [ ] NEW_LINE for i in range ( h ) : NEW_LINE INDENT s . append ( input ( ) ) NEW_LINE DEDENT for i in range ( h ) : NEW_LINE INDENT for j in range ( w ) : NEW_LINE INDENT if s [ i ] == ' # ' : NEW_LINE INDENT s . append ( j ) NEW_LINE DEDENT DEDENT DEDENT if len ( s ) == len ( s ) + w - 1 : NEW_LINE INDENT print ( ' Possible ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Impossible ' ) NEW_LINE DEDENT
def compute ( ) : NEW_LINE INDENT LENGTH = 50 NEW_LINE ways = [ 0 ] * ( LENGTH + 1 ) NEW_LINE ways [ 0 ] = 1 NEW_LINE for n in range ( 1 , length + 1 ) : NEW_LINE INDENT ways [ n ] += ways [ n - 1 ] NEW_LINE if n >= m : NEW_LINE INDENT ways [ n ] += ways [ n - m ] NEW_LINE DEDENT DEDENT return ways [ length ] - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
import sys NEW_LINE def check ( arr , n ) : NEW_LINE INDENT k = sys . maxsize ; NEW_LINE r = sys . maxsize ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT k = max ( k , arr [ i ] ) ; NEW_LINE r = min ( r , arr [ i ] ) ; NEW_LINE DEDENT k += 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] = k - arr [ i ] ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( abs ( arr [ i ] ) - 1 < n and arr [ abs ( arr [ i ] ) - 1 ] > 0 ) : NEW_LINE INDENT arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ] ; NEW_LINE DEDENT DEDENT flag = 0 ; NEW_LINE for i in range ( k - r - 1 + 1 ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT flag = 1 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT return flag ; NEW
def power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( y % 2 == 0 ) : NEW_LINE INDENT return power ( x , y // 2 ) * power ( x , y // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return x * power ( x , y // 2 ) * power ( x , y // 2 ) NEW_LINE DEDENT DEDENT def sieveOfEratosthenes ( n , isPrime ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( isPrime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def leftTruPrime ( n ) : NEW_LINE INDENT temp = n NEW_LINE cnt = 0 NEW_LINE temp1 = 0 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE
def minReplacement ( s , len ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( len ) : NEW_LINE INDENT if ( i % 2 == 0 and s [ i ] == '1' ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT if ( i % 2 == 1 and s [ i ] == '0' ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return min ( ans , len - ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = "1100" NEW_LINE len = len ( s ) NEW_LINE print ( minReplacement ( s , len ) ) NEW_LINE DEDENT
def right_left ( a , n ) : NEW_LINE INDENT total = dict ( ) NEW_LINE left = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT total [ a [ i ] ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( ( total [ a [ i ] ] - 1 - ( 2 * ( left [ a [ i ] ] ) ) ) , end = " ▁ " ) NEW_LINE left [ a [ i ] ] += 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 2 , 3 , 2 , 1 ] NEW_LINE n = len ( a ) NEW_LINE right_left ( a , n ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE cnt = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if a [ i ] > a [ i + 1 ] : NEW_LINE INDENT a [ i ] , a [ i + 1 ] = a [ i ] , a [ i + 1 ] NEW_LINE cnt += 1 NEW_LINE DEDENT DEDENT print ( cnt ) NEW_LINE print ( * sorted ( a ) ) NEW_LINE
def countPattern ( n , pat ) : NEW_LINE INDENT pattern_int = 0 NEW_LINE power_two = 1 NEW_LINE all_ones = 0 NEW_LINE for i in range ( len ( pat ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT current_bit = pat [ i ] - '0' NEW_LINE pattern_int += ( power_two * current_bit ) NEW_LINE all_ones = all_ones + power_two NEW_LINE power_two = power_two * 2 NEW_LINE DEDENT count = 0 NEW_LINE while ( n != 0 and n >= pattern_int ) : NEW_LINE INDENT if ( ( n & all_ones ) == pattern_int ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT n = n >> 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 500 NEW_LINE pat = "10" NEW_LINE print ( countPattern ( n , pat ) ) NEW_LINE DEDENT
m , n = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT b . append ( a [ i ] - 1 ) NEW_LINE DEDENT c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if b [ i ] == 1 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if c < m : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT
def findNumber ( n ) : NEW_LINE INDENT num = n - 1 NEW_LINE num = 2 * pow ( 4 , num ) NEW_LINE num = floor ( num / 3.0 ) NEW_LINE return num NEW_LINE DEDENT n = 5 NEW_LINE print ( findNumber ( n ) ) NEW_LINE
def multiply ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( y > 0 ) : NEW_LINE INDENT return ( x + multiply ( x , y - 1 ) ) NEW_LINE DEDENT if ( y < 0 ) : NEW_LINE INDENT return - multiply ( x , - y ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT print ( multiply ( 5 , - 11 ) ) NEW_LINE
sz = int ( 1e3 ) NEW_LINE fib = set ( ) NEW_LINE def fibonacci ( ) : NEW_LINE INDENT prev = 0 NEW_LINE curr = 1 NEW_LINE len = 2 NEW_LINE fib . add ( prev ) NEW_LINE fib . add ( curr ) NEW_LINE while ( len <= sz ) : NEW_LINE INDENT temp = curr + prev NEW_LINE fib . add ( temp ) NEW_LINE prev = curr NEW_LINE curr = temp NEW_LINE len += 1 NEW_LINE DEDENT DEDENT def printArray ( arr , len ) : NEW_LINE INDENT for i in range ( len ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT def removeFibonacci ( arr , len ) : NEW_LINE INDENT fibonacci ( ) NEW_LINE for i in range ( len ) : NEW_LINE INDENT if ( fib [ arr [ i ] ] in fib ) : NEW_LINE INDENT for j in range ( i , len - 1 ) : NEW_LINE INDENT arr [ j ] = arr [ j + 1
import math NEW_LINE def minAbsDiff ( n ) : NEW_LINE INDENT left = 1 << ( math . floor ( math . log ( n ) / math . log ( 2 ) ) ) NEW_LINE right = left * 2 NEW_LINE return min ( ( n - left ) , ( right - n ) ) NEW_LINE DEDENT n = 15 NEW_LINE print ( minAbsDiff ( n ) ) NEW_LINE
def bitonicGenerator ( arr , n ) : NEW_LINE INDENT i = 1 NEW_LINE j = n - 1 NEW_LINE if ( j % 2 != 0 ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT while ( i < j ) : NEW_LINE INDENT arr = arr [ : i ] NEW_LINE i += 2 NEW_LINE j -= 2 NEW_LINE DEDENT arr . sort ( ) NEW_LINE arr . sort ( ) NEW_LINE low = ( n + 1 ) // 2 NEW_LINE high = n - 1 NEW_LINE while ( low < high ) : NEW_LINE INDENT temp = arr [ low ] NEW_LINE arr [ low ] = arr [ high ] NEW_LINE arr [ high ] = temp NEW_LINE low += 1 NEW_LINE high -= 1 NEW_LINE DEDENT DEDENT arr = [ 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE bitonicGenerator ( arr , n ) NEW_LINE print ( arr ) NEW_LINE
def printSumSimple ( mat , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( 0 , n - k + 1 ) : NEW_LINE INDENT for j in range ( 0 , n - k + 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE for p in range ( i , k + i ) : NEW_LINE INDENT for q in range ( j , k + j ) : NEW_LINE INDENT sum += mat [ p ] [ q ] NEW_LINE DEDENT DEDENT print ( sum , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT mat = [ [ 1 , 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 , 4 ] , [ 5 , 5 , 5 , 5 ] ] NEW_LINE k = 3 NEW_LINE printSumSimple ( mat , k ) NEW_LINE
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( a + b - 1 ) NEW_LINE i = 1 NEW_LINE while i <= a : NEW_LINE INDENT print ( i , 1 ) NEW_LINE i += 1 NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 16 ) : NEW_LINE INDENT if n % 16 == 0 : NEW_LINE INDENT n //= 16 NEW_LINE DEDENT elif n % 16 == 0 : NEW_LINE INDENT n //= 16 NEW_LINE DEDENT elif n % 16 == 0 : NEW_LINE INDENT n //= 16 NEW_LINE DEDENT elif n % 16 == 0 : NEW_LINE INDENT n //= 16 NEW_LINE DEDENT elif n % 16 == 0 : NEW_LINE INDENT n //= 16 NEW_LINE DEDENT else : NEW_LINE INDENT n += 1 NEW_LINE DEDENT DEDENT print ( n ) NEW_LINE DEDENT
def numOfWhiteHats ( arr , n ) : NEW_LINE INDENT freq = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] >= n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT diffFreq = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( freq [ i ] > 0 ) : NEW_LINE INDENT diffFreq += 1 NEW_LINE DEDENT DEDENT if ( diffFreq == 1 and freq [ n - 1 ] == n ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( diffFreq == 1 and freq [ 0 ] == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( diffFreq != 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT k = n - 1 NEW_LINE while ( k >= 1 ) : NEW_LINE INDENT if ( freq [ k ] > 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( freq [ k - 1 ] == k and freq
def canBeBalanced ( s , n ) : NEW_LINE INDENT count = 0 NEW_LINE count_1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT count_1 = min ( count_1 , count ) NEW_LINE DEDENT if ( count_1 >= - 1 and count == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " ( ) ) ( " NEW_LINE n = len ( s ) NEW_LINE if ( canBeBalanced ( s , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT ans = min ( ans , ( arr [ r ] [ i ] - arr [ l - 1 ] [ i ] ) * ( arr [ r ] [ i ] - arr [ l - 1 ] [ i ] ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def minInt ( str ) : NEW_LINE INDENT s = " " ; NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] >= '5' ) : NEW_LINE INDENT s += chr ( ( '9' - str [ i ] ) + '0' ) ; NEW_LINE DEDENT else : NEW_LINE INDENT s += str [ i ] ; NEW_LINE DEDENT DEDENT if ( str [ 0 ] == '0' ) : NEW_LINE INDENT s += '9' ; NEW_LINE DEDENT return s ; NEW_LINE DEDENT str = "589" ; NEW_LINE print ( minInt ( str ) ) ; NEW_LINE
MAX = 100001 NEW_LINE prefix = [ 0 ] * MAX NEW_LINE def sieve_modified ( ) : NEW_LINE INDENT for i in range ( 1 , MAX , 2 ) : NEW_LINE INDENT for j in range ( i , MAX , i ) : NEW_LINE INDENT prefix [ j ] += i NEW_LINE DEDENT DEDENT for i in range ( 1 , MAX , 1 ) : NEW_LINE INDENT prefix [ i ] += prefix [ i - 1 ] NEW_LINE DEDENT DEDENT def sumOddFactors ( L , R ) : NEW_LINE INDENT return ( prefix [ R ] - prefix [ L - 1 ] ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sieve_modified ( ) NEW_LINE l = 6 NEW_LINE r = 10 NEW_LINE print ( sumOddFactors ( l , r ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n % 4 == 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
h , l = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( l ** 2 - l ** 2 ) / ( 2 * h ) ) NEW_LINE
import math NEW_LINE def findDigits ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT digits = 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT digits += math . log10 ( i ) NEW_LINE DEDENT return int ( math . floor ( digits ) + 1 ) NEW_LINE DEDENT print ( findDigits ( 1 ) ) NEW_LINE print ( findDigits ( 5 ) ) NEW_LINE print ( findDigits ( 10 ) ) NEW_LINE print ( findDigits ( 120 ) ) NEW_LINE
import math NEW_LINE def largestCube ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = ( 2 * r ) / math . sqrt ( 3 ) NEW_LINE return a NEW_LINE DEDENT r = 5 NEW_LINE print ( largestCube ( r ) ) NEW_LINE
def numberOfPaths ( m , n ) : NEW_LINE INDENT path = 1 NEW_LINE for i in range ( n , ( m + n - 1 ) ) : NEW_LINE INDENT path *= i NEW_LINE path //= ( i - n + 1 ) NEW_LINE DEDENT return path NEW_LINE DEDENT print ( numberOfPaths ( 3 , 3 ) ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = list ( input ( ) ) NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if s [ i ] == ' L ' : NEW_LINE INDENT l += 1 NEW_LINE DEDENT elif s [ i ] == ' R ' : NEW_LINE INDENT r += 1 NEW_LINE DEDENT elif s [ i ] == ' L ' : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT elif s [ i ] == ' R ' : NEW_LINE INDENT r += 1 NEW_LINE DEDENT elif s [ i ] == ' L ' : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT elif s [ i ] == ' R ' : NEW_LINE INDENT r += 1 NEW_LINE DEDENT elif s [ i ] == ' L - ' : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT elif s [ i ] == ' R ' : NEW_LINE INDENT r += 1 NEW_LINE DEDENT elif s [ i ] == ' L - ' : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def maxOfRightElement ( root ) : NEW_LINE INDENT res = - 1 NEW_LINE if ( root == None ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( root . right != None ) : NEW_LINE INDENT res = root . right . data NEW_LINE DEDENT return max ( maxOfRightElement ( root . right ) , max ( res , maxOfRightElement ( root . left ) ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT root = Node ( 7 ) NEW_LINE root . left = Node ( 6 ) NEW_LINE root . right = Node ( 5 ) NEW_LINE root . left . left = Node ( 4 ) NEW_LINE root . left . right = Node ( 3 ) NEW_LINE root . right . left = Node ( 2 ) NEW_LINE root . right . right = Node ( 1 ) NEW_LINE print ( maxOfRightElement ( root
def removeElements ( arr , n ) : NEW_LINE INDENT brr = [ 0 for i in range ( n ) ] NEW_LINE l = 1 NEW_LINE brr [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( brr [ l - 1 ] <= arr [ i ] ) : NEW_LINE INDENT brr [ l ] = arr [ i ] NEW_LINE l += 1 NEW_LINE DEDENT DEDENT for i in range ( l ) : NEW_LINE INDENT print ( brr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 10 , 12 , 9 , 10 , 2 , 13 , 14 ] NEW_LINE n = len ( arr ) NEW_LINE removeElements ( arr , n ) NEW_LINE
class Node : NEW_LINE INDENT def __init__ ( self , elementID , stepsToeliminate ) : NEW_LINE INDENT self . elementID = elementID NEW_LINE self . stepsToeliminate = stepsToeliminate NEW_LINE DEDENT DEDENT def minSteps ( arr , N ) : NEW_LINE INDENT s = [ ] NEW_LINE s . append ( ( 0 , - 1 ) ) NEW_LINE maxStepsToeliminate = - 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT stepsToeliminate = 1 NEW_LINE while ( len ( s ) > 0 ) : NEW_LINE INDENT if ( arr [ s [ - 1 ] . elementID ] >= arr [ i ] ) : NEW_LINE INDENT stepsToeliminate = max ( stepsToeliminate , s [ - 1 ] . stepsToeliminate + 1 ) NEW_LINE s . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( len ( s ) > 0 ) : NEW_LINE INDENT stepsToeliminate = - 1 NEW_LINE DEDENT maxStepsToeliminate
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = [ ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT s . append ( input ( ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT s . append ( input ( ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if s [ i ] [ j ] == s [ j ] [ 0 ] : NEW_LINE INDENT print ( s [ i ] [ j ] , end = " ▁ " ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT
def check ( H , S ) : NEW_LINE INDENT return H * H >= 4 * S NEW_LINE DEDENT def findPairs ( H , n , S , m ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( check ( H [ i ] , S [ j ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT H = [ 1 , 6 , 4 ] NEW_LINE n = len ( H ) NEW_LINE S = [ 23 , 3 , 42 , 14 ] NEW_LINE m = len ( S ) NEW_LINE print ( findPairs ( H , n , S , m ) ) NEW_LINE
def Print3Smallest ( array , n ) : NEW_LINE INDENT firstmin = sys . maxsize ; NEW_LINE secmin = sys . maxsize ; NEW_LINE thirdmin = sys . maxsize ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( array [ i ] < firstmin ) : NEW_LINE INDENT thirdmin = secmin ; NEW_LINE secmin = firstmin ; NEW_LINE firstmin = array [ i ] ; NEW_LINE DEDENT elif ( array [ i ] < secmin ) : NEW_LINE INDENT thirdmin = secmin ; NEW_LINE secmin = array [ i ] ; NEW_LINE DEDENT elif ( array [ i ] < thirdmin ) : NEW_LINE INDENT thirdmin = array [ i ] ; NEW_LINE DEDENT DEDENT print ( " First ▁ min ▁ = " , firstmin ) ; NEW_LINE print ( " Second ▁ min ▁ = " , secmin ) ; NEW_LINE print ( " Third ▁ min ▁ = " , thirdmin ) ; NEW_LINE DEDENT array = [ 4 , 9 , 1 , 32 , 12
s = input ( ) NEW_LINE ans = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == ' ! ' : NEW_LINE INDENT ans . append ( i ) NEW_LINE DEDENT DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == ' B ' : NEW_LINE INDENT ans . append ( i ) NEW_LINE DEDENT elif s [ i ] == ' G ' : NEW_LINE INDENT ans . append ( i ) NEW_LINE DEDENT DEDENT for i in ans : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT
def dayofweek ( d , m , y ) : NEW_LINE INDENT t = [ 0 , 3 , 2 , 5 , 0 , 3 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 ] NEW_LINE y -= ( m < 3 ) NEW_LINE return ( y + y // 4 - y // 100 + y // 400 + t [ m - 1 ] + d ) % 7 NEW_LINE DEDENT day = dayofweek ( 30 , 8 , 2010 ) NEW_LINE print ( day ) NEW_LINE
def powerNumbers ( n ) : NEW_LINE INDENT v = set ( ) NEW_LINE v . add ( 1 ) NEW_LINE for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT j = i * i NEW_LINE v . add ( j ) NEW_LINE while ( j * i <= n ) : NEW_LINE INDENT v . add ( j * i ) NEW_LINE j = j * i NEW_LINE DEDENT DEDENT return len ( v ) NEW_LINE DEDENT print ( powerNumbers ( 50 ) ) NEW_LINE
def productDivisible ( n , k ) : NEW_LINE INDENT product = 1 NEW_LINE position = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( position % 2 == 0 ) : NEW_LINE INDENT product *= n % 10 NEW_LINE DEDENT n = n // 10 NEW_LINE position += 1 NEW_LINE DEDENT if ( product % k == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 321922 NEW_LINE k = 3 NEW_LINE if ( productDivisible ( n , k ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def isDivisibleBy10 ( bin , n ) : NEW_LINE INDENT if ( bin [ n - 1 ] == '1' ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( bin [ i ] == '1' ) : NEW_LINE INDENT posFromRight = n - i - 1 NEW_LINE if ( posFromRight % 4 == 1 ) : NEW_LINE INDENT sum = sum + 2 NEW_LINE DEDENT elif ( posFromRight % 4 == 2 ) : NEW_LINE INDENT sum = sum + 4 NEW_LINE DEDENT elif ( posFromRight % 4 == 3 ) : NEW_LINE INDENT sum = sum + 8 NEW_LINE DEDENT elif ( posFromRight % 4 == 0 ) : NEW_LINE INDENT sum = sum + 6 NEW_LINE DEDENT DEDENT DEDENT if ( sum % 10 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def isDivisibleBy20 ( bin , n ) : NEW_LINE INDENT if ( bin [ n - 1 ] == '1'
def halfsquare ( n , x , y ) : NEW_LINE INDENT half = n // 2 NEW_LINE if ( ( half == x or half == x - 1 ) and ( half == y or half == y - 1 ) ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT n = 100 NEW_LINE x = 51 NEW_LINE y = 100 NEW_LINE halfsquare ( n , x , y ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT while ( a != 0 ) : NEW_LINE INDENT c = a NEW_LINE a = b % a NEW_LINE b = c NEW_LINE DEDENT return b NEW_LINE DEDENT def forbenius ( X , Y ) : NEW_LINE INDENT if ( gcd ( X , Y ) != 1 ) : NEW_LINE INDENT print ( " NA " ) NEW_LINE return NEW_LINE DEDENT A = ( X * Y ) - ( X + Y ) NEW_LINE N = ( X - 1 ) * ( Y - 1 ) // 2 NEW_LINE print ( " Largest ▁ Amount ▁ = ▁ " , A ) NEW_LINE print ( " Total ▁ Count ▁ = ▁ " , N ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT X = 2 NEW_LINE Y = 5 NEW_LINE forbenius ( X , Y ) : NEW_LINE INDENT X = 5 NEW_LINE Y = 10 NEW_LINE print ( ) NEW_LINE forbenius ( X , Y )
def reverse ( a ) : NEW_LINE INDENT for i in range ( 0 , int ( n / 2 ) ) : NEW_LINE INDENT t = a [ i ] NEW_LINE a [ i ] = a [ n - i - 1 ] NEW_LINE a [ n - i - 1 ] = t NEW_LINE DEDENT DEDENT arr = [ 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE arr . sort ( ) NEW_LINE reverse ( arr ) NEW_LINE print ( " Array ▁ after ▁ sorting ▁ : " , end = " ▁ " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT
def bestApproximate ( x , y ) : NEW_LINE INDENT n = len ( x ) NEW_LINE sum_x = 0 NEW_LINE sum_y = 0 NEW_LINE sum_xy = 0 NEW_LINE sum_x2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum_x += x [ i ] NEW_LINE sum_y += y [ i ] NEW_LINE sum_x2 += x [ i ] * y [ i ] NEW_LINE sum_x2 += pow ( x [ i ] , 2 ) NEW_LINE DEDENT m = ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - pow ( sum_x , 2 ) ) NEW_LINE c = ( sum_y - m * sum_x ) / n NEW_LINE print ( " m ▁ = " , m ) NEW_LINE print ( " c ▁ = " , c ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE y = [ 14 ,
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def push ( head , new_data ) : NEW_LINE INDENT new_node = Node ( data ) NEW_LINE new_node . data = new_data NEW_LINE new_node . next = ( head_ref ) NEW_LINE head = head NEW_LINE DEDENT def productOfLastN_NodesUtil ( head , n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT st = [ ] NEW_LINE prod = 1 NEW_LINE while ( head != None ) : NEW_LINE INDENT st . append ( head . data ) NEW_LINE head = head . next NEW_LINE DEDENT while ( n > 0 ) : NEW_LINE INDENT prod *= st . pop ( ) NEW_LINE st . pop ( ) NEW_LINE DEDENT return prod NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT head = None NEW_LINE push ( head , 12 ) NEW_LINE push ( head
def modExp ( a , b ) : NEW_LINE INDENT result = 1 NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b == 1 ) : NEW_LINE INDENT result = result * a NEW_LINE DEDENT a = a * a NEW_LINE b //= 2 NEW_LINE DEDENT return result NEW_LINE DEDENT def check ( num ) : NEW_LINE INDENT if ( num == 1 or num < 3 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT elif ( num % 4 == 0 ) : NEW_LINE INDENT return modExp ( num // 4 , 4 ) NEW_LINE DEDENT elif ( num % 6 == 0 ) : NEW_LINE INDENT return modExp ( num // 3 , 2 ) * modExp ( num // 6 , 2 ) NEW_LINE DEDENT elif ( num % 10 == 0 ) : NEW_LINE INDENT return modExp ( num // 5 , 2 ) * ( num // 10 ) * ( num // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT num = 10 NEW_LINE print ( check ( num ) ) NEW_LINE
def findMaxDiff ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT print ( " Invalid ▁ " ) NEW_LINE return 0 NEW_LINE DEDENT res = - sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( res < ( arr [ i ] - arr [ j ] - i + j ) ) : NEW_LINE INDENT res = ( arr [ i ] - arr [ j ] - i + j ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 9 , 15 , 4 , 12 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxDiff ( arr , n ) ) NEW_LINE
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( " Enter ▁ lower ▁ bound ▁ of ▁ the ▁ interval : ▁ " ) NEW_LINE print ( " Enter ▁ upper ▁ bound ▁ of ▁ the ▁ interval : ▁ " , a , b ) NEW_LINE
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( " Enter ▁ lower ▁ bound ▁ of ▁ the ▁ interval : ▁ " ) NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT if i == 1 or i == 0 : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT DEDENT
MAX = 100 NEW_LINE def smallestInRow ( mat , n , m ) : NEW_LINE INDENT print ( " { ▁ " , end = " " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT minm = mat [ i ] [ 0 ] NEW_LINE for j in range ( 1 , m ) : NEW_LINE INDENT if ( mat [ i ] [ j ] < minm ) : NEW_LINE INDENT minm = mat [ i ] [ j ] NEW_LINE DEDENT DEDENT print ( minm , end = " , ▁ " ) NEW_LINE DEDENT print ( " " ) NEW_LINE DEDENT def smallestInCol ( mat , n , m ) : NEW_LINE INDENT print ( " { ▁ " , end = " " ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT minm = mat [ 0 ] [ i ] NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ j ] [ i ] < minm ) : NEW_LINE INDENT minm = mat [ j ] [ i ] NEW_LINE DEDENT DEDENT print (
def minAbsDiff ( n ) : NEW_LINE INDENT mod = n % 4 NEW_LINE if ( mod == 0 or mod == 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 1 NEW_LINE DEDENT n = 5 NEW_LINE print ( minAbsDiff ( n ) ) NEW_LINE
while True : NEW_LINE INDENT n , k , s = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 and k == 0 and s == 0 : NEW_LINE INDENT break NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT ans += s - i NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def countP ( n , k ) : NEW_LINE INDENT if ( n == 0 or k == 0 or k > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( k == 1 or k == n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( k * countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) ) NEW_LINE DEDENT print ( countP ( 3 , 2 ) ) NEW_LINE
a , b , c , d = map ( str , input ( ) . split ( ) ) NEW_LINE if a == b and c == d and a == c and b == d : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def calculate ( N ) : NEW_LINE INDENT l = ( len ( N ) ) // 2 NEW_LINE count = 0 NEW_LINE for i in range ( 1 , l + 1 ) : NEW_LINE INDENT s = N [ 0 : i ] NEW_LINE l1 = len ( s ) NEW_LINE t = N [ i : l1 + i ] NEW_LINE if ( s [ 0 ] == '0' or t [ 0 ] == '0' ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( s [ 0 ] == '0' or t [ 0 ] == '0' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = "2202200" NEW_LINE print ( calculate ( N ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE N , Q = map ( int , input ( ) . split ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE B = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for _ in range ( Q ) : NEW_LINE INDENT q = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE if q < 100 : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT ans = max ( ans , A [ i ] % q ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT ans = max ( ans , A [ i ] % q ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
def printIndices ( n , a ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] . second , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def printPermutations ( n , a , k ) : NEW_LINE INDENT arr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr . append ( a [ i ] ) NEW_LINE arr . append ( i ) NEW_LINE DEDENT arr . sort ( ) NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] . first == arr [ i - 1 ] . first ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count < k ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT for i in range ( k - 1 ) : NEW_LINE INDENT printIndices ( n , arr ) NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ j ] . first == arr [ j - 1
import math NEW_LINE def countNumbers ( n ) : NEW_LINE INDENT c = 0 NEW_LINE limit = int ( math . sqrt ( n ) ) NEW_LINE prime = [ 0 ] * ( limit + 1 ) NEW_LINE for i in range ( 1 , limit + 1 ) : NEW_LINE INDENT prime [ i ] = i NEW_LINE DEDENT for i in range ( 2 , limit + 1 ) : NEW_LINE INDENT if ( prime [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , limit + 1 , i ) : NEW_LINE INDENT if ( prime [ j ] == j ) : NEW_LINE INDENT prime [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( 2 , limit + 1 ) : NEW_LINE INDENT p = prime [ i ] NEW_LINE q = prime [ i // prime [ i ] ] NEW_LINE if ( p * q == i and q != 1 and p != q ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif ( prime [ i ] == i ) : NEW_LINE INDENT if ( pow ( i , 8 ) <= n ) : NEW_
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE print ( min ( n // k , m // ( k - 1 ) ) ) NEW_LINE DEDENT
N , Q = map ( int , input ( ) . split ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE B = [ 0 ] * N NEW_LINE for i in range ( Q ) : NEW_LINE INDENT A [ i ] = int ( input ( ) ) NEW_LINE DEDENT for i in range ( Q ) : NEW_LINE INDENT B [ A [ i ] - 1 ] += 1 NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( B [ i ] ) NEW_LINE DEDENT
def smallestPoss ( s , n ) : NEW_LINE INDENT ans = " " NEW_LINE arr = [ 0 for i in range ( 10 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ ord ( s [ i ] ) - 48 ] += 1 NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT for j in range ( arr [ i ] ) : NEW_LINE INDENT ans = ans + str ( i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 15 NEW_LINE K = "325343273113434" NEW_LINE print ( smallestPoss ( K , N ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT l . append ( i + 10 * j ) NEW_LINE DEDENT DEDENT l . sort ( ) NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT if l [ i ] <= n : NEW_LINE INDENT l [ i ] , l [ j ] = l [ i ] , l [ j ] NEW_LINE DEDENT DEDENT DEDENT print ( len ( l ) - 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
s = input ( ) NEW_LINE l = len ( s ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT for j in range ( l ) : NEW_LINE INDENT if s [ i ] != s [ j ] : NEW_LINE INDENT print ( s [ i ] ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT print ( " NA " ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT primes = eulerlib . list_primes ( PRIME_LIMIT ) NEW_LINE for n in range ( 5 , len ( primes ) + 2 , 2 ) : NEW_LINE INDENT rem = n * primes [ n - 1 ] * 2 NEW_LINE if rem > THRESHOLD : NEW_LINE INDENT return str ( n ) NEW_LINE DEDENT DEDENT return " Not ▁ found " NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
s = input ( ) NEW_LINE a = 0 NEW_LINE b = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == ' - ' : NEW_LINE INDENT a += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b += 1 NEW_LINE DEDENT DEDENT if a % b == 0 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE B = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT B [ j ] [ i % j ] = 0 NEW_LINE DEDENT DEDENT for k in range ( 1 , n ) : NEW_LINE INDENT for i in range ( i , n ) : NEW_LINE INDENT B [ i ] [ k ] = 0 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT B [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT B [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT for i in range (
INT_SIZE = 32 NEW_LINE def insert ( pre_xor ) : NEW_LINE INDENT temp = root NEW_LINE for i in range ( INT_SIZE - 1 , - 1 , - 1 ) : NEW_LINE INDENT val = ( pre_xor & ( 1 << i ) ) NEW_LINE if ( temp . arr [ val ] == None ) : NEW_LINE INDENT temp . arr [ val ] = TrieNode ( ) NEW_LINE DEDENT temp = temp . arr [ val ] NEW_LINE DEDENT temp . value = pre_xor NEW_LINE DEDENT def query ( pre_xor ) : NEW_LINE INDENT temp = root NEW_LINE for i in range ( INT_SIZE - 1 , - 1 , - 1 ) : NEW_LINE INDENT val = ( pre_xor & ( 1 << i ) ) NEW_LINE if ( temp . arr [ 1 - val ] != None ) : NEW_LINE INDENT temp = temp . arr [ 1 - val ] NEW_LINE DEDENT elif ( temp . arr [ val ] != None ) : NEW_LINE INDENT temp = temp . arr [ val ] NEW_LINE DEDENT DEDENT return pre_xor ^ ( temp . value ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE e = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE e . sort ( ) NEW_LINE print ( min ( e ) ) NEW_LINE
def sumSubarrayMins ( A , n ) : NEW_LINE INDENT left = [ 0 for i in range ( n ) ] NEW_LINE right = [ 0 for i in range ( n ) ] NEW_LINE s1 = [ 0 for i in range ( n ) ] NEW_LINE s2 = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt = 1 NEW_LINE while ( len ( s1 ) != 0 and ( s1 [ - 1 ] [ 0 ] > A [ i ] ) ) : NEW_LINE INDENT cnt += s1 [ - 1 ] [ 0 ] NEW_LINE s1 . pop ( ) NEW_LINE DEDENT s1 . append ( ( A [ i ] , cnt ) ) NEW_LINE left [ i ] = cnt NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT cnt = 1 NEW_LINE while ( len ( s2 ) != 0 and ( s2 [ 0 ] [ 0 ] >= A [ i ] ) ) : NEW_LINE INDENT cnt += s2 [ 0 ] [ 1 ] NEW_LINE s2 .
def isValid ( n , d ) : NEW_LINE INDENT digit = n % 10 NEW_LINE sum = digit NEW_LINE if ( digit == d ) : NEW_LINE INDENT return False NEW_LINE DEDENT n //= 10 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = n % 10 NEW_LINE if ( digit == d or digit <= sum ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT sum += digit NEW_LINE n //= 10 NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def printGoodNumber ( L , R , d ) : NEW_LINE INDENT for i in range ( L , R + 1 ) : NEW_LINE INDENT if ( isValid ( i , d ) ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT L = 410 NEW_LINE R = 520 NEW_LINE d = 3 NEW_LINE printGoodNumber ( L , R , d ) NEW_LINE
n = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n + 1 , 2 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 , 2 ) : NEW_LINE INDENT if i % j == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
def nthprimedigitsnumber ( n ) : NEW_LINE INDENT len = 1 NEW_LINE prev_count = 0 NEW_LINE while ( True ) : NEW_LINE INDENT curr_count = ( prev_count + pow ( 4 , len ) ) NEW_LINE if ( prev_count < n and curr_count >= n ) : NEW_LINE INDENT break NEW_LINE DEDENT len += 1 NEW_LINE prev_count = curr_count NEW_LINE DEDENT for i in range ( 1 , len + 1 ) : NEW_LINE INDENT for j in range ( 1 , 4 ) : NEW_LINE INDENT if ( prev_count + pow ( 4 , len - i ) < n ) : NEW_LINE INDENT prev_count += pow ( 4 , len - i ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( j == 1 ) : NEW_LINE INDENT print ( "2" , end = " " ) NEW_LINE DEDENT elif ( j == 2 ) : NEW_LINE INDENT print ( "3" , end = " " ) NEW_LINE DEDENT elif ( j == 3 ) : NEW_LINE INDENT print ( "5" , end = " " ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT s = input ( ) NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE while r < len ( s ) and len ( s ) < 3 : NEW_LINE INDENT if s [ r ] not in l : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r += 1 NEW_LINE DEDENT DEDENT while r < len ( s ) and len ( s ) < 3 : NEW_LINE INDENT if s [ r ] not in l : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r += 1 NEW_LINE DEDENT DEDENT print ( min ( l , r - l ) ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT l . append ( i ) NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT l . append ( i ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if l [ i ] [ 1 ] != 0 : NEW_LINE INDENT print ( l [ i ] [ 1 ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE
def maxAND ( L , R ) : NEW_LINE INDENT maximum = L & R NEW_LINE for i in range ( L , R ) : NEW_LINE INDENT for j in range ( i + 1 , R + 1 ) : NEW_LINE INDENT maximum = max ( maximum , ( i & j ) ) NEW_LINE DEDENT DEDENT return maximum NEW_LINE DEDENT L = 1 NEW_LINE R = 632 NEW_LINE print ( maxAND ( L , R ) ) NEW_LINE
def Minimum_Operations ( a , n ) : NEW_LINE INDENT np = [ 0 for i in range ( n + 1 ) ] NEW_LINE np [ n ] = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT np [ i ] = np [ i + 1 ] NEW_LINE if ( a [ i ] <= 0 ) : NEW_LINE INDENT np [ i ] += 1 NEW_LINE DEDENT DEDENT pos = 0 NEW_LINE ans = n NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] >= 0 ) : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT ans = min ( ans , pos + np [ i + 1 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ - 1 , 0 , 1 , 2 ] NEW_LINE n = len ( a ) NEW_LINE print ( Minimum_Operations ( a , n ) ) NEW_LINE DEDENT
a , b , k = map ( int , input ( ) . split ( ) ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT if a + i <= b : NEW_LINE INDENT print ( a + i ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT a [ i ] [ j ] += a [ i ] [ j ] NEW_LINE DEDENT if a [ i ] [ j ] < a [ i ] [ j ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def toNegativeBase ( n , negBase ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return "0" NEW_LINE DEDENT converted = " " NEW_LINE while ( n != 0 ) : NEW_LINE INDENT remainder = n % negBase NEW_LINE n //= negBase NEW_LINE if ( remainder < 0 ) : NEW_LINE INDENT remainder += ( - negBase ) NEW_LINE n += 1 NEW_LINE DEDENT converted = str ( remainder ) + converted NEW_LINE DEDENT return converted NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 13 NEW_LINE negBase = - 2 NEW_LINE print ( toNegativeBase ( n , negBase ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT ans += a [ i + 1 ] - a [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def RSF ( n ) : NEW_LINE INDENT while ( n >= 10 ) : NEW_LINE INDENT x = n NEW_LINE l = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = n // 10 NEW_LINE l += 1 NEW_LINE DEDENT a = [ 0 ] * l NEW_LINE i = l - 1 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT a [ i ] = x % 10 NEW_LINE x = x // 10 NEW_LINE i -= 1 NEW_LINE DEDENT for j in range ( l - 1 ) : NEW_LINE INDENT n = n * 10 + abs ( a [ j ] - a [ j + 1 ] ) NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT n = 6972 NEW_LINE ans = RSF ( n ) NEW_LINE print ( ans ) NEW_LINE
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def circular ( head ) : NEW_LINE INDENT start = head NEW_LINE while ( head . next != None ) : NEW_LINE INDENT head = head . next NEW_LINE DEDENT head . next = start NEW_LINE return start NEW_LINE DEDENT def push ( head , data ) : NEW_LINE INDENT newNode = Node ( data ) NEW_LINE newNode . data = data NEW_LINE newNode . next = ( head ) NEW_LINE head = newNode NEW_LINE return head NEW_LINE DEDENT def displayList ( node ) : NEW_LINE INDENT start = node NEW_LINE while ( node . next != start ) : NEW_LINE INDENT print ( node . data , end = " ▁ " ) NEW_LINE node = node . next NEW_LINE DEDENT print ( node . data , end = " ▁ " ) NEW_LINE DEDENT head = None NEW_LINE head = push ( head , 15 ) NEW_LINE head = push ( head , 14 ) NEW_LINE head
class Solution ( object ) : NEW_LINE INDENT def licenseKeyFormatting ( self , s , k ) : NEW_LINE INDENT sb = [ ] NEW_LINE for i in range ( len ( s ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] != ' - ' ) : NEW_LINE INDENT sb . append ( len ( s ) % ( k + 1 ) == k ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( len ( s ) % ( k + 1 ) == k ) : NEW_LINE INDENT sb . append ( s [ i ] ) NEW_LINE DEDENT DEDENT DEDENT return sb . upper ( ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE s = "5F3Z - 2e - 9 - w " NEW_LINE k = 4 NEW_LINE out = sObj . licenseKeyFormatting ( s , k ) NEW_LINE print ( out ) NEW_LINE DEDENT
EPS = 1E-15 NEW_LINE def findMinValue ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += log10 ( arr [ i ] ) + EPS NEW_LINE DEDENT xl = ( sum / n + EPS ) NEW_LINE res = pow ( 10.0 , xl ) + EPS NEW_LINE return math . ceil ( res + EPS ) NEW_LINE DEDENT arr = [ 4 , 2 , 1 , 10 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMinValue ( arr , n ) ) NEW_LINE
def digroot ( n ) : NEW_LINE INDENT root = 0 NEW_LINE while ( n > 0 or root > 9 ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT n = root NEW_LINE root = 0 NEW_LINE DEDENT root += n % 10 NEW_LINE n //= 10 NEW_LINE DEDENT return root NEW_LINE DEDENT n = 65785412 NEW_LINE print ( digroot ( n ) ) NEW_LINE
m , n = map ( int , input ( ) . split ( ) ) NEW_LINE if m == n : NEW_LINE INDENT print ( " YES " ) NEW_LINE print ( len ( list ( map ( int , input ( ) . split ( ) ) ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE print ( " YES " ) NEW_LINE print ( len ( list ( map ( int , input ( ) . split ( ) ) ) ) ) NEW_LINE DEDENT
def k_sum ( a , n , k ) : NEW_LINE INDENT r = 0 NEW_LINE sum = 0 NEW_LINE ans = 0 NEW_LINE for l in range ( n ) : NEW_LINE INDENT while ( sum < k ) : NEW_LINE INDENT if ( r == n ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT sum += a [ r ] NEW_LINE r += 1 NEW_LINE DEDENT DEDENT if ( sum < k ) : NEW_LINE INDENT break NEW_LINE DEDENT ans += n - r + 1 NEW_LINE sum -= a [ l ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 6 , 1 , 2 , 7 ] NEW_LINE k = 10 NEW_LINE n = len ( a ) NEW_LINE print ( k_sum ( a , n , k ) ) NEW_LINE DEDENT
def getChar ( str ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT sum += ( ord ( str [ i ] ) - ord ( ' a ' ) + 1 ) ; NEW_LINE DEDENT if ( sum % 26 == 0 ) : NEW_LINE INDENT return ' z ' ; NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum % 26 ; NEW_LINE return chr ( ' a ' + sum - 1 ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " gfg " ; NEW_LINE print ( getChar ( str ) ) ; NEW_LINE DEDENT
def sumNth ( A , B , m , n ) : NEW_LINE INDENT res = 0 NEW_LINE if ( n == 1 ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT res = res + A [ i ] NEW_LINE DEDENT DEDENT elif ( n == 2 ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT res = res + B [ i ] * m NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT f = [ 0 ] * n NEW_LINE f [ 0 ] = 0 NEW_LINE f [ 1 ] = 1 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT f [ i ] = f [ i - 1 ] + f [ i - 2 ] NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT res = res + ( m * ( B [ i ] * f [ n - 1 ] ) ) + ( m * ( A [ i ] * f [ n - 2 ] ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT A = [ 1 , 2 , 3 ] NEW_LINE B = [ 4
def odd_even ( arr , n ) : NEW_LINE INDENT odd_indexes = [ ] NEW_LINE even_indexes = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT odd_indexes . append ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT even_indexes . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT odd_indexes . sort ( ) NEW_LINE even_indexes . sort ( ) NEW_LINE for i in range ( len ( odd_indexes ) ) : NEW_LINE INDENT print ( odd_indexes [ i ] , end = " ▁ " ) NEW_LINE DEDENT for i in range ( len ( even_indexes ) ) : NEW_LINE INDENT print ( even_indexes [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 3 , 2 , 7 , 6 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE odd_even ( arr , n ) NEW_LINE
def printFirstNegativeInteger ( arr , n , k ) : NEW_LINE INDENT flag = False NEW_LINE for i in range ( ( n - k + 1 ) ) : NEW_LINE INDENT flag = False NEW_LINE for j in range ( k ) : NEW_LINE INDENT if ( arr [ i + j ] < 0 ) : NEW_LINE INDENT print ( ( arr [ i + j ] ) , end = " ▁ " ) NEW_LINE flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT print ( 0 , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 12 , - 1 , - 7 , 8 , - 15 , 30 , 16 , 28 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE printFirstNegativeInteger ( arr , n , k ) NEW_LINE
def fillPrefixSum ( arr , n , prefixSum ) : NEW_LINE INDENT prefixSum [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefixSum [ i ] = prefixSum [ i - 1 ] + arr [ i ] NEW_LINE DEDENT DEDENT arr = [ 10 , 4 , 16 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE prefixSum = [ 0 ] * n NEW_LINE fillPrefixSum ( arr , n , prefixSum ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( prefixSum [ i ] , end = " ▁ " ) NEW_LINE DEDENT
import sys NEW_LINE from sys import stdin NEW_LINE input = stdin . readline NEW_LINE def main ( args ) : NEW_LINE INDENT while True : NEW_LINE INDENT try : NEW_LINE INDENT x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 = map ( float , input ( ) . split ( ' , ' ) ) NEW_LINE DEDENT except EOFError : NEW_LINE INDENT break NEW_LINE DEDENT alpha = ( x2 - x1 ) / ( y2 - y1 ) NEW_LINE x = ( x1 - x3 ) / ( x2 - x3 ) NEW_LINE y = ( y1 - y3 ) / ( y2 - y3 ) NEW_LINE x = ( x1 - x3 ) / ( y1 - y3 ) NEW_LINE y = ( y1 - y3 ) / ( y1 - y3 ) NEW_LINE print ( x , y ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT ans = max ( ans , ( ( i + 1 ) * ( j + 1 ) ) - k * ( a [ i ] | a [ j ] ) ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
MAX_CHAR = 26 NEW_LINE def commonCharacters ( str , n ) : NEW_LINE INDENT prim = [ True ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT sec = [ False ] * MAX_CHAR NEW_LINE for j in range ( len ( str [ i ] ) ) : NEW_LINE INDENT if ( prim [ ord ( str [ j ] ) - ord ( ' a ' ) ] ) : NEW_LINE INDENT sec [ ord ( str [ j ] ) - ord ( ' a ' ) ] = True NEW_LINE DEDENT DEDENT print ( sec , end = " ▁ " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = [ " geeksforgeeks " , " gemkstones " , " acknowledges " , " aguelikes " ] NEW_LINE n = len ( str ) NEW_LINE commonCharacters ( str , n ) NEW_LINE DEDENT
class Solution ( object ) : NEW_LINE INDENT def findDisappearedNumbers ( self , nums ) : NEW_LINE INDENT ret = [ ] NEW_LINE for i in range ( len ( nums ) ) : NEW_LINE INDENT val = abs ( nums [ i ] ) - 1 NEW_LINE if ( nums [ val ] > 0 ) : NEW_LINE INDENT nums [ val ] = - nums [ val ] NEW_LINE DEDENT DEDENT for i in range ( len ( nums ) ) : NEW_LINE INDENT if ( nums [ i ] > 0 ) : NEW_LINE INDENT ret . append ( i + 1 ) NEW_LINE DEDENT DEDENT return ret NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE nums = [ 4 , 3 , 2 , 7 , 8 , 2 , 3 , 1 ] NEW_LINE out = sObj . findDisappearedNumbers ( nums ) NEW_LINE print ( out ) NEW_LINE DEDENT
def findMaxValue ( ) : NEW_LINE INDENT res = 2 NEW_LINE fact = 2 NEW_LINE while ( True ) : NEW_LINE INDENT if ( fact < 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT res += 1 NEW_LINE fact = fact * res NEW_LINE DEDENT return res - 1 NEW_LINE DEDENT print ( " Maximum ▁ value ▁ of ▁ integer : ▁ " , findMaxValue ( ) ) NEW_LINE
a , b = map ( str , input ( ) . split ( ) ) NEW_LINE if a == b : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT elif a == " N " : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT elif a == " E " : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT elif a == " E " : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT elif a == " N " : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT elif a == " W " : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = set ( ) NEW_LINE for i in a : NEW_LINE INDENT if i not in s : NEW_LINE INDENT s . add ( - i ) NEW_LINE DEDENT else : NEW_LINE INDENT s . add ( i ) NEW_LINE DEDENT DEDENT print ( len ( s ) ) NEW_LINE DEDENT
def primesieve ( prime ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE for p in range ( 2 , 650 + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , 650 + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def sum_sqsum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE sqsum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT x = n % 10 NEW_LINE sum += x NEW_LINE sqsum += x * x NEW_LINE n //= 10 NEW_LINE DEDENT return ( sum , sqsum ) NEW_LINE DEDENT def countnumber ( L , R ) : NEW_LINE INDENT prime = [ True ] * 651 NEW_LINE primesieve ( prime ) NEW_LINE cnt = 0 NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT digit = sum_sqsum ( i ) NEW_LINE if ( prime [ digit . first ] and prime [ digit . second ] )
def printRepeating ( arr , size ) : NEW_LINE INDENT s = set ( ) NEW_LINE s . add ( arr ) NEW_LINE print ( s ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 3 , 2 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE printRepeating ( arr , n ) NEW_LINE DEDENT
def compute ( ) : NEW_LINE INDENT INDEX = 124 NEW_LINE count = 0 NEW_LINE for i in range ( 1 , INDEX + 1 , 2 ) : NEW_LINE INDENT if ( has_tribonacciMultiple ( i ) ) : NEW_LINE INDENT count += 1 NEW_LINE if ( count == INDEX ) : NEW_LINE INDENT return str ( i ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def has_tribonacciMultiple ( modulus ) : NEW_LINE INDENT slow = [ 1 , 1 , 1 ] NEW_LINE fast = slow [ : : - 1 ] NEW_LINE for head in range ( 1 , modulus + 1 , 2 ) : NEW_LINE INDENT if ( slow [ 0 ] % modulus == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( not head and slow [ 0 ] % modulus == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( slow [ 0 ] % modulus == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( slow [ 0 ] % modulus == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT tribonacci ( slow ,
def solution ( a , b , n ) : NEW_LINE INDENT for i in range ( 0 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT if ( ( n - ( i * a ) ) % b == 0 ) : NEW_LINE INDENT print ( " x ▁ = " , i , " , ▁ y ▁ = " , ( n - ( i * a ) ) // b ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " No ▁ solution " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 2 NEW_LINE b = 3 NEW_LINE n = 7 NEW_LINE solution ( a , b , n ) NEW_LINE DEDENT
x , y = map ( int , input ( ) . split ( ) ) NEW_LINE if x > y : NEW_LINE INDENT print ( ' < ' ) NEW_LINE DEDENT elif x < y : NEW_LINE INDENT print ( ' > ' ) NEW_LINE DEDENT elif x < y : NEW_LINE INDENT print ( ' > ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' = ' ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = n NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == " xx " : NEW_LINE INDENT ans = i NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
h , w = map ( int , input ( ) . split ( ) ) NEW_LINE s = [ ] NEW_LINE for i in range ( h ) : NEW_LINE INDENT s . append ( input ( ) ) NEW_LINE DEDENT for i in range ( h ) : NEW_LINE INDENT for j in range ( w ) : NEW_LINE INDENT if s [ i ] [ j ] == ' # ' : NEW_LINE INDENT s [ i ] [ j ] = ' # ' NEW_LINE DEDENT DEDENT DEDENT for i in range ( h ) : NEW_LINE INDENT for j in range ( w ) : NEW_LINE INDENT if s [ i ] [ j ] == ' # ' : NEW_LINE INDENT s [ i ] [ j ] = ' # ' NEW_LINE DEDENT DEDENT DEDENT for i in range ( h ) : NEW_LINE INDENT for j in range ( w ) : NEW_LINE INDENT if s [ i ] [ j ] == ' # ' : NEW_LINE INDENT s [ i ] [ j ] = ' # ' NEW_LINE DEDENT DEDENT DEDENT for i in range ( h ) : NEW_LINE INDENT for j in range ( w ) :
def unitDigitXRaisedY ( x , y ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( y ) : NEW_LINE INDENT res = ( res * x ) % 10 NEW_LINE DEDENT return res NEW_LINE DEDENT print ( unitDigitXRaisedY ( 4 , 2 ) ) NEW_LINE
import math NEW_LINE n = int ( input ( ) ) NEW_LINE print ( math . ceil ( n / 2 ) ) NEW_LINE
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE print ( max ( 0 , min ( n , k - 1 ) - k // 2 ) ) NEW_LINE
def checkCollision ( a , b , c , x , y , radius ) : NEW_LINE INDENT dist = ( abs ( a * x + b * y + c ) ) / sqrt ( a * a + b * b ) NEW_LINE if ( radius == dist ) : NEW_LINE INDENT print ( " Touch " ) NEW_LINE DEDENT elif ( radius > dist ) : NEW_LINE INDENT print ( " Intersect " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Outside " ) NEW_LINE DEDENT DEDENT radius = 5 NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE a = 3 NEW_LINE b = 4 NEW_LINE c = 25 NEW_LINE checkCollision ( a , b , c , x , y , radius ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n , k = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT if k == 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT ans = k + 1 NEW_LINE for i in range ( 2 , k + 1 ) : NEW_LINE INDENT mid = ( k - ( i + 1 ) ) // 2 NEW_LINE mid = ( k - ( i + 1 ) ) // 2 NEW_LINE if n - ( mid + 1 ) < k : NEW_LINE INDENT ans = mid NEW_LINE DEDENT else : NEW_LINE INDENT ans = mid NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def DivisibleBy41 ( first , second , c , n ) : NEW_LINE INDENT digit = [ 0 ] * n NEW_LINE digit [ 0 ] = first NEW_LINE digit [ 1 ] = second NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT digit [ i ] = ( digit [ i - 1 ] * c + digit [ i - 2 ] ) % 10 NEW_LINE DEDENT ans = digit [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans = ( ans * 10 + digit [ i ] ) % 41 NEW_LINE DEDENT if ( ans % 41 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT first = 1 NEW_LINE second = 2 NEW_LINE c = 1 NEW_LINE n = 3 NEW_LINE if ( DivisibleBy41 ( first , second , c , n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE dp = [ - 1 ] * ( n + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if a [ i ] - a [ j ] >= 0 : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ i - a [ j ] ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT print ( dp [ n ] ) NEW_LINE
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT a = [ list ( map ( float , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE s = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT s += a [ i ] [ 0 ] * a [ i + 1 ] [ 1 ] - a [ i ] [ 1 ] * a [ i + 1 ] [ 0 ] NEW_LINE DEDENT s += a [ n - 1 ] [ 0 ] * a [ n - 1 ] [ 1 ] - a [ n - 1 ] [ 1 ] * a [ n - 1 ] [ 0 ] NEW_LINE print ( s , s ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > a [ i ] : NEW_LINE INDENT ans += a [ i ] - a [ i ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT h , m = map ( int , input ( ) . split ( ) ) NEW_LINE print ( h * 60 - m ) NEW_LINE DEDENT
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT p , p , j = map ( int , input ( ) . split ( ) ) NEW_LINE if p >= 100 : NEW_LINE INDENT print ( " A " ) NEW_LINE DEDENT elif p >= 90 : NEW_LINE INDENT print ( " A " ) NEW_LINE DEDENT elif p >= 80 : NEW_LINE INDENT print ( " A " ) NEW_LINE DEDENT elif p >= 50 : NEW_LINE INDENT print ( " B " ) NEW_LINE DEDENT elif p >= 50 : NEW_LINE INDENT print ( " C " ) NEW_LINE DEDENT elif p >= 80 : NEW_LINE INDENT print ( " B " ) NEW_LINE DEDENT elif p >= 50 : NEW_LINE INDENT print ( " C " ) NEW_LINE DEDENT elif p >= 50 : NEW_LINE INDENT print ( " B " ) NEW_LINE DEDENT elif p >= 80 : NEW_LINE INDENT print ( " C " ) NEW_LINE DEDENT DEDENT DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE print ( a [ n - k ] ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE a = 0 NEW_LINE b = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == '0' : NEW_LINE INDENT a += 1 NEW_LINE DEDENT else : NEW_LINE INDENT a -= 1 NEW_LINE DEDENT DEDENT if a == 0 and k <= b : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a ) NEW_LINE DEDENT DEDENT
def search ( arr , l , h , key ) : NEW_LINE INDENT if ( l > h ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( l + h ) // 2 NEW_LINE if ( arr [ mid ] == key ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( arr [ l ] <= arr [ mid ] ) : NEW_LINE INDENT if ( key >= arr [ l ] and key <= arr [ mid ] ) : NEW_LINE INDENT return search ( arr , l , mid - 1 , key ) NEW_LINE DEDENT return search ( arr , mid + 1 , h , key ) NEW_LINE DEDENT if ( key >= arr [ mid ] and key <= arr [ h ] ) : NEW_LINE INDENT return search ( arr , mid + 1 , h , key ) NEW_LINE DEDENT return search ( arr , l , mid - 1 , key ) NEW_LINE DEDENT arr = [ 4 , 5 , 6 , 7 , 8 , 9 , 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE key = 6 NEW_LINE i = search ( arr , 0 , n - 1 , key ) NEW_
def fillWithFreq ( arr , n ) : NEW_LINE INDENT temp = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE DEDENT DEDENT arr = [ 5 , 2 , 3 , 4 , 5 , 5 , 4 , 5 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE fillWithFreq ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT
def convert_To_Len_th_base ( n , arr , len , L ) : NEW_LINE INDENT for i in range ( 0 , L ) : NEW_LINE INDENT print ( arr [ n % len ] , end = " " ) NEW_LINE n //= len NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def print ( arr , len , L ) : NEW_LINE INDENT for i in range ( 0 , pow ( len , L ) ) : NEW_LINE INDENT convert_To_Len_th_base ( i , arr , len , L ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 ] NEW_LINE len = len ( arr ) NEW_LINE L = 2 NEW_LINE print ( arr , len , L ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ 0 ] * n NEW_LINE b = [ 0 ] * n NEW_LINE for i in range ( m ) : NEW_LINE INDENT a [ i ] = int ( input ( ) ) NEW_LINE b [ i ] = int ( input ( ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 1 : NEW_LINE INDENT a [ i ] += 1 NEW_LINE DEDENT elif a [ i ] == 2 : NEW_LINE INDENT b [ i ] += 1 NEW_LINE DEDENT elif a [ i ] == 1 : NEW_LINE INDENT b [ i ] += 1 NEW_LINE DEDENT DEDENT if a [ n ] == 2 : NEW_LINE INDENT print ( " star ▁ topology " ) NEW_LINE DEDENT elif a [ n ] == 1 : NEW_LINE INDENT print ( " bus ▁ topology " ) NEW_LINE DEDENT elif a [ n ] == 2 : NEW_LINE INDENT print ( " star ▁ topology " ) NEW_LINE DEDENT elif a [ n ] ==
import math NEW_LINE def max_gcd ( n , p ) : NEW_LINE INDENT count = 0 NEW_LINE gcd = 1 NEW_LINE while ( p % 2 == 0 ) : NEW_LINE INDENT p >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT if ( count > 0 ) : NEW_LINE INDENT gcd *= pow ( 2 , count // n ) NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( p ) ) + 1 , 2 ) : NEW_LINE INDENT count = 0 NEW_LINE while ( p % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE p = p // i NEW_LINE DEDENT if ( count > 0 ) : NEW_LINE INDENT gcd *= pow ( i , count // n ) NEW_LINE DEDENT DEDENT if ( p > 2 ) : NEW_LINE INDENT gcd *= pow ( p , 1 / n ) NEW_LINE DEDENT return gcd NEW_LINE DEDENT n = 3 NEW_LINE p = 80 NEW_LINE print ( max_gcd ( n , p ) ) NEW_LINE
def maxArea ( perimeter ) : NEW_LINE INDENT length = ceil ( perimeter / 4 ) NEW_LINE breadth = floor ( perimeter / 4 ) NEW_LINE return length * breadth NEW_LINE DEDENT n = 38 NEW_LINE print ( " Maximum ▁ Area ▁ = " , maxArea ( n ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE c = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if a [ i ] == 2 and a [ i ] + a [ i + 1 ] == 3 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE c . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += ( n - a [ i ] ) * ( n - b [ i ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE
def calculate_angle ( n , i , j , k ) : NEW_LINE INDENT if ( i < j ) : NEW_LINE INDENT x = j - i NEW_LINE DEDENT else : NEW_LINE INDENT x = j + n - i NEW_LINE DEDENT if ( j < k ) : NEW_LINE INDENT y = k - j NEW_LINE DEDENT else : NEW_LINE INDENT y = k + n - j NEW_LINE DEDENT ang1 = ( 180 * x ) / n NEW_LINE ang2 = ( 180 * y ) / n NEW_LINE ans = 180 - ang1 - ang2 NEW_LINE return ans NEW_LINE DEDENT n = 5 NEW_LINE a1 = 1 NEW_LINE a2 = 2 NEW_LINE a3 = 5 NEW_LINE print ( calculate_angle ( n , a1 , a2 , a3 ) ) NEW_LINE
def solve ( arr , n ) : NEW_LINE INDENT k = len ( arr ) NEW_LINE mp = [ 0 for i in range ( n + 2 ) ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT leftSegment = arr [ 0 ] - 1 NEW_LINE for i in range ( 1 , k ) : NEW_LINE INDENT leftSegment = max ( leftSegment , arr [ i ] - arr [ i - 1 ] - 1 ) NEW_LINE DEDENT rightSegment = n - arr [ k - 1 ] NEW_LINE maxSegment = max ( leftSegment , rightSegment ) NEW_LINE tim = max ( leftSegment , rightSegment ) NEW_LINE if ( ( maxSegment & 1 ) == 1 ) : NEW_LINE INDENT tim = ( maxSegment // 2 + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT tim = maxSegment // 2 NEW_LINE DEDENT return tim NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 5 NEW_LINE arr = [ 1 , 4 ] NEW_LINE print ( solve ( arr , N )
def findCombinationsUtil ( arr , index , n , red_num ) : NEW_LINE INDENT s = set ( ) NEW_LINE sum = 0 NEW_LINE if ( red_num < 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( red_num == 0 ) : NEW_LINE INDENT for i in range ( index ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT for itr in s : NEW_LINE INDENT sum = sum + itr NEW_LINE DEDENT if ( sum == n ) : NEW_LINE INDENT for i in s : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE return NEW_LINE DEDENT DEDENT prev = ( index == 0 ) NEW_LINE for k in range ( prev , n + 1 ) : NEW_LINE INDENT if ( index < n ) : NEW_LINE INDENT arr [ index ] = k NEW_LINE findCombinationsUtil ( arr , index + 1 , n , red_num - k ) NEW_LINE DEDENT DEDENT DEDENT def findCombinations ( n ) : NEW_LINE INDENT a = [ 0
def KthMinValAfterMconcatenate ( A , N , M , K ) : NEW_LINE INDENT V = [ ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT V . append ( A [ j ] ) NEW_LINE DEDENT DEDENT V . sort ( ) NEW_LINE return ( V [ K - 1 ] ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = [ 3 , 1 , 2 ] NEW_LINE M = 3 NEW_LINE K = 4 NEW_LINE N = len ( A ) NEW_LINE print ( KthMinValAfterMconcatenate ( A , N , M , K ) ) NEW_LINE DEDENT
from collections import deque NEW_LINE from enum import Enum NEW_LINE import sys NEW_LINE import math NEW_LINE from _heapq import heappush , heappop NEW_LINE import copy NEW_LINE BIG_NUM = 2000000000 NEW_LINE HUGE_NUM = 99999999999999999 NEW_LINE MOD = 1000000007 NEW_LINE EPS = 0.000000001 NEW_LINE sys . setrecursionlimit ( 100000 ) NEW_LINE sys . setrecursionlimit ( 100000 ) NEW_LINE SIZE = 10000 NEW_LINE POW = [ 1 ] * SIZE NEW_LINE for i in range ( 1 , SIZE ) : NEW_LINE INDENT POW [ i ] = POW [ i - 1 ] * 2 NEW_LINE DEDENT for i in range ( 1 , SIZE ) : NEW_LINE INDENT for j in range ( i , SIZE ) : NEW_LINE INDENT POW [ i ] = POW [ i - 1 ] * 2 NEW_LINE DEDENT DEDENT for i in range ( 1 , SIZE ) : NEW_LINE INDENT for j in range ( i , SIZE ) : NEW_LINE INDENT POW [ i ] = POW [ i - 1 ] * 2 NEW_LINE
def numberOfSolutions ( n ) : NEW_LINE INDENT c = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT c += n % 2 NEW_LINE n //= 2 NEW_LINE DEDENT return int ( pow ( 2 , c ) ) NEW_LINE DEDENT n = 3 NEW_LINE print ( numberOfSolutions ( n ) ) NEW_LINE
n , x = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if x == sum ( l ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def compute ( ) : NEW_LINE INDENT allLcm = 1 NEW_LINE for i in range ( 1 , 20 ) : NEW_LINE INDENT allLcm = lcm ( i , allLcm ) NEW_LINE DEDENT return str ( allLcm ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def Profit ( costPrice , sellingPrice ) : NEW_LINE INDENT profit = ( sellingPrice - costPrice ) NEW_LINE return profit NEW_LINE DEDENT def Loss ( costPrice , sellingPrice ) : NEW_LINE INDENT Loss = ( costPrice - sellingPrice ) NEW_LINE return Loss NEW_LINE DEDENT costPrice = 1500 NEW_LINE sellingPrice = 2000 NEW_LINE if ( sellingPrice == costPrice ) : NEW_LINE INDENT print ( " No ▁ profit ▁ nor ▁ Loss " ) NEW_LINE DEDENT elif ( sellingPrice > costPrice ) : NEW_LINE INDENT print ( Profit ( costPrice , sellingPrice ) , " Profit ▁ Loss " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( Loss ( costPrice , sellingPrice ) , " Loss ▁ " ) NEW_LINE DEDENT
a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE print ( a + b + c - a + c ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE INF = float ( ' inf ' ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE input = lambda : sys . stdin . readline ( ) . rstrip ( ) NEW_LINE YesNo = lambda b : bool ( [ print ( ' Yes ' ) ] if b else print ( ' No ' ) ) NEW_LINE YESNO = lambda b : bool ( [ print ( ' YES ' ) ] if b else print ( ' NO ' ) ) NEW_LINE int1 = lambda x : int ( x ) - 1 NEW_LINE def main ( ) : NEW_LINE INDENT a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 1 NEW_LINE while True : NEW_LINE INDENT if a [ 0 ] % 2 == 0 : NEW_LINE INDENT a [ 1 ] //= 2 NEW_LINE ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT a [ 0 ] //= 2 NEW_LINE DEDENT
while True : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] < m : NEW_LINE INDENT ans += a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT ans += a [ i ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
from math import sqrt NEW_LINE pr = [ True for i in range ( 10000000 + 1 ) ] NEW_LINE def sieve ( n ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT for p in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT pr . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def SemiPrimeSum ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( len ( pr ) ) : NEW_LINE INDENT for j in range ( i , len ( pr ) ) : NEW_LINE INDENT if ( pr [ i ] * pr [ j ] > N ) : NEW_LINE INDENT break NEW_LINE DEDENT ans += pr [ i ] * pr [ j ] NEW_LINE DEDENT DE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE if n % 2 == 0 : NEW_LINE INDENT print ( n + k * 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT while n % 2 == 0 : NEW_LINE INDENT n += 1 NEW_LINE DEDENT print ( n + k * 2 - 2 ) NEW_LINE DEDENT DEDENT
import math NEW_LINE def isPrime ( N ) : NEW_LINE INDENT if ( N < 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( N & 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( N % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT curr = 5 NEW_LINE s = int ( math . sqrt ( N ) ) NEW_LINE while ( curr <= s ) : NEW_LINE INDENT if ( N % curr == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT curr += 2 NEW_LINE if ( N % curr == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT curr += 4 NEW_LINE DEDENT return True NEW_LINE DEDENT def check ( s , p , prefix_sum , n ) : NEW_LINE INDENT satisfies = True NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i + s - 1 >= n ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( prefix_sum [ i + s - 1 ] - ( i - 1 >= 0 ) ) : NEW_LINE INDENT satisfies = False NEW_LINE DE
import math NEW_LINE def checkPerfectSquare ( n ) : NEW_LINE INDENT d = math . sqrt ( n ) NEW_LINE if ( d * d == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def largestPerfectSquareNumber ( a , n ) : NEW_LINE INDENT maxi = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( checkPerfectSquare ( a [ i ] ) ) : NEW_LINE INDENT maxi = max ( a [ i ] , maxi ) NEW_LINE DEDENT DEDENT return maxi NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 16 , 20 , 25 , 2 , 3 , 10 ] NEW_LINE n = len ( a ) NEW_LINE print ( largestPerfectSquareNumber ( a , n ) ) NEW_LINE DEDENT
class Solution ( object ) : NEW_LINE INDENT def compress ( self , chars ) : NEW_LINE INDENT anchor = 0 NEW_LINE write = 0 NEW_LINE for read in chars : NEW_LINE INDENT if read + 1 == len ( chars ) or chars [ read + 1 ] != chars [ read ] : NEW_LINE INDENT chars [ write + 1 ] = chars [ anchor ] NEW_LINE if read > anchor : NEW_LINE INDENT for c in range ( read - anchor + 1 ) : NEW_LINE INDENT chars [ write + 1 ] = c NEW_LINE write += 1 NEW_LINE DEDENT DEDENT anchor = read + 1 NEW_LINE DEDENT DEDENT return write NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE chars = [ ' a ' , ' a ' , ' b ' , ' c ' , ' c ' , ' c ' ] NEW_LINE out = sObj . compress ( chars ) NEW_LINE print ( out ) NEW_LINE DEDENT
def checkPalindrome ( num ) : NEW_LINE INDENT str = str ( num ) NEW_LINE l = 0 NEW_LINE r = len ( str ) - 1 NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( str [ l ] != str [ r ] ) : NEW_LINE INDENT print ( " No " ) NEW_LINE return NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT print ( " Yes " ) NEW_LINE return NEW_LINE DEDENT n = 19 NEW_LINE k = 3 NEW_LINE checkPalindrome ( n + k ) NEW_LINE
def isVowel ( c ) : NEW_LINE INDENT return ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' ) NEW_LINE DEDENT def countSubstringsUtil ( s ) : NEW_LINE INDENT count = 0 NEW_LINE mp = dict ( ) NEW_LINE n = len ( s ) NEW_LINE start = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] in mp . keys ( ) ) : NEW_LINE INDENT mp [ s [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ s [ i ] ] = 1 NEW_LINE DEDENT while ( mp [ ' a ' ] and mp [ ' e ' ] and mp [ ' i ' ] and mp [ ' o ' ] and mp [ ' u ' ] ) and mp [ ' a ' ] and mp [ ' e ' ] and mp [ ' i ' ] and mp [ ' o ' ] and mp [ ' u ' ] : NEW_LINE INDENT count += n - i NEW_LINE mp [ s [ start ] ] -= 1 NEW_LINE start +=
n , q = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE for _ in range ( q ) : NEW_LINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEW_LINE l , r = l - 1 , r - 1 NEW_LINE ans = [ ] NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if s [ i ] == '0' : NEW_LINE INDENT ans . append ( i ) NEW_LINE DEDENT elif s [ i ] == ' > ' : NEW_LINE INDENT ans . append ( i ) NEW_LINE DEDENT DEDENT if r == 0 : NEW_LINE INDENT ans . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( i ) NEW_LINE DEDENT DEDENT print ( * ans ) NEW_LINE
def setAllBitsAfterMSB ( n ) : NEW_LINE INDENT n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE return n NEW_LINE DEDENT def toggle ( n ) : NEW_LINE INDENT n = n ^ setAllBitsAfterMSB ( n ) NEW_LINE return n NEW_LINE DEDENT n = 10 NEW_LINE n = toggle ( n ) NEW_LINE print ( n ) NEW_LINE
def inv_interpolate ( d , n , y ) : NEW_LINE INDENT x = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT xi = d [ i ] . x ; NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( j != i ) : NEW_LINE INDENT xi = xi * ( y - d [ j ] . y ) / ( d [ i ] . y - d [ j ] . y ) ; NEW_LINE DEDENT DEDENT x += xi ; NEW_LINE DEDENT return x ; NEW_LINE DEDENT d = [ ( 1.27 , 2.3 ) , ( 2.25 , 2.95 ) , ( 2.5 , 3.5 ) , ( 3.6 , 5.1 ) ] ; NEW_LINE n = 4 ; NEW_LINE y = 4.5 ; NEW_LINE print ( " Value ▁ of ▁ x ▁ at ▁ y ▁ = ▁ 4.5 ▁ : " , inv_interpolate ( d , n , y ) ) ; NEW_LINE
def findElement ( arr , n ) : NEW_LINE INDENT prefixMul = [ 0 ] * n NEW_LINE prefixMul [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefixMul [ i ] = prefixMul [ i - 1 ] * arr [ i ] NEW_LINE DEDENT suffixMul = [ 0 ] * n NEW_LINE suffixMul [ n - 1 ] = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT suffixMul [ i ] = suffixMul [ i + 1 ] * arr [ i ] NEW_LINE DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( prefixMul [ i ] == suffixMul [ i ] ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 1 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findElement ( arr , n ) ) NEW_LINE
def numberOfDays ( a , b , n ) : NEW_LINE INDENT Days = b * ( n + a ) // ( a + b ) NEW_LINE return Days NEW_LINE DEDENT a = 10 NEW_LINE b = 20 NEW_LINE n = 5 NEW_LINE print ( numberOfDays ( a , b , n ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE i = 0 NEW_LINE while i < n - 1 : NEW_LINE INDENT if s [ i ] > s [ i + 1 ] : NEW_LINE INDENT s [ i + 1 ] = s [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT print ( s [ 0 ] + s [ 1 : ] ) NEW_LINE DEDENT
MAX = 100005 NEW_LINE fibonacci = set ( ) NEW_LINE def createHash ( ) : NEW_LINE INDENT prev = 0 NEW_LINE curr = 1 NEW_LINE fibonacci . add ( prev ) NEW_LINE fibonacci . add ( curr ) NEW_LINE while ( curr <= MAX ) : NEW_LINE INDENT temp = curr + prev NEW_LINE fibonacci . add ( temp ) NEW_LINE prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT def checkArray ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( fibonacci . add ( arr [ i ] ) ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT if ( fibonacci . add ( sum ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT arr = [ 1 , 2 , 4 , 8 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE createHash ( ) NEW_LINE if ( checkArray ( arr , n ) )
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def solve ( health , n ) : NEW_LINE INDENT currentgcd = gcd ( health [ 0 ] , health [ 1 ] ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT currentgcd = gcd ( currentgcd , health [ i ] ) NEW_LINE DEDENT return currentgcd NEW_LINE DEDENT health = [ 4 , 6 , 8 , 12 ] NEW_LINE n = len ( health ) NEW_LINE print ( solve ( health , n ) ) NEW_LINE
def squarearea ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = 4 * ( pow ( r , 2 ) / 5 ) NEW_LINE return a NEW_LINE DEDENT r = 5 NEW_LINE print ( squarearea ( r ) ) NEW_LINE
class Graph : NEW_LINE INDENT def __init__ ( self , V ) : NEW_LINE INDENT self . V = V NEW_LINE self . adj = [ [ ] for i in range ( V ) ] NEW_LINE DEDENT def addEdge ( v , w ) : NEW_LINE INDENT adj [ v ] . append ( w ) NEW_LINE DEDENT def DFSUtil ( s , visited ) : NEW_LINE INDENT stack = [ ] NEW_LINE stack . append ( s ) NEW_LINE while ( len ( stack ) == 0 ) : NEW_LINE INDENT s = stack . pop ( ) NEW_LINE if ( visited [ s ] == False ) : NEW_LINE INDENT print ( s , end = " ▁ " ) NEW_LINE visited [ s ] = True NEW_LINE DEDENT itr = adj [ s ] . pop ( ) NEW_LINE while ( len ( itr ) > 0 ) : NEW_LINE INDENT v = itr . pop ( ) NEW_LINE if ( not visited [ v ] ) : NEW_LINE INDENT stack . append ( v ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def DFS ( ) : NEW_LINE INDENT visited = [ False ] * V NEW
def addEdge ( V , w ) : NEW_LINE INDENT adj [ v ] . append ( w ) NEW_LINE DEDENT def DFS ( s ) : NEW_LINE INDENT visited = [ False ] * V NEW_LINE stack = [ ] NEW_LINE stack . append ( s ) NEW_LINE while ( len ( stack ) == 0 ) : NEW_LINE INDENT s = stack [ 0 ] NEW_LINE stack . pop ( ) NEW_LINE if ( visited [ s ] == False ) : NEW_LINE INDENT print ( s , end = " ▁ " ) NEW_LINE visited [ s ] = True NEW_LINE DEDENT itr = adj [ s ] . pop ( ) NEW_LINE while ( len ( itr ) > 0 ) : NEW_LINE INDENT v = itr . pop ( ) NEW_LINE if ( not visited [ v ] ) : NEW_LINE INDENT stack . append ( v ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT g = [ 5 ] NEW_LINE g . addEdge ( 1 , 0 ) NEW_LINE g . addEdge ( 0 , 2 ) NEW_LINE g . add
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT S = input ( ) NEW_LINE ans = [ ] NEW_LINE for i in range ( len ( S ) - 1 ) : NEW_LINE INDENT if S [ i ] == S [ i + 1 ] : NEW_LINE INDENT ans . append ( i + 1 ) NEW_LINE ans . append ( i + 2 ) NEW_LINE ans . append ( i + 1 ) NEW_LINE ans . append ( i + 2 ) NEW_LINE ans . append ( i + 1 ) NEW_LINE ans . append ( i + 2 ) NEW_LINE ans . append ( i + 1 ) NEW_LINE ans . append ( i + 3 ) NEW_LINE ans . append ( i + 2 ) NEW_LINE ans . append ( i + 1 ) NEW_LINE ans . append ( i + 2 ) NEW_LINE ans . append ( i + 1 ) NEW_LINE ans . append ( i + 2 ) NEW_LINE ans . append ( i + 1 ) NEW_LINE ans . append ( i + 2 ) NEW_LINE ans . append ( i + 3 ) NEW_LINE ans . append ( i
def sequence ( n ) : NEW_LINE INDENT f = [ 0 ] * ( n + 1 ) ; NEW_LINE f [ 0 ] = 0 ; NEW_LINE f [ 1 ] = 1 ; NEW_LINE f [ 2 ] = 1 ; NEW_LINE print ( f [ 1 ] , f [ 2 ] , end = " ▁ " ) ; NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ; NEW_LINE print ( f [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT n = 13 ; NEW_LINE sequence ( n ) ; NEW_LINE
n , p , q , r = map ( int , input ( ) . split ( ) ) NEW_LINE p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE q = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = max ( ans , p [ i ] * p [ i ] + q [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT ans = max ( ans , q [ i ] * p [ i ] + q [ i ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE
def compute ( ) : NEW_LINE INDENT count = 0 NEW_LINE for n in range ( 1 , 10 ) : NEW_LINE INDENT for k in range ( 1 , 21 ) : NEW_LINE INDENT if n ** k == str ( n ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return str ( count ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
import math NEW_LINE n = 12 NEW_LINE print ( math . sqrt ( n ) ) NEW_LINE
import math NEW_LINE def findSum ( n ) : NEW_LINE INDENT return math . sqrt ( 3 ) * ( n * ( n + 1 ) / 2 ) NEW_LINE DEDENT n = 10 NEW_LINE print ( findSum ( n ) ) NEW_LINE
import math NEW_LINE def findNth ( n ) : NEW_LINE INDENT nthElement = 19 + ( n - 1 ) * 9 NEW_LINE outliersCount = math . log10 ( nthElement ) - 1 NEW_LINE nthElement += 9 * outliersCount NEW_LINE return nthElement NEW_LINE DEDENT print ( findNth ( 5 ) ) NEW_LINE
def per ( a , b ) : NEW_LINE INDENT return ( a + b ) NEW_LINE DEDENT def area ( s ) : NEW_LINE INDENT return ( s / 2 ) NEW_LINE DEDENT a = 7 NEW_LINE b = 8 NEW_LINE s = 10 NEW_LINE print ( per ( a , b ) ) NEW_LINE print ( area ( s ) ) NEW_LINE
def isBinary ( n ) : NEW_LINE INDENT while ( n != 0 ) : NEW_LINE INDENT temp = n % 10 NEW_LINE if ( temp != 0 and temp != 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = n // 10 NEW_LINE DEDENT return True NEW_LINE DEDENT def formBinaryStr ( n , a ) : NEW_LINE INDENT flag = True NEW_LINE s = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( isBinary ( a [ i ] ) ) : NEW_LINE INDENT s += a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 10 , 1 , 0 , 11 , 10 ] NEW_LINE N = len ( a ) NEW_LINE formBinaryStr ( N , a ) NEW_LINE DEDENT
def calculateAND ( arr , n ) : NEW_LINE INDENT max_val = getMax ( arr ) NEW_LINE prime = [ True ] * ( max_val + 1 ) NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( max_val + 1 ) ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT S1 = 0 NEW_LINE S2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT S1 += arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] != 1 ) : NEW_LINE INDENT S2 += arr [ i ] NEW_LINE DEDENT DEDENT return ( S1 & S2 ) NEW_LINE DEDENT arr = [ 3 , 4 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( calculateAND ( arr ,
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT a = [ ] NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE b . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE dp = [ [ 0 ] * ( n + 1 ) for _ in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n + 1 ) : NEW_LINE INDENT if a [ i ] [ j ] > b [ i ] [ j ] : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ j - b [ i ] ] + b [ i ] [ j ] )
def findIndex ( str ) : NEW_LINE INDENT len = len ( str ) NEW_LINE open = [ 0 for i in range ( len + 1 ) ] NEW_LINE close = [ 0 for i in range ( len + 1 ) ] NEW_LINE index = - 1 NEW_LINE open [ 0 ] = 0 NEW_LINE close [ len ] = 0 NEW_LINE if ( str [ 0 ] == ' ( ' ) : NEW_LINE INDENT open [ 1 ] = 1 NEW_LINE DEDENT if ( str [ len - 1 ] == ' ) ' ) : NEW_LINE INDENT close [ len - 1 ] = 1 NEW_LINE DEDENT for i in range ( 1 , len ) : NEW_LINE INDENT if ( str [ i ] == ' ( ' ) : NEW_LINE INDENT open [ i + 1 ] = open [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT open [ i + 1 ] = open [ i ] NEW_LINE DEDENT DEDENT for i in range ( len - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( str [ i ] == ' ) ' ) : NEW_LINE INDENT close [ i ] = close [ i +
def sumOfDigit ( K ) : NEW_LINE INDENT sod = 0 NEW_LINE while ( K != 0 ) : NEW_LINE INDENT sod += K % 10 NEW_LINE K //= 10 NEW_LINE DEDENT return sod NEW_LINE DEDENT def totalNumbersWithSpecificDifference ( N , diff ) : NEW_LINE INDENT low = 1 NEW_LINE high = N NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( mid - sumOfDigit ( mid ) < diff ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return ( N - high ) NEW_LINE DEDENT N = 13 NEW_LINE diff = 2 NEW_LINE print ( totalNumbersWithSpecificDifference ( N , diff ) ) NEW_LINE
def numOfsubarrays ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT product = arr [ i ] NEW_LINE sum = arr [ i ] NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( product == sum ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT product *= arr [ j ] NEW_LINE sum += arr [ j ] NEW_LINE DEDENT if ( product == sum ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( numOfsubarrays ( arr , n ) ) NEW_LINE DEDENT
import math NEW_LINE n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT DEDENT a . sort ( ) NEW_LINE ans = [ ] NEW_LINE for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT for j in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT ans . append ( i ) NEW_LINE DEDENT DEDENT DEDENT if len ( ans ) == 0 : NEW_LINE INDENT print ( len ( ans ) + 1 , len ( ans ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( len ( ans ) + 1 , len ( ans ) ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 0 , 0 ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT if m > n - 2 * m : NEW_LINE INDENT print ( n - 2 * m ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT if m > n - 2 * m : NEW_LINE INDENT print ( n - 2 * m ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT if m > n - 2 * m : NEW_LINE INDENT print ( n - 2 * m ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT print ( n - 2 * m ) NEW_LINE
def getMaxNum ( a , b , c ) : NEW_LINE INDENT if ( b % c == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT x = ( ( b // c ) * c ) NEW_LINE if ( x >= a and x <= b ) : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT a = 2 NEW_LINE b = 10 NEW_LINE c = 3 NEW_LINE print ( getMaxNum ( a , b , c ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE if n % 3 == 0 : NEW_LINE INDENT print ( n // 12 , n // 12 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n // 12 , n // 12 ) NEW_LINE DEDENT
def HailstoneNumbers ( N ) : NEW_LINE INDENT print ( N , end = " ▁ " ) NEW_LINE if ( N == 1 and c == 0 ) : NEW_LINE INDENT return c NEW_LINE DEDENT elif ( N == 1 and c != 0 ) : NEW_LINE INDENT c += 1 NEW_LINE return c NEW_LINE DEDENT elif ( N % 2 == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE HailstoneNumbers ( N // 2 ) NEW_LINE DEDENT elif ( N % 2 != 0 ) : NEW_LINE INDENT c += 1 NEW_LINE HailstoneNumbers ( 3 * N + 1 ) NEW_LINE DEDENT return c NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 7 NEW_LINE x = HailstoneNumbers ( N ) NEW_LINE print ( " Number ▁ of ▁ Steps : " , x ) NEW_LINE DEDENT
class Solution ( object ) : NEW_LINE INDENT def binaryGap ( self , N ) : NEW_LINE INDENT last = - 1 NEW_LINE ans = 0 NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT if ( ( N >> i ) & 1 ) : NEW_LINE INDENT if ( last >= 0 ) : NEW_LINE INDENT ans = max ( ans , i - last ) NEW_LINE DEDENT last = i NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE N = 22 NEW_LINE out = sObj . binaryGap ( N ) NEW_LINE print ( out ) NEW_LINE DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n , h , m = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if h == 7 or h == 17 or m == 7 or m % 10 == 7 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def canFormTeam ( n , m ) : NEW_LINE INDENT if ( n >= 1 and m >= 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( m >= 1 and n >= 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def maxTeams ( n , m ) : NEW_LINE INDENT count = 0 NEW_LINE while ( canFormTeam ( n , m ) ) : NEW_LINE INDENT if ( n > m ) : NEW_LINE INDENT n -= 2 NEW_LINE m -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT m -= 2 NEW_LINE n -= 1 NEW_LINE DEDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT n = 4 NEW_LINE m = 5 NEW_LINE print ( maxTeams ( n , m ) ) NEW_LINE
def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def catalan ( n ) : NEW_LINE INDENT c = binomialCoeff ( 2 * n , n ) NEW_LINE return c // ( n + 1 ) NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT print ( catalan ( i ) , end = " ▁ " ) NEW_LINE DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def catalan ( n ) : NEW_LINE INDENT c = binomialCoeff ( 2 * n , n ) NEW_LINE return c // ( n + 1 ) NEW_LINE DEDENT n = 3 NEW_LINE print ( catalan ( n ) ) NEW_LINE
def removeDuplicates ( string ) : NEW_LINE INDENT lhs = set ( ) NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT lhs . add ( string [ i ] ) NEW_LINE DEDENT for ch in lhs : NEW_LINE INDENT print ( ch , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " geeksforgeeks " NEW_LINE r = removeDuplicates ( string ) NEW_LINE removeDuplicates ( string ) NEW_LINE DEDENT
def getPosition ( a , n , m ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT a [ i ] = ( a [ i ] // m + ( a [ i ] % m ) ) NEW_LINE DEDENT ans = - 1 NEW_LINE max = - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( max < a [ i ] ) : NEW_LINE INDENT max = a [ i ] NEW_LINE ans = i NEW_LINE DEDENT DEDENT return ans + 1 NEW_LINE DEDENT a = [ 2 , 5 , 4 ] NEW_LINE n = len ( a ) NEW_LINE m = 2 NEW_LINE print ( getPosition ( a , n , m ) ) NEW_LINE
days = [ 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] NEW_LINE def dayOfYear ( date ) : NEW_LINE INDENT year = int ( date [ 0 : 4 ] ) NEW_LINE month = int ( date [ 5 : 7 ] ) NEW_LINE day = int ( date [ 8 : ] ) NEW_LINE if ( month > 2 and year % 4 == 0 and ( year % 100 != 0 or year % 400 == 0 ) ) : NEW_LINE INDENT day += 1 NEW_LINE DEDENT while ( month > 0 ) : NEW_LINE INDENT day = day + days [ month - 1 ] NEW_LINE DEDENT return day NEW_LINE DEDENT date = "2019-01-09" NEW_LINE print ( dayOfYear ( date ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n % 2 == 0 : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT print ( i - 1 , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( i + 1 , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT print ( i - 1 , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( i + 1 , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT print ( i - 1 , end = " ▁ " ) NEW
cnt = 0 NEW_LINE graph = [ ] NEW_LINE weight = [ ] NEW_LINE def isPalindrome ( x ) : NEW_LINE INDENT n = len ( x ) NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT if ( x [ i ] != x [ n - 1 - i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def dfs ( node , parent ) : NEW_LINE INDENT x = weight [ node ] NEW_LINE if ( isPalindrome ( x ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT for i in range ( len ( graph [ node ] ) ) : NEW_LINE INDENT if ( graph [ node ] [ i ] == parent ) : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( graph [ node ] [ i ] , node ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT weight . append ( " " ) NEW_LINE weight . append ( " abc " ) NEW_LINE weight . append ( " aba " ) NEW_LINE weight . append ( " bcb
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if a [ 1 ] == a [ 13 ] : NEW_LINE INDENT print ( " yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " no " ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i % 3 == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . append ( input ( ) ) NEW_LINE DEDENT s . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if s [ i ] == s [ j ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT ans //= 3 NEW_LINE print ( ans ) NEW_LINE
import sys NEW_LINE from sys import stdin NEW_LINE input = stdin . readline NEW_LINE def main ( args ) : NEW_LINE INDENT while True : NEW_LINE INDENT w , h = map ( int , input ( ) . split ( ) ) NEW_LINE if w == 0 and h == 0 : NEW_LINE INDENT break NEW_LINE DEDENT sx , sy = map ( int , input ( ) . split ( ) ) NEW_LINE gx , gy = map ( int , input ( ) . split ( ) ) NEW_LINE n = int ( input ( ) ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT c , d , x , y = map ( int , input ( ) . split ( ) ) NEW_LINE if d == 1 : NEW_LINE INDENT for i in range ( 4 ) : NEW_LINE INDENT for j in range ( 2 ) : NEW_LINE INDENT for k in range ( 4 ) : NEW_LINE INDENT for j in range ( 2 ) : NEW_LINE INDENT for k in range ( 4 ) : NEW_LINE INDENT for j in range ( 2 ) : NEW_LINE INDENT for k in range ( 2 ) : NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( a - b , b ) NEW_LINE DEDENT return gcd ( a , b - a ) NEW_LINE DEDENT a = 98 NEW_LINE b = 56 NEW_LINE print ( " GCD ▁ of " , a , " and " , b , " is " , gcd ( a , b ) ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT a = 98 NEW_LINE b = 56 NEW_LINE print ( " GCD ▁ of " , a , " and " , b , " is " , gcd ( a , b ) ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) // gcd ( a , b ) NEW_LINE DEDENT a = 15 NEW_LINE b = 20 NEW_LINE print ( " LCM ▁ of " , a , " and " , b , " is " , lcm ( a , b ) ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) // gcd ( a , b ) NEW_LINE DEDENT a = 15 NEW_LINE b = 20 NEW_LINE print ( " LCM ▁ of " , a , " and " , b , " is " , lcm ( a , b ) ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( a - b , b ) NEW_LINE DEDENT return gcd ( a , b - a ) NEW_LINE DEDENT a = 98 NEW_LINE b = 56 NEW_LINE print ( " GCD ▁ of " , a , " and " , b , " is " , gcd ( a , b ) ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT a = 98 NEW_LINE b = 56 NEW_LINE print ( " GCD ▁ of " , a , " and " , b , " is " , gcd ( a , b ) ) NEW_LINE
def compute ( ) : NEW_LINE INDENT return str ( tetration_mod ( 1777 , 1855 , pow ( 10 , 8 ) ) ) NEW_LINE DEDENT def tetration_mod ( x , y , m ) : NEW_LINE INDENT if ( y == 1 ) : NEW_LINE INDENT return x % m NEW_LINE DEDENT else : NEW_LINE INDENT return pow ( x , tetration_mod ( x , y - 1 , m ) , m ) NEW_LINE DEDENT DEDENT def tetration_mod ( x , y , m ) : NEW_LINE INDENT if ( y == 1 ) : NEW_LINE INDENT return x % m NEW_LINE DEDENT else : NEW_LINE INDENT return pow ( x , tetration_mod ( x , y - 1 , m ) , m ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def min_sum ( n , k , a ) : NEW_LINE INDENT a . sort ( ) NEW_LINE if ( a [ 0 ] < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT if ( a [ 0 ] == a [ n - 1 ] ) : NEW_LINE INDENT return ( n * a [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT f = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT p = a [ i ] - a [ 0 ] NEW_LINE if ( p % k == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT f = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( f > 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT return ( n * ( a [ 0 ] % k ) ) NEW_LINE DEDENT DEDENT
class Solution ( object ) : NEW_LINE INDENT def removeNthFromEnd ( self , head , n ) : NEW_LINE INDENT slow = head NEW_LINE fast = head NEW_LINE fast = head NEW_LINE for i in range ( n ) : NEW_LINE INDENT fast = fast . next NEW_LINE DEDENT if ( fast == None ) : NEW_LINE INDENT head = head . next NEW_LINE return head NEW_LINE DEDENT while ( fast . next != None ) : NEW_LINE INDENT fast = fast . next NEW_LINE slow = slow . next NEW_LINE DEDENT curr = slow . next NEW_LINE slow . next = curr . next NEW_LINE return head NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE nums = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = 2 NEW_LINE head = None NEW_LINE lastNode = None NEW_LINE out = sObj . removeNthFromEnd ( head , n ) NEW_LINE while ( out . next != None ) : NEW_LINE INDENT out . next = out . next NEW_LINE
def findMaxLenEven ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE i = 0 NEW_LINE currlen = 0 NEW_LINE maxlen = 0 NEW_LINE st = - 1 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( str [ i ] == ' ▁ ' ) : NEW_LINE INDENT if ( currlen % 2 == 0 ) : NEW_LINE INDENT if ( maxlen < currlen ) : NEW_LINE INDENT maxlen = currlen NEW_LINE st = i - currlen NEW_LINE DEDENT DEDENT currlen = 0 NEW_LINE DEDENT else : NEW_LINE INDENT currlen += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( currlen % 2 == 0 ) : NEW_LINE INDENT if ( maxlen < currlen ) : NEW_LINE INDENT maxlen = currlen NEW_LINE st = i - currlen NEW_LINE DEDENT DEDENT if ( st == - 1 ) : NEW_LINE INDENT return " - 1" NEW_LINE DEDENT return str [ st : st + maxlen ] NEW_LINE DEDENT if __name__ ==
def pairsInSortedRotated ( arr , n , x ) : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT l = ( i + 1 ) % n NEW_LINE r = i NEW_LINE cnt = 0 NEW_LINE while ( l != r ) : NEW_LINE INDENT if ( arr [ l ] + arr [ r ] == x ) : NEW_LINE INDENT cnt += 1 NEW_LINE if ( l == ( r - 1 + n ) % n ) : NEW_LINE INDENT return cnt NEW_LINE DEDENT l = ( l + 1 ) % n NEW_LINE r = ( r - 1 + n ) % n NEW_LINE DEDENT elif ( arr [ l ] + arr [ r ] < x ) : NEW_LINE INDENT l = ( l + 1 ) % n NEW_LINE DEDENT else : NEW_LINE INDENT r = ( n + r - 1 ) % n NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT arr = [ 11 , 15 , 6 , 7 , 9 , 10 ]
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = eulerlib . pow ( 10 , 6 ) NEW_LINE for n in range ( LIMIT , - 1 , - 1 ) : NEW_LINE INDENT if findLeastDivisibleRepunit ( n ) > LIMIT : NEW_LINE INDENT return str ( n ) NEW_LINE DEDENT DEDENT DEDENT def findLeastDivisibleRepunit ( n ) : NEW_LINE INDENT if ( n % 2 == 0 or n % 5 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n > sys . maxsize // 10 ) : NEW_LINE INDENT return " Arithmetic ▁ overflow " NEW_LINE DEDENT sum = 1 NEW_LINE pow = 1 NEW_LINE k = 1 NEW_LINE while ( sum % n != 0 ) : NEW_LINE INDENT k += 1 NEW_LINE pow = pow * 10 % n NEW_LINE sum = ( sum + pow ) % n NEW_LINE DEDENT return k NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def getPassingCars ( A , n ) : NEW_LINE INDENT countOne = 0 NEW_LINE result = 0 NEW_LINE while ( n >= 1 ) : NEW_LINE INDENT if ( A [ n - 1 ] == 1 ) : NEW_LINE INDENT countOne += 1 NEW_LINE DEDENT else : NEW_LINE INDENT result += countOne NEW_LINE DEDENT n -= 1 NEW_LINE DEDENT return result NEW_LINE DEDENT A = [ 0 , 1 , 0 , 1 , 1 ] NEW_LINE n = len ( A ) NEW_LINE print ( getPassingCars ( A , n ) ) NEW_LINE
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT for i in range ( 9 , 0 , 2 ) : NEW_LINE INDENT if eulerlib . is_prime ( i ) : NEW_LINE INDENT return str ( i ) NEW_LINE DEDENT DEDENT DEDENT def satisfiesConjecture ( n ) : NEW_LINE INDENT if n % 2 == 0 or eulerlib . is_prime ( n ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 1 , n + 1 , 2 ) : NEW_LINE INDENT if eulerlib . is_prime ( n - i * i * 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( reverse = True ) NEW_LINE ans = " YES " NEW_LINE for j in range ( n ) : NEW_LINE INDENT if a [ j ] - k < 0 : NEW_LINE INDENT ans = " NO " NEW_LINE break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def findMinRemoval ( arr , n ) : NEW_LINE INDENT value = 0 NEW_LINE maximum = 0 NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( i != 0 and i != n - 1 ) : NEW_LINE INDENT value = value + abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE temp = abs ( arr [ i ] - arr [ i - 1 ] ) + abs ( arr [ i - 1 ] - arr [ i + 1 ] ) - abs ( arr [ i - 1 ] - arr [ i + 1 ] ) NEW_LINE DEDENT elif ( i == 0 ) : NEW_LINE INDENT value = value + abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE temp = abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT temp = abs ( arr [ i ] - arr [ i - 1 ] ) NEW_LINE DEDENT maximum = max ( maximum , temp ) NEW_LINE DEDENT return ( value - maximum ) NEW_LINE DEDENT arr
def find ( n ) : NEW_LINE INDENT arr = [ " " ] * ( n + 1 ) ; NEW_LINE size = 1 ; m = 1 ; NEW_LINE while ( size <= n ) : NEW_LINE INDENT for i in range ( 0 , m and ( size + i ) <= n ) : NEW_LINE INDENT arr [ size + i ] = "3" + arr [ size - m + i ] ; NEW_LINE DEDENT for i in range ( 0 , m and ( size + m + i ) <= n ) : NEW_LINE INDENT arr [ size + m + i ] = "4" + arr [ size - m + i ] ; NEW_LINE DEDENT m = m << 1 ; NEW_LINE size = size + m ; NEW_LINE DEDENT print ( arr [ n ] ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT for i in range ( 1 , 16 ) : NEW_LINE INDENT find ( i ) ; NEW_LINE DEDENT DEDENT
def maxValue ( a , b ) : NEW_LINE INDENT b . sort ( ) NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE j = m - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( j < 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( b [ j ] > a [ i ] ) : NEW_LINE INDENT a [ i ] = b [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT return a NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = "1234" NEW_LINE b = "4321" NEW_LINE print ( maxValue ( a , b ) ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x , a = map ( int , input ( ) . split ( ) ) NEW_LINE a . append ( ( x , a ) ) NEW_LINE DEDENT a . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] < 0 : NEW_LINE INDENT a [ i ] = a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT b [ i ] = a [ i ] NEW_LINE DEDENT DEDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE ans = 0 NEW_LINE if len ( a ) == len ( b ) : NEW_LINE INDENT for i in range ( len ( a ) ) : NEW_LINE INDENT ans += a [ i ] + b [ i ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( len ( a ) ) : NEW_LINE INDENT ans += a [ i ] + b [ i ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_
def geometricMean ( arr , n ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT product = product * arr [ i ] NEW_LINE DEDENT gm = pow ( product , 1 / n ) NEW_LINE return gm NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( geometricMean ( arr , n ) ) NEW_LINE
def display ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if k % 2 == 0 : NEW_LINE INDENT print ( j , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE display ( n ) NEW_LINE
def countXorPair ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( ( arr [ i ] ^ arr [ j ] ) % 2 == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE print ( countXorPair ( arr , len ( arr ) ) ) NEW_LINE
def Square ( n , i , j ) : NEW_LINE INDENT mid = ( i + j ) / 2 NEW_LINE mul = mid * mid NEW_LINE if ( ( mul == n ) or ( abs ( mul - n ) < 0.00001 ) ) : NEW_LINE INDENT return mid NEW_LINE DEDENT elif ( mul < n ) : NEW_LINE INDENT return Square ( n , mid , j ) NEW_LINE DEDENT else : NEW_LINE INDENT return Square ( n , i , mid ) NEW_LINE DEDENT DEDENT def findSqrt ( n ) : NEW_LINE INDENT i = 1 NEW_LINE found = False NEW_LINE while ( not found ) : NEW_LINE INDENT if ( i * i == n ) : NEW_LINE INDENT print ( i ) NEW_LINE found = True NEW_LINE DEDENT elif ( i * i > n ) : NEW_LINE INDENT res = Square ( n , i - 1 , i ) NEW_LINE print ( " % . 5f " % res ) NEW_LINE found = True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT n = 3 NEW_LINE findSqrt ( n ) NEW_LINE
import sys NEW_LINE from sys import stdin NEW_LINE input = stdin . readline NEW_LINE def main ( args ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] + b [ i ] < a [ i ] + b [ i ] : NEW_LINE INDENT ans += a [ i ] + b [ i ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
def combinationUtil ( arr , data , start , end , index , r ) : NEW_LINE INDENT if ( index == r ) : NEW_LINE INDENT for j in range ( r ) : NEW_LINE INDENT print ( data [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( " " ) NEW_LINE return NEW_LINE DEDENT for i in range ( start , end + 1 , - 1 ) : NEW_LINE INDENT data [ index ] = arr [ i ] NEW_LINE combinationUtil ( arr , data , i + 1 , end , index + 1 , r ) NEW_LINE DEDENT DEDENT def printCombination ( arr , n , r ) : NEW_LINE INDENT data = [ 0 ] * r NEW_LINE combinationUtil ( arr , data , 0 , n - 1 , 0 , r ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE r = 3 NEW_LINE n = len ( arr ) NEW_LINE printCombination ( arr , n , r ) NEW_LINE
def combinationUtil ( arr , n , r , index , data , i ) : NEW_LINE INDENT if ( index == r ) : NEW_LINE INDENT for j in range ( r ) : NEW_LINE INDENT print ( data [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( " " ) NEW_LINE return NEW_LINE DEDENT if ( i >= n ) : NEW_LINE INDENT return NEW_LINE DEDENT data [ index ] = arr [ i ] NEW_LINE combinationUtil ( arr , n , r , index + 1 , data , i + 1 ) NEW_LINE combinationUtil ( arr , n , r , index , data , i + 1 ) NEW_LINE DEDENT def printCombination ( arr , n , r ) : NEW_LINE INDENT data = [ 0 ] * r NEW_LINE combinationUtil ( arr , n , r , 0 , data , 0 ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE r = 3 NEW_LINE n = len ( arr ) NEW_LINE printCombination ( arr , n , r ) NEW_LINE
def bitwiseAndOdd ( n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 3 , n + 1 , 2 ) : NEW_LINE INDENT result = ( result & i ) NEW_LINE DEDENT return result NEW_LINE DEDENT n = 10 NEW_LINE print ( bitwiseAndOdd ( n ) ) NEW_LINE
def findTangent ( A , x , y ) : NEW_LINE INDENT dif = A - x * 2 NEW_LINE if ( y == ( 2 * x - x * x ) ) : NEW_LINE INDENT if ( dif < 0 ) : NEW_LINE INDENT print ( " y ▁ = ▁ " , dif , " x " , ( x * dif + y ) ) NEW_LINE DEDENT elif ( dif > 0 ) : NEW_LINE INDENT print ( " y ▁ = ▁ " , dif , " x " , - x * dif + y ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ possible " ) NEW_LINE DEDENT DEDENT DEDENT A = 2 NEW_LINE x = 2 NEW_LINE y = 0 NEW_LINE findTangent ( A , x , y ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( max ( a ) - min ( a ) ) NEW_LINE DEDENT
def countRotationsDivBy8 ( n ) : NEW_LINE INDENT len = len ( n ) NEW_LINE count = 0 NEW_LINE if ( len == 1 ) : NEW_LINE INDENT oneDigit = n [ 0 ] - '0' NEW_LINE if ( oneDigit % 8 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( len == 2 ) : NEW_LINE INDENT first = ( n [ 0 ] - '0' ) * 10 + ( n [ 1 ] - '0' ) NEW_LINE second = ( n [ 1 ] - '0' ) * 10 + ( n [ 0 ] - '0' ) NEW_LINE if ( first % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( second % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT threeDigit = ( n [ len - 1 ] - '0' ) * 100 + ( n [ 0 ] - '0' ) * 10 + ( n [ 1 ] - '0' ) NEW_LINE if ( threeDigit % 8 == 0 ) : NEW
def max_element ( a ) : NEW_LINE INDENT m = a [ 0 ] NEW_LINE for i in range ( 0 , len ( a ) ) : NEW_LINE INDENT m = max ( a [ i ] , m ) NEW_LINE DEDENT return m NEW_LINE DEDENT def primeCount ( arr , n ) : NEW_LINE INDENT max_val = max_element ( arr ) NEW_LINE prime = [ True ] * ( max_val + 1 ) NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , max_val + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT def getPrefixArray ( arr , n , pre ) : NEW
def interLeaveQueue ( q ) : NEW_LINE INDENT if ( len ( q ) % 2 != 0 ) : NEW_LINE INDENT print ( " Input ▁ even ▁ number ▁ of ▁ integers . " ) NEW_LINE DEDENT s = [ ] NEW_LINE halfSize = int ( len ( q ) / 2 ) NEW_LINE for i in range ( halfSize ) : NEW_LINE INDENT s . append ( s [ - 1 ] ) NEW_LINE s . pop ( ) NEW_LINE DEDENT for i in range ( halfSize ) : NEW_LINE INDENT q . append ( q [ - 1 ] ) NEW_LINE q . pop ( ) NEW_LINE DEDENT while ( len ( s ) != 0 ) : NEW_LINE INDENT s . append ( q [ - 1 ] ) NEW_LINE q . pop ( ) NEW_LINE DEDENT while ( len ( s ) != 0 ) : NEW_LINE INDENT s . append ( s [ - 1 ] ) NEW_LINE s . pop ( ) NEW_LINE DEDENT while ( len ( s ) != 0 ) : NEW_LINE INDENT s . append ( s [ - 1 ] ) NEW_
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def solve ( ) : NEW_LINE INDENT n , m , n = map ( int , input ( ) . split ( ) ) NEW_LINE floors = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT floors . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT floors . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if floors [ i ] [ j ] == 0 : NEW_LINE INDENT print ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT solve ( ) NEW_LINE
def GCD ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return GCD ( b , a % b ) NEW_LINE DEDENT def findRatio ( m , n ) : NEW_LINE INDENT Am = m - 5 NEW_LINE An = n - 5 NEW_LINE numerator = Am // GCD ( Am , An ) NEW_LINE denominator = An // GCD ( Am , An ) NEW_LINE print ( numerator , " / " , denominator ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT m = 10 NEW_LINE n = 20 NEW_LINE findRatio ( m , n ) NEW_LINE DEDENT
import math NEW_LINE M_E = 2.71828182845904523536 NEW_LINE M_PI = 3.141592654 NEW_LINE def findDigits ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT x = ( n * math . log10 ( n / M_E ) + math . log10 ( 2 * M_PI * n ) / 2.0 ) NEW_LINE return int ( math . floor ( x ) + 1 ) NEW_LINE DEDENT print ( findDigits ( 1 ) ) NEW_LINE print ( findDigits ( 50000000 ) ) NEW_LINE print ( findDigits ( 120 ) ) NEW_LINE print ( findDigits ( 120 ) ) NEW_LINE
def find_sum ( n , k ) : NEW_LINE INDENT total_sum = ( n * ( n + 1 ) ) // 2 NEW_LINE power = k NEW_LINE while ( power <= n ) : NEW_LINE INDENT total_sum -= power NEW_LINE power *= k NEW_LINE DEDENT return total_sum NEW_LINE DEDENT n = 11 NEW_LINE k = 2 NEW_LINE print ( find_sum ( n , k ) ) NEW_LINE
def FirstDigit ( arr , n ) : NEW_LINE INDENT S = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT S = S + log10 ( arr [ i ] * 1.0 ) NEW_LINE DEDENT fract_S = S - floor ( S ) NEW_LINE ans = pow ( 10 , fract_S ) NEW_LINE return ans NEW_LINE DEDENT arr = [ 5 , 8 , 3 , 7 ] NEW_LINE print ( FirstDigit ( arr , len ( arr ) ) ) NEW_LINE
def findSum ( arr , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % k == 0 ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT arr = [ 15 , 16 , 10 , 9 , 6 , 7 , 17 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( findSum ( arr , n , k ) ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE l . append ( a + b ) NEW_LINE l . append ( c - d ) NEW_LINE l . append ( d + c - d ) NEW_LINE DEDENT print ( sum ( l ) // 2 ) NEW_LINE
while True : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 and m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if a [ i ] + b [ j ] == c [ j ] + a [ i ] : NEW_LINE INDENT c [ i ] , c [ j ] = c [ j ] , c [ i ] NEW_LINE DEDENT DEDENT DEDENT print ( c [ 0 ] , c [ 1 ] ) NEW_LINE DEDENT
class Solution ( object ) : NEW_LINE INDENT def fixedPoint ( self , A ) : NEW_LINE INDENT l = 0 NEW_LINE h = len ( A ) NEW_LINE while ( l <= h ) : NEW_LINE INDENT mid = ( l + h ) // 2 NEW_LINE if ( A [ mid ] > mid ) : NEW_LINE INDENT h = mid - 1 NEW_LINE DEDENT elif ( A [ mid ] < mid ) : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return mid NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE A = [ - 10 , - 5 , 0 , 3 , 7 ] NEW_LINE out = sObj . fixedPoint ( A ) NEW_LINE print ( out ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT ans += min ( a [ i ] [ j ] , a [ j ] [ i ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def remAnagram ( str1 , str2 ) : NEW_LINE INDENT count1 = [ 0 ] * 26 NEW_LINE count2 = [ 0 ] * 26 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT count1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( str2 ) ) : NEW_LINE INDENT count2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT result += abs ( count1 [ i ] - count2 [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str1 = " bcadeh " NEW_LINE str2 = " hea " NEW_LINE print ( remAnagram ( str1 , str2 ) ) NEW_LINE DEDENT
def polyarea ( n , r ) : NEW_LINE INDENT if ( r < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = ( ( r * r * n ) * math . sin ( ( 360 / n ) * 3.14159 / 180 ) ) / 2 NEW_LINE return A NEW_LINE DEDENT r = 9 NEW_LINE n = 6 NEW_LINE print ( polyarea ( n , r ) ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT s = input ( ) NEW_LINE a = set ( s ) NEW_LINE for j in range ( len ( s ) ) : NEW_LINE INDENT a . add ( s [ j ] ) NEW_LINE DEDENT if len ( a ) == 1 or len ( a ) == len ( s ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def surfaceArea ( b , s ) : NEW_LINE INDENT return 2 * b * s + pow ( b , 2 ) NEW_LINE DEDENT b = 3 NEW_LINE s = 4 NEW_LINE print ( surfaceArea ( b , s ) ) NEW_LINE
def count ( s , len ) : NEW_LINE INDENT MAX = 1000 NEW_LINE cur = 0 NEW_LINE dig = 0 NEW_LINE sum = [ 0 ] * MAX NEW_LINE dp = [ 0 ] * MAX NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , len ) : NEW_LINE INDENT dig = ord ( s [ i - 1 ] ) - 48 NEW_LINE cur += dig NEW_LINE cur %= 3 NEW_LINE sum [ i ] = cur NEW_LINE dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] NEW_LINE dp [ i ] [ 1 ] = dp [ i - 1 ] [ 1 ] NEW_LINE dp [ i ] [ 2 ] = dp [ i - 1 ] [ 2 ] NEW_LINE dp [ i ] [ sum [ i ] ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE dprev = 0 NEW_LINE value = 0 NEW_LINE dprev2 = 0 NEW_LINE for i in range ( 1 , len ) : NEW_LINE INDENT dig = ord ( s [ i - 1 ] ) - 48 NEW_LINE if dig == 8 : NEW_
def sieve ( maxm , prime ) : NEW_LINE INDENT prime [ 0 ] = prime [ 1 ] = 1 NEW_LINE for i in range ( 2 , int ( maxm ** 0.5 ) + 1 ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( 2 * i , maxm + 1 , i ) : NEW_LINE INDENT prime [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def countPair ( a , n ) : NEW_LINE INDENT maxm = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] > maxm ) : NEW_LINE INDENT maxm = a [ i ] NEW_LINE DEDENT DEDENT prime = [ 0 ] * ( maxm + 1 ) NEW_LINE sieve ( maxm , prime ) NEW_LINE countPrimes = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ a [ i ] ] == 0 ) : NEW_LINE INDENT countPrimes += 1 NEW_LINE DEDENT DEDENT nonPrimes = n - countPrimes
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == s [ i + 1 ] and s [ i + 2 ] == s [ i + 3 ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def sortString ( string ) : NEW_LINE INDENT arr = sorted ( string ) NEW_LINE print ( arr ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE sortString ( s ) NEW_LINE DEDENT
for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE print ( n ) NEW_LINE a = [ i + 1 for i in range ( n ) ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT a [ i ] , a [ i + 1 ] = a [ i ] , a [ i + 1 ] NEW_LINE DEDENT print ( n ) NEW_LINE print ( * a ) NEW_LINE DEDENT
def printNumber ( n ) : NEW_LINE INDENT count = [ 0 for i in range ( 10 ) ] NEW_LINE while ( n > 0 ) : NEW_LINE INDENT count [ n % 10 ] += 1 NEW_LINE n //= 10 NEW_LINE DEDENT for i in range ( 1 , 10 ) : NEW_LINE INDENT for j in range ( count [ i ] * i ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT DEDENT n = 3225 NEW_LINE printNumber ( n ) NEW_LINE
def getMax ( Arr ) : NEW_LINE INDENT max = Arr [ 0 ] NEW_LINE for i in range ( 1 , len ( Arr ) ) : NEW_LINE INDENT if ( Arr [ i ] > max ) : NEW_LINE INDENT max = Arr [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT def maxPrimefactorNum ( N ) : NEW_LINE INDENT arr = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT for j in range ( 2 * i , N + 1 , i ) : NEW_LINE INDENT arr [ j ] += 1 NEW_LINE DEDENT DEDENT arr [ i ] = 1 NEW_LINE DEDENT return getMax ( arr ) NEW_LINE DEDENT N = 40 NEW_LINE print ( maxPrimefactorNum ( N ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] <= a [ i ] : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE print ( n ) NEW_LINE
