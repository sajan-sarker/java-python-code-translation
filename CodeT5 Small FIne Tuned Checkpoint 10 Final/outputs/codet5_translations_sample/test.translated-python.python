import sys NEW_LINE from sys import stdin NEW_LINE input = stdin . readline NEW_LINE def is_prime ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if n % 2 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT def is_prime ( n ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def is_prime_number ( n ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT def is_prime_number_list ( n ) : NEW_LINE INDENT prime_number_list = [ ] NEW_LINE for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT if is_prime_number ( i ) : NEW_LINE INDENT prime_number_list . append ( i ) NEW_LINE DEDENT DEDENT
MAX_CHAR = 26 NEW_LINE def countFreq ( str , freq , len ) : NEW_LINE INDENT for i in range ( len ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT DEDENT def canMakePalindrome ( freq , len ) : NEW_LINE INDENT count_odd = 0 NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT if ( freq [ i ] % 2 != 0 ) : NEW_LINE INDENT count_odd += 1 NEW_LINE DEDENT DEDENT if ( len % 2 == 0 ) : NEW_LINE INDENT if ( count_odd > 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def findOddAndRemoveItsFreq ( freq ) : NEW_LINE INDENT odd_str = " " NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT if ( freq [ i ] % 2 != 0 ) : NEW_LINE INDENT freq [ i ] -= 1 NEW_LINE odd_str = odd_str
import sys NEW_LINE input = sys . stdin . readline NEW_LINE q = int ( input ( ) ) NEW_LINE for _ in range ( q ) : NEW_LINE INDENT a , b , c , d = map ( float , input ( ) . split ( ) ) NEW_LINE if a > b : NEW_LINE INDENT a , b = b , a NEW_LINE DEDENT print ( min ( [ c , d ] ) ) NEW_LINE DEDENT
def count9s ( number ) : NEW_LINE INDENT n = len ( number ) NEW_LINE d = [ 0 ] * 9 NEW_LINE d [ 0 ] = 1 NEW_LINE result = 0 NEW_LINE mod_sum = 0 NEW_LINE continuous_zero = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( number [ i ] - '0' ) == 0 ) : NEW_LINE INDENT continuous_zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT continuous_zero = 0 NEW_LINE DEDENT mod_sum += ( int ( number [ i ] ) - '0' ) NEW_LINE mod_sum %= 9 NEW_LINE result += d [ mod_sum ] NEW_LINE d [ mod_sum ] += 1 NEW_LINE result -= continuous_zero NEW_LINE DEDENT return result NEW_LINE DEDENT print ( count9s ( "01809" ) ) NEW_LINE print ( count9s ( "1809" ) ) NEW_LINE print ( count9s ( "4189" ) ) NEW_LINE
def fastPow ( N , K ) : NEW_LINE INDENT if ( K == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT temp = fastPow ( N , K // 2 ) NEW_LINE if ( K % 2 == 0 ) : NEW_LINE INDENT return temp * temp NEW_LINE DEDENT else : NEW_LINE INDENT return N * temp * temp NEW_LINE DEDENT DEDENT def countWays ( N , K ) : NEW_LINE INDENT return K * fastPow ( K - 1 , N - 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 3 NEW_LINE K = 3 NEW_LINE print ( countWays ( N , K ) ) NEW_LINE DEDENT
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == - 1 : NEW_LINE INDENT break NEW_LINE DEDENT m = [ int ( input ( ) ) for _ in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ i ] = int ( input ( ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( m [ i ] ^ m [ i ] ) NEW_LINE DEDENT DEDENT
MAX = 10000 NEW_LINE arr = [ ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime = [ True ] * MAX NEW_LINE for p in range ( 2 , int ( MAX ** ( 1 / 2 ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , MAX , 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT arr . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def isEuclid ( n ) : NEW_LINE INDENT product = 1 NEW_LINE i = 0 NEW_LINE while ( product < n ) : NEW_LINE INDENT product = product * arr [ i ] NEW_LINE if ( product + 1 == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE
MAX = 1000000 NEW_LINE arr = [ ] NEW_LINE prime = [ True ] * MAX NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT p = 2 NEW_LINE while ( p * p < MAX ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , MAX , 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT arr . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def isPrimorialPrime ( n ) : NEW_LINE INDENT if ( not prime [ n ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT product = 1 NEW_LINE i = 0 NEW_LINE while ( product < n ) : NEW_LINE INDENT product = product * arr [ i ] NEW_LINE if ( product + 1 == n or product - 1 == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW
def mul_table ( N , i ) : NEW_LINE INDENT if ( i > 10 ) : NEW_LINE INDENT return NEW_LINE DEDENT print ( N , " ▁ * ▁ " , i , " ▁ = " , N * i ) NEW_LINE mul_table ( N , i + 1 ) NEW_LINE DEDENT N = 8 NEW_LINE mul_table ( N , 1 ) NEW_LINE
def closestNumber ( n , m ) : NEW_LINE INDENT q = n // m NEW_LINE n1 = m * q NEW_LINE n2 = ( m * ( q + 1 ) ) NEW_LINE if ( n * m ) : NEW_LINE INDENT return n1 NEW_LINE DEDENT return n2 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 13 NEW_LINE m = 4 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE n = - 15 NEW_LINE m = 6 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE n = 0 NEW_LINE m = 8 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE n = 18 NEW_LINE m = - 7 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE DEDENT
def solve ( ang , n ) : NEW_LINE INDENT if ( ( ang * n ) > ( 180 * ( n - 2 ) ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( ( ang * n ) % 180 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = 1 NEW_LINE freq = ( ang * n ) // 180 NEW_LINE ans = ans * ( n - 1 - freq ) NEW_LINE ans = ans * n NEW_LINE return ans NEW_LINE DEDENT ang = 90 NEW_LINE n = 4 NEW_LINE print ( solve ( ang , n ) ) NEW_LINE
def compute_lps ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE lps = [ 0 ] * n NEW_LINE lps [ 0 ] = 0 NEW_LINE i = 1 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( s [ i ] == s [ len ( s ) - 1 ] ) : NEW_LINE INDENT lps [ i ] = len ( lps ) NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( len != 0 ) : NEW_LINE INDENT len = lps [ len - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lps [ i ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT return lps NEW_LINE DEDENT def Longestsubstring ( s ) : NEW_LINE INDENT lps = compute_lps ( s ) NEW_LINE n = len ( s ) NEW_LINE if ( lps [ n - 1 ] == 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT if ( lps
def checkIfSortRotated ( arr , n ) : NEW_LINE INDENT minEle = sys . maxsize NEW_LINE maxEle = - sys . maxsize NEW_LINE minIndex = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < minEle ) : NEW_LINE INDENT minEle = arr [ i ] NEW_LINE minIndex = i NEW_LINE DEDENT DEDENT flag1 = True NEW_LINE for i in range ( 1 , minIndex ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i - 1 ] ) : NEW_LINE INDENT flag1 = False NEW_LINE break NEW_LINE DEDENT DEDENT flag2 = True NEW_LINE for i in range ( minIndex + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i - 1 ] ) : NEW_LINE INDENT flag2 = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( minIndex == 0 ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE return NEW_LINE DEDENT if ( flag1 and flag2 and ( arr [ n - 1 ] < arr [ minIndex - 1 ]
n , d = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT while a [ i ] <= a [ i + 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE a [ i + 1 ] -= a [ i ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def checkIfPowerIsolated ( num ) : NEW_LINE INDENT input = num NEW_LINE count = 0 NEW_LINE factor = [ 0 ] * ( num + 1 ) NEW_LINE if ( num % 2 == 0 ) : NEW_LINE INDENT while ( num % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE num //= 2 NEW_LINE DEDENT factor [ 2 ] = count NEW_LINE DEDENT for i in range ( 3 , int ( num ** 0.5 ) + 1 , 2 ) : NEW_LINE INDENT count = 0 NEW_LINE while ( num % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE num //= i NEW_LINE DEDENT if ( count > 0 ) : NEW_LINE INDENT factor [ i ] = count NEW_LINE DEDENT DEDENT if ( num > 1 ) : NEW_LINE INDENT factor [ num ] = 1 NEW_LINE DEDENT product = 1 NEW_LINE for i in range ( num + 1 ) : NEW_LINE INDENT if ( factor [ i ] > 0 ) : NEW_LINE INDENT product = product * factor [ i ] * i NEW_LINE DEDENT DEDENT if ( product == input ) :
s = input ( ) NEW_LINE if len ( s ) % 2 == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( len ( s ) // 2 ) : NEW_LINE INDENT if s [ i ] == ' A ' or s [ i ] == ' Z ' : NEW_LINE INDENT print ( ' AZ ' , end = ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Z ' , end = ' ' ) NEW_LINE DEDENT DEDENT DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] in d : NEW_LINE INDENT d [ a [ i ] ] = d [ a [ i ] ] NEW_LINE DEDENT else : NEW_LINE INDENT d [ a [ i ] ] = d [ a [ i ] ] NEW_LINE DEDENT DEDENT print ( max ( d . values ( ) ) ) NEW_LINE DEDENT
def multiply ( num1 , num2 ) : NEW_LINE INDENT len1 = len ( num1 ) NEW_LINE len2 = len ( num2 ) NEW_LINE if ( len1 == 0 or len2 == 0 ) : NEW_LINE INDENT return "0" NEW_LINE DEDENT result = [ 0 ] * ( len1 + len2 ) NEW_LINE i_n1 = 0 NEW_LINE i_n2 = 0 NEW_LINE for i in range ( len1 - 1 , - 1 , - 1 ) : NEW_LINE INDENT carry = 0 NEW_LINE n1 = ord ( num1 [ i ] ) - ord ( '0' ) NEW_LINE i_n2 = 0 NEW_LINE for j in range ( len2 - 1 , - 1 , - 1 ) : NEW_LINE INDENT n2 = ord ( num2 [ j ] ) - ord ( '0' ) NEW_LINE sum = n1 * n2 + result [ i_n1 + i_n2 ] + carry NEW_LINE carry = sum // 10 NEW_LINE result [ i_n1 + i_n2 ] = sum % 10 NEW_LINE i_n2 += 1 NEW
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if sum ( a ) >= sum ( b ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE if k > n // 2 : NEW_LINE INDENT print ( " RIGHT " ) NEW_LINE DEDENT elif k == 1 : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( " PRINT " , s [ i ] ) NEW_LINE if ( i + 1 < n ) : NEW_LINE INDENT print ( " RIGHT " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " LEFT " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( " PRINT " , s [ i ] ) NEW_LINE if ( i + 1 < n ) : NEW_LINE INDENT print ( " RIGHT " ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( " LEFT " , s [ i ] ) NEW_LINE if ( i + 1 < n ) : NEW_LINE INDENT print ( " RIGHT " ) NEW_LINE DEDENT DEDENT DEDENT