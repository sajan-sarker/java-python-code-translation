def calculateSquareSum ( n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT fibo = [ 0 ] * ( n + 1 ) NEW_LINE fibo [ 0 ] = 0 NEW_LINE fibo [ 1 ] = 1 NEW_LINE sum = ( fibo [ 0 ] * fibo [ 0 ] ) + ( fibo [ 1 ] * fibo [ 1 ] ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] NEW_LINE sum += ( fibo [ i ] * fibo [ i ] ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 6 NEW_LINE print ( " Sum ▁ of ▁ squares ▁ of ▁ Fibonacci ▁ numbers ▁ is ▁ : " , calculateSquareSum ( n ) ) NEW_LINE
s1 = input ( ) NEW_LINE s2 = input ( ) NEW_LINE k = int ( input ( ) ) NEW_LINE if s1 == s2 : NEW_LINE INDENT print ( 0 ) NEW_LINE exit ( ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , len ( s1 ) ) : NEW_LINE INDENT if s1 [ i ] == s2 [ i ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT if k % 2 == 0 : NEW_LINE INDENT ans %= 1000000007 NEW_LINE DEDENT else : NEW_LINE INDENT ans %= 1000000007 NEW_LINE DEDENT print ( ans ) NEW_LINE
while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . append ( list ( input ( ) . split ( ) ) ) NEW_LINE DEDENT s . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if s [ j ] [ 0 ] == s [ j ] [ 1 ] : NEW_LINE INDENT print ( s [ j ] [ 0 ] , s [ j ] [ 1 ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if a [ i ] == 0 and a [ i - 1 ] == 1 and a [ i + 1 ] == 1 : NEW_LINE INDENT ans += 1 NEW_LINE if i <= n - 4 : NEW_LINE INDENT if a [ i + 2 ] == 1 and a [ i + 3 ] == 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
def val ( c ) : NEW_LINE INDENT if ( c >= '0' and c <= '9' ) : NEW_LINE INDENT return ord ( c ) - ord ( '0' ) NEW_LINE DEDENT else : NEW_LINE INDENT return ord ( c ) - ord ( ' A ' ) + 10 NEW_LINE DEDENT DEDENT def toDeci ( str , base ) : NEW_LINE INDENT len = len ( str ) NEW_LINE power = 1 NEW_LINE num = 0 NEW_LINE for i in range ( len - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( val ( str [ i ] ) >= base ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT num += val ( str [ i ] ) * power NEW_LINE power = power * base NEW_LINE DEDENT return num NEW_LINE DEDENT def checkCorrespond ( str , x ) : NEW_LINE INDENT counter = 0 NEW_LINE n = len ( str ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 2 , 36 ) : NEW_LINE INDENT if ( toDeci ( str [ i ] , j ) == x
s = input ( ) NEW_LINE a = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT a . append ( int ( s [ i ] ) ) NEW_LINE DEDENT for i in range ( len ( s ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if s [ i ] == '0' : NEW_LINE INDENT a . append ( int ( s [ i ] ) ) NEW_LINE DEDENT DEDENT print ( max ( a ) ) NEW_LINE
n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > b [ i ] : NEW_LINE INDENT print ( " YES " ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
import heapq NEW_LINE from collections import deque NEW_LINE from enum import Enum NEW_LINE import sys NEW_LINE import math NEW_LINE from _heapq import heappush , heappop NEW_LINE import copy NEW_LINE BIG_NUM = 2000000000 NEW_LINE HUGE_NUM = 99999999999999999 NEW_LINE MOD = 1000000007 NEW_LINE EPS = 0.000000001 NEW_LINE sys . setrecursionlimit ( 100000 ) NEW_LINE N = int ( input ( ) ) NEW_LINE A = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE A . append ( ( a , b ) ) NEW_LINE DEDENT A . sort ( ) NEW_LINE S = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT S += A [ i ] [ 0 ] NEW_LINE while S < S : NEW_LINE INDENT S -= A [ i ] [ 0 ] NEW_LINE S -= A [ i ] [ 1 ] NEW_LINE DEDENT if S > S : NEW_LINE INDENT S = S NEW_LINE
def maxDivide ( a , b ) : NEW_LINE INDENT while ( a % b == 0 ) : NEW_LINE INDENT a = a // b NEW_LINE DEDENT return a NEW_LINE DEDENT def isUgly ( no ) : NEW_LINE INDENT no = maxDivide ( no , 2 ) NEW_LINE no = maxDivide ( no , 3 ) NEW_LINE no = maxDivide ( no , 5 ) NEW_LINE return ( no == 1 ) NEW_LINE DEDENT def getNthUglyNo ( n ) : NEW_LINE INDENT i = 1 NEW_LINE count = 1 NEW_LINE while ( n > count ) : NEW_LINE INDENT i += 1 NEW_LINE if ( isUgly ( i ) == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return i NEW_LINE DEDENT no = getNthUglyNo ( 150 ) NEW_LINE print ( " 150th ▁ ugly ▁ no . ▁ is " , no ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l [ i ] > l [ i ] : NEW_LINE INDENT print ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT
import math NEW_LINE def perfectSquares ( l , r ) : NEW_LINE INDENT number = math . ceil ( math . sqrt ( l ) ) NEW_LINE n2 = number * number NEW_LINE number = ( number * 2 ) + 1 NEW_LINE while ( ( n2 >= l and n2 <= r ) ) : NEW_LINE INDENT print ( n2 , end = " ▁ " ) NEW_LINE n2 = n2 + number NEW_LINE number += 2 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l = 2 NEW_LINE r = 24 NEW_LINE perfectSquares ( l , r ) NEW_LINE DEDENT
import math NEW_LINE def CheckArray ( arr , n ) : NEW_LINE INDENT prod = 1 NEW_LINE freq = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq . append ( arr [ i ] ) NEW_LINE prod *= arr [ i ] NEW_LINE DEDENT root = int ( math . sqrt ( prod ) ) NEW_LINE if ( root * root == prod ) : NEW_LINE INDENT if ( freq . contains ( root ) and freq . lastIndexOf ( root ) != ( len ( freq ) ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 12 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE if ( CheckArray ( arr , n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def findNumbers ( N ) : NEW_LINE INDENT i = 1 NEW_LINE while ( i <= N ) : NEW_LINE INDENT print ( ( i * i * i ) , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT N = 4 NEW_LINE findNumbers ( N ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if a [ i ] + a [ j ] < m : NEW_LINE INDENT m -= a [ i ] + a [ j ] NEW_LINE a [ j ] = i NEW_LINE DEDENT DEDENT DEDENT print ( ' NA ' ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE if a [ 0 ] == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif a [ - 1 ] == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 0 : NEW_LINE INDENT print ( i + 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT print ( a [ 0 ] + a [ - 1 ] ) NEW_LINE DEDENT DEDENT
n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] != a [ i ] : NEW_LINE INDENT ans += abs ( a [ i ] - a [ i ] ) NEW_LINE DEDENT if a [ i ] != a [ i ] : NEW_LINE INDENT ans += abs ( a [ i ] - a [ i ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = len ( input ( ) ) NEW_LINE d = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT d [ ord ( input ( ) ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT DEDENT d = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT d [ ord ( input ( ) ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT d [ ord ( input ( ) ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if d [ i ] [ j ] == 1 : NEW_LINE INDENT ans += d [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
def countIntervals ( arr , V , N ) : NEW_LINE INDENT count = 0 NEW_LINE li = ri = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT li = arr [ i ] [ 0 ] NEW_LINE ri = arr [ i ] [ 1 ] NEW_LINE if ( V >= li and V <= ri ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ [ 1 , 10 ] , [ 5 , 10 ] , [ 15 , 25 ] , [ 7 , 12 ] , [ 20 , 25 ] ] NEW_LINE V = 7 NEW_LINE N = len ( arr ) NEW_LINE print ( countIntervals ( arr , V , N ) ) NEW_LINE
def msbPos ( n ) : NEW_LINE INDENT msb_p = - 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = n >> 1 NEW_LINE msb_p += 1 NEW_LINE DEDENT return msb_p NEW_LINE DEDENT def andOperator ( x , y ) : NEW_LINE INDENT res = 0 NEW_LINE while ( x > 0 and y > 0 ) : NEW_LINE INDENT msb_p1 = msbPos ( x ) NEW_LINE msb_p2 = msbPos ( y ) NEW_LINE if ( msb_p1 != msb_p2 ) : NEW_LINE INDENT break NEW_LINE DEDENT msb_val = ( 1 << msb_p1 ) NEW_LINE res = res + msb_val NEW_LINE x = x - msb_val NEW_LINE y = y - msb_val NEW_LINE DEDENT return res NEW_LINE DEDENT x = 10 NEW_LINE y = 15 NEW_LINE print ( andOperator ( x , y ) ) NEW_LINE
def lengthOfLastWord ( a ) : NEW_LINE INDENT char_flag = False NEW_LINE len = 0 NEW_LINE for i in range ( len ( a ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if a [ i ] . isupper ( ) : NEW_LINE INDENT char_flag = True NEW_LINE len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if char_flag == True : NEW_LINE INDENT return len NEW_LINE DEDENT DEDENT DEDENT return len NEW_LINE DEDENT input = " Geeks ▁ For ▁ Geeks ▁ " NEW_LINE print ( " The ▁ length ▁ of ▁ last ▁ word ▁ is " , lengthOfLastWord ( input ) ) NEW_LINE